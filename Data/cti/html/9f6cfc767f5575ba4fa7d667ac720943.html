<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#" style="height: 100%; width: 100%; border: 0; padding: 0; margin: 0; overflow: hidden;">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, minimal-ui">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="ck5AZ7xFZB5Mr3WmxRv1oTkWl6g9X4zOHTfaRUmNtPyICRGRS134I4bb7IwNyvO8yKDgkr8n4UOvD7lXouqbDw==" />
    <title>Malicious Activity Report: Elements of Lokibot Infostealer - 20190131</title>
      <meta name="robots" content="index, follow" />

      <link rel="shortcut icon" href="https://app.cdn.lookbookhq.com/lbhq-production/10336/thumbnails/original/da1f4bd8-8310-44d4-8718-6ffa9dabbd24.png" />
    <meta property="og:site_name" content="Infoblox" />
<meta property="og:title" content="Malicious Activity Report: Elements of Lokibot Infostealer - 20190131" />
<meta property="og:description" content="Read more about the Lokibot threat characteristics" />
<meta property="og:image" content="https://app.cdn.lookbookhq.com/production/content-previews/cfd88ad4-3c12-4c0f-9078-fa101f72d69f/1024_1562614723-01.png" />
<meta property="og:image:width" content="576" />
<meta property="og:image:height" content="384" />
<meta property="og:type" content="website" />

  <meta property="og:url" content="https://insights.infoblox.com/threat-intelligence-reports/threat-intelligence--22" />


<meta name="twitter:site" content="@infoblox" />
<meta name="twitter:title" content="Malicious Activity Report: Elements of Lokibot Infostealer - 20190131" />
<meta name="twitter:description" content="Read more about the Lokibot threat characteristics" />
<meta name="twitter:image" content="https://app.cdn.lookbookhq.com/production/content-previews/cfd88ad4-3c12-4c0f-9078-fa101f72d69f/1024_1562614723-01.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:creator" content="@infoblox" />
<meta name="description" content="Read more about the Lokibot threat characteristics" />
    <base href="/">
    <link href="//fonts.googleapis.com/css?family=Roboto:400,700|Lato:400,700" media="screen" rel="stylesheet" type="text/css">
    <link href= "//maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" media="screen" rel="stylesheet" type="text/css">
    <link href="https://overpass-30e2.kxcdn.com/overpass.css" rel="stylesheet" type="text/css">
    <Style>
	</Style>
    




    





      <!-- RUN EXTERNAL CODE IN BOTTOM BODY TAG -->
<!-- START CONFIGURATION -->
<script>
  var linkUrl = "https://info.infoblox.com/WW-CRQ-FY19-infoblox-cyber-threat-reports.html"; // CTA link
  var linkText = "Stay up to date on the latest Cyber Threats"; // CTA text
</script>
<style>
  .cta {
    font-family: inherit;
    font-size: 14px;
    color: #ffffff !important;
    border: 1px solid #f47a28;
    border-radius: 3px;
    background-color: #f47a28;
    text-decoration: none;
    -webkit-font-smoothing: antialiased;
  }
  .cta-container { 
	  text-align: center; 
	    border: 1px solid #f47a28;
    border-radius: 3px;
    background-color: #f47a28;
    padding: 8px;
    width: 200px;
    margin: 0 auto;
    margin-top:20px !important;
	  
  }
  .message_ { display: flex; align-items: center; }
  .message_ .cta-container { padding: 0 10px 0 0; }
</style>
<!-- END CONFIGURATION -->
<script>
  var mode;

  addElement();
  window.addEventListener("resize", addElement);

  function addElement() {
    if (mode === "desktop" && window.innerWidth > 800) { return; }
    if (mode === "mobile" && window.innerWidth <= 800) { return; }

    mode = window.innerWidth > 800 ? "desktop" : "mobile";

    if (mode === "mobile") { return; }

    var retry = 0;
    var timer = window.setInterval(function() {
      if (retry > 20) { clearInterval(timer); }

      var lbApp = document.getElementById("qa-app-base");
      if (lbApp) {
        var header = document.querySelector(".mainHeader_ .message_");

        if (!header) {
          header = document.querySelector(".headerContainer_ > div");
        }

        if (!header) { return; }

        var container = document.createElement("div");
        container.className = "cta-container";
        var cta = document.createElement("a");
        cta.className = "cta";
        cta.href = linkUrl;
        cta.innerText = linkText;
        cta.target = "_blank";

        container.appendChild(cta);
        header.appendChild(container);

        clearInterval(timer);
      }
      retry++;

    }, 200);
  }
</script>

      <style>
.contentInner_2ikxc{
hyphens: none !important;
word-break: normal !important;
-webkit-hyphens: none !important;
}
</style>
      <!--<script src="https://app.cdn.lookbookhq.com/libraries/threshold-met/threshold-met-post.min.js"></script>
<script>
  //Update to 1928
  ThresholdMet.initialize({
    threshold: "20",
    config: {
      platform: "marketo",
      baseUrl: "app-ab23.marketo.com", // Marketo instance base URL
      munchkinId: "931-AVB-853", // Marketo Munchkin ID
      formId: "1928" // Marketo form ID
    },
    requiredFields: ["Email", "mKTOSFDCCampaignID"], // Required fields in data property for form submit to fire
    data: {
      "Email": "",
      "mKTOSFDCCampaignID": ""
    }
  })
</script>-->
<script src='https://cdnjs.cloudflare.com/ajax/libs/visibility.js/1.2.4/visibility.min.js'></script>
<script src="//info.infoblox.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_1928" style="display:none"></form>
<script>MktoForms2.loadForm("//info.infoblox.com", "240-PTK-751", 1928, function(form) {
    form.onSuccess(function(values, followUpUrl) {
        return false;
    });
    var threshold = "20";
    var mKTOSFDCCampaignID= "";
    //var form = MktoForms2.allForms()[0];
   var timeOnPage = 0;
   var timer = Visibility.every(1000, function () {
     timeOnPage += 1;
     if (timeOnPage >= parseInt(threshold)&&""!="") {

            form.addHiddenFields({
           // These are the values which will be submitted to Marketo
              
      "Email": "",
      "mKTOSFDCCampaignID": mKTOSFDCCampaignID

           });
            form.submit();
           Visibility.stop(timer);          
     }
    });
   
    });
  
</script>
      <script>
    window.addEventListener("message", function(event) {
        if (event.data === "captureModal") {
            console.log(event.data);
            var css = document.createElement("style");
            css.type = "text/css";
            css.innerHTML = "div[class^='modal_'] { padding: 0px !important; }";
            document.body.appendChild(css);
        }
    }, false);
</script>
      <style>
    #sidebarContainer {
        display: none;
    }
    #viewerContainer{
	    left:0px!important;
    }
</style>
      <!-- Google Tag Manager -->

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':

new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],

j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=

'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);

})(window,document,'script','dataLayer','GTM-F7RMF');</script>

<!-- End Google Tag Manager -->
      <script src="https://polyfill.io/v3/polyfill.min.js?version=3.52.1&features=Promise"></script>
<script>
  if (window.Promise) {
    window.pfResolveJukeboxLoaded;
    window.pfOnJukeboxLoad = new Promise(function (resolve) {
      window.pfResolveJukeboxLoaded = resolve;
    });
  }
</script>

      <script
  src="https://code.jquery.com/jquery-3.4.0.min.js"
  integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg="
  crossorigin="anonymous"></script>
<!-- Google Tag Manager -->

<style>
    #cookie_bar{
        z-index:200000!important;

    }
    .white-popup {
    margin-top: 20px !important;
    }
    .mfp-ready{
        z-index: 200001!important;
        overflow:scroll auto!important;
    }
</style>

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':

new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],

j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=

'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);

})(window,document,'script','dataLayer','GTM-F7RMF');

<!-- End Google Tag Manager -->


$(document).ready(function(){
  if (getCookie("marketing_cookie_consent") ||
    getCookie("analytics_cookie_consent") ||
    getCookie("necessary_cookie_consent") ||
    getCookie("preference_cookie_consent")) {
    } else {
        var countryIP = "AR";
      if (countryIP == "AT" || countryIP == "BE" || countryIP == "BG" || 
        countryIP == "HR" || countryIP == "CY" || countryIP == "CZ" || 
        countryIP == "DK" || countryIP == "EE" || countryIP == "FI" || 
        countryIP == "FR" || countryIP == "DE" || countryIP == "GR" || 
        countryIP == "HU" || countryIP == "IE" || countryIP == "IT" || 
        countryIP == "LV" || countryIP == "LT" || countryIP == "LU" || 
        countryIP == "MT" || countryIP == "NL" || countryIP == "PL" || 
        countryIP == "PT" || countryIP == "RO" || countryIP == "SK" || 
        countryIP == "SI" || countryIP == "ES" || countryIP == "SE" || countryIP == "GB" ) {
        dataLayer.push({'event': 'eventTracker', 'eventCat': 'GDPR Cookie', 'eventAct': 'Location', 'eventLbl':countryIP, 'eventVal': 0});
          dataLayer.push ({'event' : 'GDPR_Country_Code', 'countryIP' : "GDPR" });
      } else {
        dataLayer.push({'event': 'eventTracker', 'eventCat': 'GDPR Cookie', 'eventAct': 'Location', 'eventLbl':'Non EU', 'eventVal': 0});
        

        //PPC Confirmation Use Case
        if(window.location.href.indexOf("/ppcconfirmation/") > -1) {
          setCookie("necessary_cookie_consent",true);
              setCookie("analytics_cookie_consent",true);
              setCookie("marketing_cookie_consent",true);
              setCookie("preference_cookie_consent",true);
          dataLayer.push ({'event' : 'Non_GDPR_Forced_Consent', 'NonGDPRForcedConsent' : 'true'});
        } else {
          dataLayer.push ({'event' : 'GDPR_Country_Code', 'countryIP' : "NOGDPR" });
        }

      }
    } 
});





function getCookie(name) {
    var v = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');
    return v ? v[2] : null;
}

  function setCookie(cookieName, cookieValue){
    var expirationTime = 31557600;
    expirationTime = expirationTime * 1000;
    var date = new Date(); 
    var dateTimeNow = date.getTime(); 
    date.setTime(dateTimeNow + expirationTime); 
    var expirationTime = date.toUTCString(); 
    document.cookie = cookieName+"="+cookieValue+"; expires="+expirationTime+"; path=/; domain=.infoblox.com";
  }
</script>

<script>
function setPfConsent(status){
  console.log('update preferences',status);
if(pfConsentStatus()!=true && status==true)
    return pfCookieResponse(true);
if (pfConsentStatus() != false && status!=true)
   pfCookieResponse(false);
}
    pfOnJukeboxLoad.then(function() {
        
        
        
        
    setTimeout(function(){ 
  if(getCookie("marketing_cookie_consent")==""||getCookie("marketing_cookie_consent")==null)
   {
//setPfConsent(true)
   }
  else{
    setPfConsent(getCookie("marketing_cookie_consent")=="true")
  }
}, 500);
});

  var waitForEl = function(selector, callback) {
  if (jQuery(selector).length) {
    callback();
  } else {
    setTimeout(function() {
      waitForEl(selector, callback);
    }, 100);
  }
};
waitForEl('#button_accept', function() {
var accept_button = document.querySelector('#button_accept')  
console.log(accept_button);
accept_button.addEventListener('click',function(){setPfConsent(true)},false);
var popup_button = document.querySelector('#popup-submit')  
console.log(popup_button);
popup_button.addEventListener('click',function(){setPfConsent(getCookie("marketing_cookie_consent")=="true")},false);
});
</script>

    <script>
      window.__PATHFACTORY__ = {
        pageViewData: {"id":19647,"name":"[Reports] Threat Intelligence Reports","uniqueId":"24TSub","externalId":"https://insights.infoblox.com/threat-intelligence-reports","experienceType":"target","bottomBarEnabled":null,"bottomBarConfig":{"backgroundColor":"#7d7d7d","itemColor":"#000308","itemFontFamily":"Helvetica","itemFontSize":"13px","itemFontWeight":"normal","itemLineHeight":"18px","maxItems":3,"showAfter":5,"scrollDistance":100,"targetTitle":"Continue Reading","websiteTitle":"Recommended For You","titleColor":"#FFFFFF","titleFontFamily":"Helvetica","titleFontSize":"13px","titleFontWeight":"bold","titleLineHeight":"18px"},"captureConfig":{"formId":5268,"displayMode":"totalTime","showAfterViews":5,"delay":10,"showAfterTime":10,"isDismissable":true,"enablePromoterNavigation":false,"doNotShow":"known","form":{"id":5268,"organizationId":10336,"name":"Cyber Threat Reports","formType":"custom","formDetails":{"captureFirstName":true,"captureLastName":true,"captureTitle":true,"captureCompany":true,"capturePhone":true,"captureEmail":true,"enableOptIn":true,"optInText":"May we contact you?","privacyLink":"","buttonText":"Submit","cookieConsentText":"By checking this you are accepting to use cookies to personalize content, ads, and analyze our traffic"},"externalUrl":"","customHtml":"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\n\u003chead\u003e\n  \u003cmeta charset=\"utf-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e\n  \u003ctitle\u003eInfoblox Form\u003c/title\u003e\n  \u003cstyle\u003e\n#qa-custom-form{\n\theight: 600px !important;\n}\n#qa-modal{\n    background: #025fb7 !important;\t\t  \n\t  }\n    body {\n      margin: 0;\n      padding: 20px;\n      background-color: #025fb7;\n      font-family: Helvetica, sans-serif;\n      color: #fff;\n      font-size: 14px;\n      width: 90% !important;\n    }\n\n    .formContainer {\n      width: 400px;\n      margin: 0 auto;\n    }\n\n    .formFooter {\n      font-size: 12px;\n    }\n\n    .mktoOffset {\n      width: 0px !important;\n    }\n\n    .padRight1 {\n      padding-top: 5px;\n    }\n\n    .mktoForm .mktoGutter {\n      width: 0px !important;\n    }\n\n \n\n    .mktoForm .mktoRequiredField label.mktoLabel {\n      font-family: \"ProximaNovaRegular\", Arial, Helvetica, sans-serif !important;\n      font-size: 14px !important;\n      line-height: 19px !important;\n      color: #ffffff !important;\n    }\n\n    .mktoForm input[type=text],\n    .mktoForm input[type=url],\n    .mktoForm input[type=email],\n    .mktoForm input[type=tel],\n    .mktoForm input[type=number],\n    .mktoForm input[type=date],\n    .mktoForm textarea.mktoField,\n    .mktoForm select.mktoField {\n      width: 200px !important;\n      height: 32px !important;\n      font-family: \"ProximaNovaRegular\", Arial, Helvetica, sans-serif !important;\n      font-size: 14px !important;\n      line-height: 19px !important;\n      color: #000000 !important;\n      -webkit-appearance: none !important;\n      background-color: #ffffff !important;\n      border-radius: 0px !important;\n      border: 1px solid #ffffff !important;\n    }\n\n    .mktoForm input[type=text]:focus,\n    .mktoForm input[type=url]:focus,\n    .mktoForm input[type=email]:focus,\n    .mktoForm input[type=tel]:focus,\n    .mktoForm input[type=number]:focus,\n    .mktoForm input[type=date]:focus,\n    .mktoForm textarea.mktoField:focus,\n    .mktoForm select.mktoField:focus {\n\n      height: 32px !important;\n      font-family: \"ProximaNovaRegular\", Arial, Helvetica, sans-serif !important;\n      font-size: 14px !important;\n      line-height: 19px !important;\n      color: #000000 !important;\n      -webkit-appearance: none !important;\n      background-color: #ffffff !important;\n      border-radius: 0px !important;\n      border: 1px solid #ffffff !important;\n      outline: none !important;\n    }\n\n    .mktoForm select.mktoField {\n      height: 32px !important;\n      font-family: \"ProximaNovaRegular\", Arial, Helvetica, sans-serif !important;\n      font-size: 14px !important;\n      line-height: 19px !important;\n      color: #000000 !important;\n      -webkit-appearance: none !important;\n      background-color: #ffffff !important;\n      border-radius: 0px !important;\n      border: 1px solid #ffffff !important;\n\n      -moz-appearance: none !important;\n      outline: none !important;\n      background: #ffffff url('https://info.infoblox.com/rs/240-PTK-751/images/Polygon 1.png') no-repeat 97% 43% !important;\n    }\n\n    .mktoButtonRow {\n      margin-top: 6% !important;\n      margin-bottom: 6% !important;\n    }\n\n    .mktoForm .mktoButtonWrap {\n      margin-left: 0px !important;\n    }\n\n    .mktoForm .mktoButton {\n      width: 200px !important;\n      padding-top: 12px !important;\n      padding-bottom: 12px !important;\n      background-image: none !important;\n      background-color: #fcb814 !important;\n      color: #000000 !important;\n      font-size: 18px !important;\n      border: 1px solid #fcb814 !important;\n      border-radius: 5px !important;\n      font-family: \"ProximaNovaSBold\", Arial, Helvetica, sans-serif;\n      line-height: 22px;\n    }\n\n    .mktoForm .mktoButtonRow {\n      width: 90% !important;\n      text-align: center !important;\n    }\n\n    .mktoForm .mktoAsterix {\n      display: none !important;\n    }\n\n    @media (max-width: 480px) {\n      .formContainer {\n        width: auto;\n      }\n      .formFooter {\n        padding-right: 10px;\n      }\n      .mktoForm {\n        padding: 0px !important;\n      }\n      .mktoForm input[type=text],\n      .mktoForm input[type=url],\n      .mktoForm input[type=email],\n      .mktoForm input[type=tel],\n      .mktoForm input[type=number],\n      .mktoForm input[type=date],\n      .mktoForm textarea.mktoField,\n      .mktoForm select.mktoField {\n        width: 87% !important;\n      }\n    }\n@media only screen and (max-width: 480px){\n.mktoForm .mktoCheckboxList {\n    width: 30% !important;\n}\n}\n  \u003c/style\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cscript src=\"https://info.infoblox.com/js/forms2/js/forms2.min.js\"\u003e\u003c/script\u003e\n  \u003cdiv class=\"formContainer\"\u003e\n    \u003cdiv id=\"formHeading\" class=\"formHeading\" style=\"display: block; margin-bottom:20px;\"\u003e\n      \u003ch3\u003eWant to be in the know? Subscribe to Infoblox threat intel reports for regular updates on latest threats.\u003c/h3\u003e\n    \u003c/div\u003e\n    \u003cform id=\"mktoForm_4581\"\u003e\u003c/form\u003e\n     \u003cdiv id=\"formFooter\" class=\"formFooter\" style=\"display: none;\"\u003e\n    \u003c/div\u003e\n   \n  \u003c/div\u003e\n  \u003cscript\u003e\n    MktoForms2.loadForm(\"https://info.infoblox.com\", \"240-PTK-751\", 4581, function(form) {\n      document.getElementById(\"formHeading\").style.display = \"block\";\n      document.getElementById(\"formFooter\").style.display = \"block\";\n      form.vals({\n        \"mKTOUTMSource\": getUrlParameter(\"utm_source\"),\n        \"mKTOUTMMedium\": getUrlParameter(\"utm_medium\")\n      });\n      form.onSuccess(function() {\n        var vals = form.vals();\n        window.parent.postMessage({\n          conversionUrl: document.location.href,\n          referrer: document.referrer,\n          email: vals.Email,\n          lookbookExternalForm: true\n        }, \"*\");\n        return true;\n      });\n\n      function getUrlParameter(name) {\n        name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n        var regex = new RegExp('[\\\\?\u0026]' + name + '=([^\u0026#]*)');\n        var results = regex.exec(location.search);\n        return results === null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n      };\n    });\n  \u003c/script\u003e\n  \u003cscript type=\"text/javascript\"\u003ellfrmid=10235\u003c/script\u003e\n\u003cscript type=\"text/javascript\" src=\"https://tracking.leadlander.com/formalyze_init.js\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\" src=\"https://tracking.leadlander.com/formalyze_call_secure.js\"\u003e\u003c/script\u003e\n\u003cscript\u003ejQuery('.mktoButton').on('click', function(){formalyzer_call_onclick(10235);});\u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n","deleted":false,"createdAt":"2019-10-01T14:46:00.000-04:00","updatedAt":"2020-10-22T11:29:51.000-04:00","formDetailsJson":{"captureFirstName":true,"captureLastName":true,"captureTitle":true,"captureCompany":true,"capturePhone":true,"captureEmail":true,"enableOptIn":true,"optInText":"May we contact you?","privacyLink":"","buttonText":"Submit","cookieConsentText":"By checking this you are accepting to use cookies to personalize content, ads, and analyze our traffic"},"formHeader":{"title":"Fill This Out to Continue","description":"This content will be available after you complete this form.","imageEnabled":false,"headerEnabled":false},"formHeaderJson":{"title":"Fill This Out to Continue","description":"This content will be available after you complete this form.","imageEnabled":false,"headerEnabled":false},"formHeight":650,"formWidth":470,"applyStyling":false,"customBasicStyling":{"primaryColor":"#ffffff","secondaryColor":"#000000","font":"Roboto"},"enableCookieConsentMessage":false},"enabled":true,"formExcluded":false},"cardEnabled":null,"cardConfig":null,"cookieConsentConfig":{"autoApplyCookieConsent":false,"enabled":"custom","enabledStrict":false,"externalCode":"\u003cscript\n  src=\"https://code.jquery.com/jquery-3.4.0.min.js\"\n  integrity=\"sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=\"\n  crossorigin=\"anonymous\"\u003e\u003c/script\u003e\n\u003c!-- Google Tag Manager --\u003e\n\n\u003cstyle\u003e\n    #cookie_bar{\n        z-index:200000!important;\n\n    }\n    .white-popup {\n    margin-top: 20px !important;\n    }\n    .mfp-ready{\n        z-index: 200001!important;\n        overflow:scroll auto!important;\n    }\n\u003c/style\u003e\n\n\u003cscript\u003e(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':\n\nnew Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],\n\nj=d.createElement(s),dl=l!='dataLayer'?'\u0026l='+l:'';j.async=true;j.src=\n\n'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);\n\n})(window,document,'script','dataLayer','GTM-F7RMF');\n\n\u003c!-- End Google Tag Manager --\u003e\n\n\n$(document).ready(function(){\n  if (getCookie(\"marketing_cookie_consent\") ||\n    getCookie(\"analytics_cookie_consent\") ||\n    getCookie(\"necessary_cookie_consent\") ||\n    getCookie(\"preference_cookie_consent\")) {\n    } else {\n        var countryIP = \"AR\";\n      if (countryIP == \"AT\" || countryIP == \"BE\" || countryIP == \"BG\" || \n        countryIP == \"HR\" || countryIP == \"CY\" || countryIP == \"CZ\" || \n        countryIP == \"DK\" || countryIP == \"EE\" || countryIP == \"FI\" || \n        countryIP == \"FR\" || countryIP == \"DE\" || countryIP == \"GR\" || \n        countryIP == \"HU\" || countryIP == \"IE\" || countryIP == \"IT\" || \n        countryIP == \"LV\" || countryIP == \"LT\" || countryIP == \"LU\" || \n        countryIP == \"MT\" || countryIP == \"NL\" || countryIP == \"PL\" || \n        countryIP == \"PT\" || countryIP == \"RO\" || countryIP == \"SK\" || \n        countryIP == \"SI\" || countryIP == \"ES\" || countryIP == \"SE\" || countryIP == \"GB\" ) {\n        dataLayer.push({'event': 'eventTracker', 'eventCat': 'GDPR Cookie', 'eventAct': 'Location', 'eventLbl':countryIP, 'eventVal': 0});\n          dataLayer.push ({'event' : 'GDPR_Country_Code', 'countryIP' : \"GDPR\" });\n      } else {\n        dataLayer.push({'event': 'eventTracker', 'eventCat': 'GDPR Cookie', 'eventAct': 'Location', 'eventLbl':'Non EU', 'eventVal': 0});\n        \n\n        //PPC Confirmation Use Case\n        if(window.location.href.indexOf(\"/ppcconfirmation/\") \u003e -1) {\n          setCookie(\"necessary_cookie_consent\",true);\n              setCookie(\"analytics_cookie_consent\",true);\n              setCookie(\"marketing_cookie_consent\",true);\n              setCookie(\"preference_cookie_consent\",true);\n          dataLayer.push ({'event' : 'Non_GDPR_Forced_Consent', 'NonGDPRForcedConsent' : 'true'});\n        } else {\n          dataLayer.push ({'event' : 'GDPR_Country_Code', 'countryIP' : \"NOGDPR\" });\n        }\n\n      }\n    } \n});\n\n\n\n\n\nfunction getCookie(name) {\n    var v = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');\n    return v ? v[2] : null;\n}\n\n  function setCookie(cookieName, cookieValue){\n    var expirationTime = 31557600;\n    expirationTime = expirationTime * 1000;\n    var date = new Date(); \n    var dateTimeNow = date.getTime(); \n    date.setTime(dateTimeNow + expirationTime); \n    var expirationTime = date.toUTCString(); \n    document.cookie = cookieName+\"=\"+cookieValue+\"; expires=\"+expirationTime+\"; path=/; domain=.infoblox.com\";\n  }\n\u003c/script\u003e\n\n\u003cscript\u003e\nfunction setPfConsent(status){\n  console.log('update preferences',status);\nif(pfConsentStatus()!=true \u0026\u0026 status==true)\n    return pfCookieResponse(true);\nif (pfConsentStatus() != false \u0026\u0026 status!=true)\n   pfCookieResponse(false);\n}\n    pfOnJukeboxLoad.then(function() {\n        \n        \n        \n        \n    setTimeout(function(){ \n  if(getCookie(\"marketing_cookie_consent\")==\"\"||getCookie(\"marketing_cookie_consent\")==null)\n   {\n//setPfConsent(true)\n   }\n  else{\n    setPfConsent(getCookie(\"marketing_cookie_consent\")==\"true\")\n  }\n}, 500);\n});\n\n  var waitForEl = function(selector, callback) {\n  if (jQuery(selector).length) {\n    callback();\n  } else {\n    setTimeout(function() {\n      waitForEl(selector, callback);\n    }, 100);\n  }\n};\nwaitForEl('#button_accept', function() {\nvar accept_button = document.querySelector('#button_accept')  \nconsole.log(accept_button);\naccept_button.addEventListener('click',function(){setPfConsent(true)},false);\nvar popup_button = document.querySelector('#popup-submit')  \nconsole.log(popup_button);\npopup_button.addEventListener('click',function(){setPfConsent(getCookie(\"marketing_cookie_consent\")==\"true\")},false);\n});\n\u003c/script\u003e\n","countries":[],"marketingAutomationPlatform":"marketo","cookieMessage":"This website or its third party tools use cookies, which are necessary to its functioning and required to achieve the purposes illustrated in the privacy policy. If you want to know more or withdraw your consent to all or some of the cookies, please click on Learn More. By continued use of this website you are consenting to our use of cookies.","gdprAccept":"Accept","gdprAcceptButtonBackgroundColor":"#fff","gdprDecline":"Decline","gdprDeclineButtonBackgroundColor":"#fff","gdprButtonColor":"#213542","gdprButtonFontFamily":"Roboto","gdprButtonFontSize":"15px","gdprButtonFontWeight":"normal","gdprButtonLineHeight":"20px","gdprLearnMore":"Learn More","gdprLearnMoreUrl":"https://www.infoblox.com/company/legal/privacy-policy/","gdprLearnMoreColor":"#009bff","gdprLearnMoreFontFamily":"Roboto","gdprLearnMoreFontSize":"15px","gdprLearnMoreFontWeight":"normal","gdprLearnMoreLineHeight":"20px","gdprCookieMessage":"This website or its third party tools use cookies, which are necessary to its functioning and required to achieve the purposes illustrated in the cookie policy. If you want to know more or withdraw your consent to all or some of the cookies, please click on Learn More.","gdprMessageColor":"#213542","gdprMessageFontFamily":"Roboto","gdprMessageFontSize":"15px","gdprMessageFontWeight":"normal","gdprMessageLineHeight":"20px","gdprDialogBackgroundColor":"#ffffff","gdprPreferencesBodyText":"These cookies are necessary for the website to function. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy settings, logging in or filling in forms.","gdprPreferencesBodyTextColor":"#213542","gdprPreferencesBodyTextFontFamily":"Roboto","gdprPreferencesBodyTextFontSize":"15px","gdprPreferencesBodyTextFontWeight":"normal","gdprPreferencesBodyTextLineHeight":"20px","gdprPreferencesHeaderText":"Cookie Preference Center","gdprPreferencesHeaderColor":"#213542","gdprPreferencesHeaderFontFamily":"Roboto","gdprPreferencesHeaderFontSize":"15px","gdprPreferencesHeaderFontWeight":"normal","gdprPreferencesHeaderLineHeight":"20px","gdprPreferencesSubheaderText":"Cookies Used","gdprPreferencesSubheaderColor":"#213542","gdprPreferencesSubheaderFontFamily":"Roboto","gdprPreferencesSubheaderFontSize":"15px","gdprPreferencesSubheaderFontWeight":"normal","gdprPreferencesSubheaderLineHeight":"20px","gdprPreferencesLinkLabel":"Cookie Settings","gdprPreferencesMapDescription":"These cookies are necessary for the website to function. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy settings, logging in or filling in forms.","gdprPreferencesGaDescription":"These cookies are necessary for the website to function. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy settings, logging in or filling in forms.","gdprPreferencesDialogBackgroundColor":"#ffffff","gdprPreferencesDialogOptInColor":"#00a9cb","gdprPreferencesStrictlyNecessarySubheaderText":"Strictly Necessary Cookies","gdprMarketingCookieTypeText":"Marketing","gdprThirdPartyCookieTypeText":"3rd Party","vidSessionCookieDesc":"vid - session cookie used to collect anonymous information for analytics, and provide content and navigation in this content track.","strictModeVidSessionCookieDesc":"vid - this session cookie is required to render content and navigate around this content track.","vidPermanentCookieDesc":"vid - PathFactory permanent cookie used to collect information about both unknown and known web visitors and behaviour habits to make content relevant to your interests.","externalCodesList":[{"id":2784,"code":"\u003c!-- RUN EXTERNAL CODE IN BOTTOM BODY TAG --\u003e\n\u003c!-- START CONFIGURATION --\u003e\n\u003cscript\u003e\n  var linkUrl = \"https://info.infoblox.com/WW-CRQ-FY19-infoblox-cyber-threat-reports.html\"; // CTA link\n  var linkText = \"Stay up to date on the latest Cyber Threats\"; // CTA text\n\u003c/script\u003e\n\u003cstyle\u003e\n  .cta {\n    font-family: inherit;\n    font-size: 14px;\n    color: #ffffff !important;\n    border: 1px solid #f47a28;\n    border-radius: 3px;\n    background-color: #f47a28;\n    text-decoration: none;\n    -webkit-font-smoothing: antialiased;\n  }\n  .cta-container { \n\t  text-align: center; \n\t    border: 1px solid #f47a28;\n    border-radius: 3px;\n    background-color: #f47a28;\n    padding: 8px;\n    width: 200px;\n    margin: 0 auto;\n    margin-top:20px !important;\n\t  \n  }\n  .message_ { display: flex; align-items: center; }\n  .message_ .cta-container { padding: 0 10px 0 0; }\n\u003c/style\u003e\n\u003c!-- END CONFIGURATION --\u003e\n\u003cscript\u003e\n  var mode;\n\n  addElement();\n  window.addEventListener(\"resize\", addElement);\n\n  function addElement() {\n    if (mode === \"desktop\" \u0026\u0026 window.innerWidth \u003e 800) { return; }\n    if (mode === \"mobile\" \u0026\u0026 window.innerWidth \u003c= 800) { return; }\n\n    mode = window.innerWidth \u003e 800 ? \"desktop\" : \"mobile\";\n\n    if (mode === \"mobile\") { return; }\n\n    var retry = 0;\n    var timer = window.setInterval(function() {\n      if (retry \u003e 20) { clearInterval(timer); }\n\n      var lbApp = document.getElementById(\"qa-app-base\");\n      if (lbApp) {\n        var header = document.querySelector(\".mainHeader_ .message_\");\n\n        if (!header) {\n          header = document.querySelector(\".headerContainer_ \u003e div\");\n        }\n\n        if (!header) { return; }\n\n        var container = document.createElement(\"div\");\n        container.className = \"cta-container\";\n        var cta = document.createElement(\"a\");\n        cta.className = \"cta\";\n        cta.href = linkUrl;\n        cta.innerText = linkText;\n        cta.target = \"_blank\";\n\n        container.appendChild(cta);\n        header.appendChild(container);\n\n        clearInterval(timer);\n      }\n      retry++;\n\n    }, 200);\n  }\n\u003c/script\u003e\n","name":"CTA - Reports Subscribe Now","globallyEnabled":false,"location":"head","createdAt":"Jun 21, 2019 18:28:58","updatedAt":"Nov 03, 2019 19:14:24","description":null,"thirdParty":false,"tag":"head","usedIn":[{"name":"[Reports] Threat Intelligence Reports","id":19647,"type":"target"},{"name":"[Event] MPOWER Pre-Show","id":27627,"type":"target"},{"name":"MPower with Form","id":28653,"type":"target"},{"name":"TEST Threat Reports","id":29071,"type":"target"},{"name":"[Email] Security - Follow Up Email","id":30080,"type":"target"},{"name":"[eBook] CSA for Dummies","id":27124,"type":"target"},{"name":"[Event] Microsoft Ignite","id":30240,"type":"recommend"},{"name":"Testing Reports Bundle","id":36487,"type":"target"}]},{"id":189,"code":"\u003cstyle\u003e\n.contentInner_2ikxc{\nhyphens: none !important;\nword-break: normal !important;\n-webkit-hyphens: none !important;\n}\n\u003c/style\u003e","name":"Lookbook bottom bar css fixes","globallyEnabled":true,"location":"head","createdAt":"Oct 25, 2017 17:38:12","updatedAt":"May 28, 2019 17:15:55","description":null,"thirdParty":false,"tag":"head","usedIn":[]},{"id":219,"code":"\u003c!--\u003cscript src=\"https://app.cdn.lookbookhq.com/libraries/threshold-met/threshold-met-post.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\n  //Update to 1928\n  ThresholdMet.initialize({\n    threshold: \"{{content.engagement_threshold}}\",\n    config: {\n      platform: \"marketo\",\n      baseUrl: \"app-ab23.marketo.com\", // Marketo instance base URL\n      munchkinId: \"931-AVB-853\", // Marketo Munchkin ID\n      formId: \"1928\" // Marketo form ID\n    },\n    requiredFields: [\"Email\", \"mKTOSFDCCampaignID\"], // Required fields in data property for form submit to fire\n    data: {\n      \"Email\": \"{{visitor.email}}\",\n      \"mKTOSFDCCampaignID\": \"{{content.external_id}}\"\n    }\n  })\n\u003c/script\u003e--\u003e\n\u003cscript src='https://cdnjs.cloudflare.com/ajax/libs/visibility.js/1.2.4/visibility.min.js'\u003e\u003c/script\u003e\n\u003cscript src=\"//info.infoblox.com/js/forms2/js/forms2.min.js\"\u003e\u003c/script\u003e\n\u003cform id=\"mktoForm_1928\" style=\"display:none\"\u003e\u003c/form\u003e\n\u003cscript\u003eMktoForms2.loadForm(\"//info.infoblox.com\", \"240-PTK-751\", 1928, function(form) {\n    form.onSuccess(function(values, followUpUrl) {\n        return false;\n    });\n    var threshold = \"{{content.engagement_threshold}}\";\n    var mKTOSFDCCampaignID= \"{{content.external_id}}\";\n    //var form = MktoForms2.allForms()[0];\n   var timeOnPage = 0;\n   var timer = Visibility.every(1000, function () {\n     timeOnPage += 1;\n     if (timeOnPage \u003e= parseInt(threshold)\u0026\u0026\"{{visitor.email}}\"!=\"\") {\n\n            form.addHiddenFields({\n           // These are the values which will be submitted to Marketo\n              \n      \"Email\": \"{{visitor.email}}\",\n      \"mKTOSFDCCampaignID\": mKTOSFDCCampaignID\n\n           });\n            form.submit();\n           Visibility.stop(timer);          \n     }\n    });\n   \n    });\n  \n\u003c/script\u003e","name":"Threshold Met","globallyEnabled":true,"location":"head","createdAt":"Nov 07, 2017 22:17:07","updatedAt":"May 07, 2021 15:09:36","description":null,"thirdParty":false,"tag":"head","usedIn":[]},{"id":368,"code":"\u003cscript\u003e\n    window.addEventListener(\"message\", function(event) {\n        if (event.data === \"captureModal\") {\n            console.log(event.data);\n            var css = document.createElement(\"style\");\n            css.type = \"text/css\";\n            css.innerHTML = \"div[class^='modal_'] { padding: 0px !important; }\";\n            document.body.appendChild(css);\n        }\n    }, false);\n\u003c/script\u003e","name":"Modal CSS","globallyEnabled":true,"location":"head","createdAt":"Jan 24, 2018 18:42:29","updatedAt":"May 28, 2019 17:15:52","description":null,"thirdParty":false,"tag":"head","usedIn":[]},{"id":2332,"code":"\u003c!-- Google Tag Manager (noscript) --\u003e\n\n\u003cnoscript\u003e\u003ciframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-F7RMF\"\n\nheight=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"\u003e\u003c/iframe\u003e\u003c/noscript\u003e\n\n\u003c!-- End Google Tag Manager (noscript) --\u003e","name":"GTM Body","globallyEnabled":true,"location":"top_body","createdAt":"Apr 17, 2019 16:23:38","updatedAt":"May 28, 2019 17:16:34","description":null,"thirdParty":false,"tag":"header","usedIn":[{"name":"PF - Cookie Consent Test","id":21932,"type":"target"}]},{"id":2366,"code":"\u003cstyle\u003e\n        .white-popup {\n    margin-top: 20px !important;\n    }\n\u003c/style\u003e","name":"Cookie popup styling","globallyEnabled":true,"location":"body","createdAt":"Apr 23, 2019 13:55:12","updatedAt":"May 28, 2019 17:16:00","description":null,"thirdParty":false,"tag":"footer","usedIn":[{"name":"PF - Cookie Consent Test","id":21932,"type":"target"}]},{"id":2996,"code":"\u003cstyle\u003e\n    #sidebarContainer {\n        display: none;\n    }\n    #viewerContainer{\n\t    left:0px!important;\n    }\n\u003c/style\u003e","name":"DisablePDFSidebar","globallyEnabled":true,"location":"head","createdAt":"Jul 29, 2019 14:55:12","updatedAt":"Jul 30, 2019 12:06:58","description":null,"thirdParty":false,"tag":"head","usedIn":[]},{"id":5053,"code":"\u003c!-- Google Tag Manager --\u003e\n\n\u003cscript\u003e(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':\n\nnew Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],\n\nj=d.createElement(s),dl=l!='dataLayer'?'\u0026l='+l:'';j.async=true;j.src=\n\n'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);\n\n})(window,document,'script','dataLayer','GTM-F7RMF');\u003c/script\u003e\n\n\u003c!-- End Google Tag Manager --\u003e","name":"GTM Head-GA","globallyEnabled":true,"location":"head","createdAt":"May 27, 2020 17:15:20","updatedAt":"May 27, 2020 17:18:04","description":null,"thirdParty":false,"tag":"head","usedIn":[{"name":"EW TEST - GA Event Capture","id":19261,"type":"target"},{"name":"Local JP","id":6059,"type":"explore"},{"name":"Local DE","id":7896,"type":"explore"}]}],"googleAnalyticsEnabled":false},"cookieConsentEnabled":false,"gdprCookieConsentEnabled":true,"endEnabled":null,"endConfig":null,"exitEnabled":null,"exitConfig":{"itemColor":"#000308","itemFontFamily":"Roboto","itemFontSize":"15px","itemFontWeight":"normal","itemLineHeight":"20px","maxItems":1,"message":"We have so much more great content. Why not check this out?","messageColor":"#000308","messageFontFamily":"Roboto","messageFontSize":"15px","messageFontWeight":"normal","messageLineHeight":"20px","title":"Before you go...","titleColor":"#0077ed","titleFontFamily":"Roboto","titleFontSize":"24px","titleFontWeight":"normal","titleLineHeight":"30px","delay":5,"featuredItemId":null},"flowCallToActionConfig":null,"flowConfig":{"sidebarBackgroundColor":"#FFFFFF","sharingIconColor":"#0077ed","itemBackgroundColor":"#FFFFFF","itemColor":"#000308","itemFontFamily":"Roboto","itemFontSize":"15px","itemFontWeight":"normal","itemLineHeight":"20px","activeItemColor":"#0077ed","activeItemFontFamily":"Roboto","activeItemFontSize":"15px","activeItemFontWeight":"bold","activeItemLineHeight":"20px","logo":"https://app.cdn.lookbookhq.com/lbhq-production/10336/thumbnails/original/b0993bdd-e641-4907-a31e-d5cf1bff0886.png","nextPromoterTeaserBackgroundColor":"#0077ed","nextPromoterTeaserColor":"#FFFFFF","nextPromoterTeaserFontFamily":"Roboto","nextPromoterTeaserFontSize":"24px","nextPromoterTeaserFontWeight":"normal","nextPromoterTeaserLineHeight":"30px","nextPromoterBackgroundColor":"#FFFFFF","nextPromoterHeadlineColor":"#0077ed","nextPromoterHeadlineFontFamily":"Roboto","nextPromoterHeadlineFontSize":"24px","nextPromoterHeadlineFontWeight":"normal","nextPromoterHeadlineLineHeight":"30px","nextPromoterTitleColor":"#000308","nextPromoterTitleFontFamily":"Roboto","nextPromoterTitleFontSize":"15px","nextPromoterTitleFontWeight":"bold","nextPromoterTitleLineHeight":"20px","nextPromoterBodyColor":"#000308","nextPromoterBodyFontFamily":"Roboto","nextPromoterBodyFontSize":"15px","nextPromoterBodyFontWeight":"normal","nextPromoterBodyLineHeight":"20px","nextPromoterTitle":"Next","headerTitle":null,"headerDescription":null,"hideNextPromoter":false,"shareOptions":{"twitter":false,"facebook":false,"linkedin":false,"email":false,"like":false,"download":false},"imageAltText":""},"flowEnabled":true,"generalConfig":{"favicon":"https://app.cdn.lookbookhq.com/lbhq-production/10336/thumbnails/original/da1f4bd8-8310-44d4-8718-6ffa9dabbd24.png","clientLogo":"","headerTextFontFamily":"Roboto","headerTextColor":"#212529","headerTextFontWeight":"500","headerTextFontSize":"1.39rem","headerTextLineHeight":"1.2em","bodyTextFontFamily":"Roboto","bodyTextColor":"#212529","bodyTextFontWeight":"normal","bodyTextFontSize":"0.95rem","bodyTextLineHeight":"1.2em"},"headerEnabled":null,"headerConfig":null,"headerCallToActionConfig":null,"inactivityEnabled":null,"inactivityConfig":null,"shareEnabled":null,"shareConfig":{"logoLink":"https://www.infoblox.com/","emailMessage":"A Content Experience For You","twitterHandle":"","socialShareMessage":"A Content Experience For You","linkedinEnabled":true,"twitterEnabled":true,"facebookEnabled":true,"emailEnabled":true,"likeEnabled":false,"downloadEnabled":true},"sidebarEnabled":null,"sidebarCallToActionConfig":null,"sidebarConfig":null,"signpostEnabled":null,"signpostConfig":{"teaserBackgroundColor":"#0077ed","teaserColor":"#FFFFFF","teaserFontFamily":"Roboto","teaserFontSize":"24px","teaserFontWeight":"normal","teaserLineHeight":"30px","backgroundColor":"#FFFFFF","headlineColor":"#0077ed","headlineFontFamily":"Roboto","headlineFontSize":"24px","headlineFontWeight":"normal","headlineLineHeight":"30px","titleColor":"#000308","titleFontFamily":"Roboto","titleFontSize":"15px","titleFontWeight":"bold","titleLineHeight":"20px","bodyColor":"#000308","bodyFontFamily":"Roboto","bodyFontSize":"15px","bodyFontWeight":"normal","bodyLineHeight":"20px","nextTitle":"Next","previousTitle":"Previous","nextSignpostBehavior":"hide"},"topicSidebarEnabled":null,"topicSidebarConfig":null,"topicSidebarCallToActionConfig":null,"filterTopicConfig":{"displayFilterSection":true,"enableFilterByTopic":true}},
        global: {
          currentContent: {"id":83186,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54053/390x292/1024_1562614723-01.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/cfd88ad4-3c12-4c0f-9078-fa101f72d69f/1024_1562614723-01.png","imageId":54053,"slug":"threat-intelligence--22","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54053/390x292/1024_1562614723-01.png","title":"Malicious Activity Report: Elements of Lokibot Infostealer - 20190131","description":"Read more about the Lokibot threat characteristics","seoConfigJson":"","rating":null,"contentUuid":"22347d70-84e1-4aa3-8c34-9a0fb0a6243f","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-elements-of-lokibot-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1324,"url":"/threat-intelligence-reports/threat-intelligence--22","topics":["Cybersecurity","Network Security"],"personas":[],"industries":[],"businessUnits":["Security","Core DDI"],"funnelStages":["Middle of Funnel"],"assetTypes":[],"active":true},
          experienceContent: [{"id":287784,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/287784/thumbnails/400x300/bc423737-64e6-4e50-9fe1-a334732badd4-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/287784/previews/bc423737-64e6-4e50-9fe1-a334732badd4-1.png","imageId":339615,"slug":"threat-intelligence--119","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/287784/thumbnails/400x300/bc423737-64e6-4e50-9fe1-a334732badd4-1.png","title":"Polish Language Malspam Campaign Delivers AveMaria Infostealer - 20210503","description":"Between 25 and 30 April, Infoblox observed a malspam campaign distributing the AveMaria remote access trojan (RAT). Threat actors used email subject lines written in Polish referencing payment confirmations to lure victims into downloading a malicious executable.","seoConfigJson":"","rating":null,"contentUuid":"b0fd9c64-648d-4b92-aa08-13efa0adce61","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-polish-language-malspam-campaign-delivers-avemaria-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":420,"url":"/threat-intelligence-reports/threat-intelligence--119","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":286233,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/286233/thumbnails/400x300/b8be36d1-6beb-44b0-a2df-d138aaa26705-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/286233/previews/b8be36d1-6beb-44b0-a2df-d138aaa26705-1.png","imageId":337755,"slug":"threat-intelligence--118","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/286233/thumbnails/400x300/b8be36d1-6beb-44b0-a2df-d138aaa26705-1.png","title":"Post-Takedown Trickbot Activity - 20210428","description":"On 25 April, Infoblox observed a phishing campaign that used a DocuSign lure and a malicious file attachment to infect victims with the Trickbot banking trojan. Although Microsoft and other organizations disrupted the Trickbot botnet in October 2020,1 multiple sources have seen activity from the botnet since then.","seoConfigJson":"","rating":null,"contentUuid":"2d8c0bfb-8290-4c14-bcb2-92dc78f7596e","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-post-takedown-trickbot-activity.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":201,"url":"/threat-intelligence-reports/threat-intelligence--118","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":281136,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/281136/thumbnails/400x300/7ac2a2cf-cb9a-4908-9893-06a4d24a50c3-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/281136/previews/7ac2a2cf-cb9a-4908-9893-06a4d24a50c3-1.png","imageId":331921,"slug":"threat-intelligence--117","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/281136/thumbnails/400x300/7ac2a2cf-cb9a-4908-9893-06a4d24a50c3-1.png","title":"Spoofed Vehicle Purchase Invoice Malspam Drops Formbook Infostealer - 20210416","description":"On 12 April, Infoblox observed a malicious email campaign distributing Formbook malware via Microsoft Office documents containing malicious macros. ","seoConfigJson":"","rating":null,"contentUuid":"40adc428-6bc9-49e3-b4f1-4928df64707f","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-spoofed-vehicle-purchase-invoice-malspam-drops-formbook-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":361,"url":"/threat-intelligence-reports/threat-intelligence--117","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":281128,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/281128/thumbnails/400x300/d642724e-de33-4f30-ba8f-d925f109a214-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/281128/previews/d642724e-de33-4f30-ba8f-d925f109a214-1.png","imageId":331913,"slug":"threat-intelligence--116","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/281128/thumbnails/400x300/d642724e-de33-4f30-ba8f-d925f109a214-1.png","title":"Agent Tesla Malspam Campaign Spoofs Bank Correspondence - 20210413 ","description":"From 1 to 6 April, we observed a malspam campaign distributing a TAR file containing Agent Tesla, a remote access trojan (RAT) designed to steal information from a victim. ","seoConfigJson":"","rating":null,"contentUuid":"9ddee2bd-559c-4bf9-8087-7e1760a0ca05","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-agent-tesla-malspam-campaign-spoofs-bank-correspondence.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":133,"url":"/threat-intelligence-reports/threat-intelligence--116","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":281127,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/281127/thumbnails/400x300/9bfa4105-7fef-4462-bcec-f2c0c21ba5f1-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/281127/previews/9bfa4105-7fef-4462-bcec-f2c0c21ba5f1-1.png","imageId":331912,"slug":"threat-intelligence--115","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/281127/thumbnails/400x300/9bfa4105-7fef-4462-bcec-f2c0c21ba5f1-1.png","title":"Italian Economic Support-Themed Malspam Delivers Ursnif Banking Trojan - 20210401 ","description":"On 30 March, Infoblox observed a malspam campaign using an economic support-themed message to lure Italian-speaking victims into opening a malicious attachment that delivers Ursnif, a widely distributed banking trojan. ","seoConfigJson":"","rating":null,"contentUuid":"875d3e76-0861-4857-af7e-fc618581b095","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-italian-economic-support-themed-malspam-delivers-ursnif-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":106,"url":"/threat-intelligence-reports/threat-intelligence--115","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":260090,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/260090/thumbnails/400x300/601db081-7c16-464c-afd0-3f2ddbd5dc84-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/260090/previews/601db081-7c16-464c-afd0-3f2ddbd5dc84-1.png","imageId":325150,"slug":"threat-intelligence--114","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/260090/thumbnails/400x300/601db081-7c16-464c-afd0-3f2ddbd5dc84-1.png","title":"Mamba Ransomware Campaign - 20210331 ","description":"On 23 March, the Federal Bureau of Investigation reported on a variant of the disk-encrypting ransomware HDDCryptor, also known as Mamba. Specifically, it weaponizes DiskCryptor, a legitimate and open source full-disk encryption software.","seoConfigJson":"","rating":null,"contentUuid":"627dd85d-2044-41dc-b63c-15f66da7f0ff","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-mamba-ransomware-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":567,"url":"/threat-intelligence-reports/threat-intelligence--114","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":258372,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/258372/thumbnails/400x300/5283e1ce-4717-4d1e-ab06-390476bbdc69-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/258372/previews/5283e1ce-4717-4d1e-ab06-390476bbdc69-1.png","imageId":322820,"slug":"threat-intelligence--113","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/258372/thumbnails/400x300/5283e1ce-4717-4d1e-ab06-390476bbdc69-1.png","title":"Malspam Campaign Delivers Burkina Trojan - 20210326","description":"From 21 to 23 March, we observed a malspam campaign distributing the Burkina trojan. First seen in October 2017, Burkina is a trojan distributed through executable (EXE) files sent via email.","seoConfigJson":"","rating":null,"contentUuid":"c9c7b01e-8533-4cd2-a7fc-b32e545d9d89","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malspam-campaign-delivers-burkina-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":484,"url":"/threat-intelligence-reports/threat-intelligence--113","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":256955,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/256955/thumbnails/400x300/76bbcd8c-bbf8-410a-b3a8-2ccd2af5ffec-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/256955/previews/76bbcd8c-bbf8-410a-b3a8-2ccd2af5ffec-1.png","imageId":321003,"slug":"threat-intelligence--112","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/256955/thumbnails/400x300/76bbcd8c-bbf8-410a-b3a8-2ccd2af5ffec-1.png","title":"Hancitor Downloader Delivers Cobalt Strike and Ficker Stealer - 20210323","description":"On 18 March, security researcher Brad Duncan reported a malspam campaign that used DocuSign-themed lures to entice users to download and open Microsoft Word documents with malicious macros that install embedded copies of the Hancitor trojan downloader.1 These copies of Hancitor delivered additional payloads containing Cobalt Strike and Ficker Stealer.","seoConfigJson":"","rating":null,"contentUuid":"338d9195-184a-430c-9468-db7db8bba1fc","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-hancitor-downloader-delivers-cobalt-strike-ficker-stealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":404,"url":"/threat-intelligence-reports/threat-intelligence--112","topics":["Cybersecurity","Network Security","Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":255930,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/255930/thumbnails/400x300/1bdb2d51-7770-421c-8eb6-4531090cb748-01.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/255930/previews/1bdb2d51-7770-421c-8eb6-4531090cb748-01.png","imageId":319481,"slug":"threat-intelligence--111","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/255930/thumbnails/400x300/1bdb2d51-7770-421c-8eb6-4531090cb748-01.png","title":"Malicious Activity Report: Trickbot Loader - 20210319","description":"Recent activity from a Trickbot campaign targeting the insurance and legal sector1 shows that the botnet is still a threat, despite U.S. Cyber Command’s attempt to disrupt it in October 2020. Given the potential impact of this threat, we are releasing this detailed report on Trickbot’s functionality to provide our customers and security researchers with the knowledge to prepare for and defend from potential Trickbot-related threats.","seoConfigJson":"","rating":null,"contentUuid":"22a05a4d-dd18-4a27-a8ca-b714060b0020","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malicious-activity-report-trickbot-loader.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":516,"url":"/threat-intelligence-reports/threat-intelligence--111","topics":["Cybersecurity","Network Security","Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":253182,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/253182/thumbnails/400x300/ea2ccc3c-86c5-4a49-9fac-b4d598a982ef-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/253182/previews/ea2ccc3c-86c5-4a49-9fac-b4d598a982ef-1.png","imageId":315942,"slug":"threat-intelligence--110","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/253182/thumbnails/400x300/ea2ccc3c-86c5-4a49-9fac-b4d598a982ef-1.png","title":"Malspam Campaign Spoofing Shipping Company Quote Drops Dridex Banking Trojan - 20210315","description":"On 12 March, Infoblox observed a malspam email campaign distributing the Dridex banking trojan via emails spoofing updated/adjusted invoice notifications from the shipping company Freight Quote.","seoConfigJson":"","rating":null,"contentUuid":"dcfa9ae2-4900-4d6e-ae48-36b1c9b35935","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malspam-campaign-spoofing-shipping-company-quote-drops-dridex-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":450,"url":"/threat-intelligence-reports/threat-intelligence--110","topics":["Cybersecurity","Threat intelligence","Cyber Intelligence Unit"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":250217,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/250217/thumbnails/400x300/f529147c-1b26-4013-abc3-a1489b1ab8c6-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/250217/previews/f529147c-1b26-4013-abc3-a1489b1ab8c6-1.png","imageId":312131,"slug":"threat-intelligence--109","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/250217/thumbnails/400x300/f529147c-1b26-4013-abc3-a1489b1ab8c6-1.png","title":"Warezov Worm Malspam Campaign - 20210308","description":"From March 1 to 3, we observed a malspam campaign distributing the Warezov worm. Also known as Stration, Warezov is an email worm that was first seen in 2006 and is spread through EXE files sent via email.","seoConfigJson":"","rating":null,"contentUuid":"b810f548-5bf4-4934-801d-847163c58f80","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-warezov-worm-malspam-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":397,"url":"/threat-intelligence-reports/threat-intelligence--109","topics":["Cybersecurity","Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":249442,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/249442/thumbnails/400x300/f4e6917d-d5bb-438b-91af-08ad040ca6a3-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/249442/previews/f4e6917d-d5bb-438b-91af-08ad040ca6a3-1.png","imageId":310870,"slug":"threat-intelligence--108","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/249442/thumbnails/400x300/f4e6917d-d5bb-438b-91af-08ad040ca6a3-1.png","title":"Bazarstrike Malspam Campaign Spoofs Complaint Notifications - 20210303","description":"During the week of February 22, security researchers discovered email campaigns distributing a malware loader for Cobalt Strike,1,2,3 a legitimate penetration testing tool abused by threat actors for its post-exploitation capabilities. These campaigns, which some researchers have nicknamed “BazarStrike,” deliver the loaders using similar tactics, techniques, and procedures (TTPs) to that of BazarLoader campaigns.","seoConfigJson":"","rating":null,"contentUuid":"410f6aa2-3d5b-4a77-a1b6-12e219f95c39","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-bazarstrike-malspam-campaign-spoofs-complaint-notifications.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":323,"url":"/threat-intelligence-reports/threat-intelligence--108","topics":["Cybersecurity","Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":246246,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/246246/thumbnails/400x300/b2d402f6-7aaa-4cea-98c5-59ed4dfd4602-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/246246/previews/b2d402f6-7aaa-4cea-98c5-59ed4dfd4602-1.png","imageId":304976,"slug":"threat-intelligence--107","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/246246/thumbnails/400x300/b2d402f6-7aaa-4cea-98c5-59ed4dfd4602-1.png","title":"Malspam Campaign With Fake Invoice Drops RuRAT - 20210219","description":"On February 15, Infoblox observed a malicious email campaign distributing a remote access trojan (RAT) known as RuRAT, via an encrypted Microsoft Excel spreadsheet (XLS) with malicious macros. In this campaign, threat actor(s) used an email subject referencing a fraudulent card invoice to lure users into opening the malicious attachment for details.","seoConfigJson":"","rating":null,"contentUuid":"182975dc-86f3-43e8-926b-9783780b35da","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malspam-campaign-with-fake-invoice-drops-rurat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":547,"url":"/threat-intelligence-reports/threat-intelligence--107","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":244735,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/244735/thumbnails/400x300/4b9522c0-e150-4d12-829f-dfc2f2221361-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/244735/previews/4b9522c0-e150-4d12-829f-dfc2f2221361-1.png","imageId":302326,"slug":"threat-intelligence--106","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/244735/thumbnails/400x300/4b9522c0-e150-4d12-829f-dfc2f2221361-1.png","title":"Buer Loader Campaign Spoofs Identity Services Company - 20210217","description":"From February 2 to 10, Infoblox observed an ongoing malspam campaign delivering trojan malware known as Buer Loader. This campaign used invoice-themed lures to entice users to download and open Microsoft Excel (XLS) documents that contain malicious macros and spoof GlobalSign, a legitimate identity services company.","seoConfigJson":"","rating":null,"contentUuid":"efd8eb2a-0299-48bb-b8b1-2f16bdededf7","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-buer-loader-campaign-spoofs-identity-services-company.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":435,"url":"/threat-intelligence-reports/threat-intelligence--106","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":240672,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/240672/thumbnails/400x300/068da483-a936-478c-9b07-3db1b71f875d-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/240672/previews/068da483-a936-478c-9b07-3db1b71f875d-1.png","imageId":295327,"slug":"threat-intelligence--105","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/240672/thumbnails/400x300/068da483-a936-478c-9b07-3db1b71f875d-1.png","title":"Tax-Themed Phishing Campaign - 20210209","description":"On 1 February, we observed a malspam campaign distributing a Hypertext Markup Language (HTML) file designed to steal email credentials from the recipient. The campaign’s email subject references tax documents. In the United States, it is not unusual to see campaigns using tax-related lures at this time of the year.","seoConfigJson":"","rating":null,"contentUuid":"443b66cf-dcd0-492f-9a73-d2c78046c3c5","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-tax-themed-phishing-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":716,"url":"/threat-intelligence-reports/threat-intelligence--105","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":240669,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/240669/thumbnails/400x300/27ece022-38c0-46fa-a48a-8234d6d75219-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/240669/previews/27ece022-38c0-46fa-a48a-8234d6d75219-1.png","imageId":295324,"slug":"threat-intelligence--104","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/240669/thumbnails/400x300/27ece022-38c0-46fa-a48a-8234d6d75219-1.png","title":"GhostDNS Exploit Kit - 20210126","description":"On January 26, Team Cymru posted an update to their analysis of the GhostDNS exploit kit.1,2 Their report detailed an ongoing GhostDNS campaign that targets unsuspecting users by compromising and changing the DNS of their router to deliver phishing websites. NetLab has also reported on this campaign.","seoConfigJson":"","rating":null,"contentUuid":"2e375063-bba5-446d-a450-091078138e64","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-ghostdns-exploit-kit.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":407,"url":"/threat-intelligence-reports/threat-intelligence--104","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":238141,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/238141/thumbnails/400x300/4f842e6a-0da1-40eb-a786-331b2b73c8c9-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/238141/previews/4f842e6a-0da1-40eb-a786-331b2b73c8c9-1.png","imageId":291140,"slug":"threat-intelligence--103","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/238141/thumbnails/400x300/4f842e6a-0da1-40eb-a786-331b2b73c8c9-1.png","title":"Italian Emotet Campaign - 20210126","description":"On January 22, Infoblox observed a large malspam campaign targeting Italian speakers and delivering Emotet malware. This campaign delivered emails containing malicious, passwordprotected ZIP archives with a Microsoft Word document that infects victims when opened.","seoConfigJson":"","rating":null,"contentUuid":"5fb35560-5b18-4e35-a22b-9c52c855c50a","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-Italian-emotet-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":578,"url":"/threat-intelligence-reports/threat-intelligence--103","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":235763,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/235763/thumbnails/400x300/a84072ea-d94f-4bc6-bc91-69936eee108a-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/235763/previews/a84072ea-d94f-4bc6-bc91-69936eee108a-1.png","imageId":287122,"slug":"threat-intelligence--102","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/235763/thumbnails/400x300/a84072ea-d94f-4bc6-bc91-69936eee108a-1.png","title":"Snake Keylogger Slithers Through Malspam - 20210119","description":"During the week of January 14, we observed a malspam campaign distributing the Snake Keylogger. The emails in the campaign contain a malicious 7-ZIP archive that opens an SCR file and downloads the malware to the victim host.1,2","seoConfigJson":"","rating":null,"contentUuid":"2978c33c-afef-4d13-86fb-9b40e8e0a10c","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-snake-keylogger-slithers-through-malspam.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":628,"url":"/threat-intelligence-reports/threat-intelligence--102","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":234126,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/234126/thumbnails/400x300/469d95f6-25f3-4339-bd48-97b1fd92a31e-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/234126/previews/469d95f6-25f3-4339-bd48-97b1fd92a31e-1.png","imageId":284263,"slug":"threat-intelligence--101","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/234126/thumbnails/400x300/469d95f6-25f3-4339-bd48-97b1fd92a31e-1.png","title":"Valyria Trojan Drops Emotet - 20210112","description":"During the week of January 4, we observed a malspam campaign distributing the Valyria trojan. The emails in this campaign contain malicious Microsoft Office Word documents (DOCs) that display an error message when opened and execute a PowerShell script via Windows Management Instrumentation (WMI","seoConfigJson":"","rating":null,"contentUuid":"d2520449-d70c-4ab9-9d46-791749715495","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/infoblox-whitepaper-valyria-trojan-drops-emotet.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":428,"url":"/threat-intelligence-reports/threat-intelligence--101","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":228544,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/228544/thumbnails/400x300/e957c453-c357-4752-b747-b9ab86ba49a7-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/228544/previews/e957c453-c357-4752-b747-b9ab86ba49a7-1.png","imageId":273698,"slug":"threat-intelligence--100","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/228544/thumbnails/400x300/e957c453-c357-4752-b747-b9ab86ba49a7-1.png","title":"Malspam Sender Spoofing Indian Companies Drops Agent Tesla Keylogger - 20201222","description":"Between December 13 and 14, Infoblox observed a malicious spam (malspam) email campaign distributing Agent Tesla keylogger1  via a Microsoft Excel spreadsheet (XLS) with malicious macros. In this campaign, threat actor(s) sent emails spoofing communication from Gopaldas \u0026 Sons (also Gopal Das \u0026 Sons, both of which represent several large companies in India).","seoConfigJson":"","rating":null,"contentUuid":"82c39f07-41f4-498a-bfdb-f7d209d57382","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/malspam-sender-spoofing-indian-companies-drops-agent-tesla-keylogger.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":773,"url":"/threat-intelligence-reports/threat-intelligence--100","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":228427,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/228427/thumbnails/400x300/ece41de6-c333-48ed-b6fd-948c6c96142c-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/228427/previews/ece41de6-c333-48ed-b6fd-948c6c96142c-1.png","imageId":273513,"slug":"threat-intelligence--99","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/228427/thumbnails/400x300/ece41de6-c333-48ed-b6fd-948c6c96142c-1.png","title":"Encrypted Excel Files Drop Abracadabra Trojan - 20201221","description":"From December 13 to 14, Infoblox observed a spam email campaign distributing a trojan known as Abracadabra1  via an encrypted Microsoft Excel spreadsheet (XLS) with malicious macros. In this campaign, threat actor(s) used an email subject referencing an overdue invoice to lure users into opening the malicious attachment.","seoConfigJson":"","rating":null,"contentUuid":"2ff4c565-1e64-4307-a513-3ff7ca7db790","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-encrypted-excel-files-drop-abracadabra-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":288,"url":"/threat-intelligence-reports/threat-intelligence--99","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":228428,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/228428/thumbnails/400x300/44a415ac-7386-4c18-a77e-8f30b8e6ba3a-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/228428/previews/44a415ac-7386-4c18-a77e-8f30b8e6ba3a-1.png","imageId":273514,"slug":"threat-intelligence--98","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/228428/thumbnails/400x300/44a415ac-7386-4c18-a77e-8f30b8e6ba3a-1.png","title":"LokiBot Campaign Uses Microsoft Office Exploit - 20201216","description":"On December 9, Infoblox observed a malicious email campaign exploiting CVE 2017-118821  to distribute LokiBot malware. This campaign used purchase order-themed lures to entice victims into downloading malicious Microsoft Excel (XLS) files","seoConfigJson":"","rating":null,"contentUuid":"001767c4-8d09-4652-86c5-d97f31fddca2","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-lokibot-campaign-uses-microsoft-office-exploit.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":293,"url":"/threat-intelligence-reports/threat-intelligence--98","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":228426,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/228426/thumbnails/400x300/9b25d373-c90d-4c69-b5d6-5bc070cdd287-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/228426/previews/9b25d373-c90d-4c69-b5d6-5bc070cdd287-1.png","imageId":273510,"slug":"threat-intelligence--97","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/228426/thumbnails/400x300/9b25d373-c90d-4c69-b5d6-5bc070cdd287-1.png","title":"AveMaria RAT Malspam Campaign - 20201215","description":"Between December 2 and 7, Infoblox observed a malicious email campaign distributing the AveMaria remote access trojan (RAT). In this campaign, threat actor(s) used subjects referencing text message logs to lure users into opening a malicious Rich Text Format (RTF) file attachment that was disguised as a Microsoft Word document (DOC). ","seoConfigJson":"","rating":null,"contentUuid":"ec3ea02e-0b52-4b3e-9ee0-6609b9d29277","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-avemaria-rat-malspam-campagin.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":266,"url":"/threat-intelligence-reports/threat-intelligence--97","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":226370,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/226370/thumbnails/400x300/b58179a4-757b-44d6-a299-bb37402b13c9-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/226370/previews/b58179a4-757b-44d6-a299-bb37402b13c9-1.png","imageId":269545,"slug":"threat-intelligence--96","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/226370/thumbnails/400x300/b58179a4-757b-44d6-a299-bb37402b13c9-1.png","title":"Hancitor Downloader and Follow-On Malware - 20201210","description":"Between 23 November and 8 December, Infoblox observed multiple malicious spam (malspam) campaigns that all used DocuSign-themed lures to entice users to download and open Microsoft Word documents with malicious macros that install embedded copies of the Hancitor trojan downloader.","seoConfigJson":"","rating":null,"contentUuid":"94fe9a5c-07d4-4964-a689-15099fa397b8","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-hancitor-downloader.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":655,"url":"/threat-intelligence-reports/threat-intelligence--96","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":221256,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/221256/thumbnails/400x300/d6d0aae8-7701-4c00-b85d-ee8e6bb70e54-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/221256/previews/d6d0aae8-7701-4c00-b85d-ee8e6bb70e54-1.png","imageId":259809,"slug":"threat-intelligence--95","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/221256/thumbnails/400x300/d6d0aae8-7701-4c00-b85d-ee8e6bb70e54-1.png","title":"Shathak Pushes IcedID in Japanese Malspam - 20201125","description":"On 20 November, security researcher Brad Duncan reported on a malicious spam campaign from the threat actor known as Shathak (a.k.a. TA551) to distribute the IcedID banking trojan via emails written in Japanese.","seoConfigJson":"","rating":null,"contentUuid":"1d2d1a86-d8dc-43a2-ab2a-a490e372613f","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-shathak-pushes-icedid-in-japanese-malspam.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":552,"url":"/threat-intelligence-reports/threat-intelligence--95","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":218970,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/218970/thumbnails/400x300/20274f84-b0b5-4d26-b994-1cbedc972984-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/218970/previews/20274f84-b0b5-4d26-b994-1cbedc972984-1.png","imageId":253940,"slug":"threat-intelligence--94","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/218970/thumbnails/400x300/20274f84-b0b5-4d26-b994-1cbedc972984-1.png","title":"Remcos RAT Malspam Campaign - 20201118","description":"During the week of 9 November, we discovered a malspam campaign distributing the Remcos remote access trojan (RAT). The emails in this campaign carried malicious Microsoft Office documents that required the user to enable macros to execute the Remcos payload.","seoConfigJson":"","rating":null,"contentUuid":"9202ed69-19a6-4063-bb59-9a917d1074a5","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-remcos-rat-malspam-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":628,"url":"/threat-intelligence-reports/threat-intelligence--94","topics":["Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":218967,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/218967/thumbnails/400x300/b557e438-d5bc-498d-b306-32accfc29422-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/218967/previews/b557e438-d5bc-498d-b306-32accfc29422-1.png","imageId":253935,"slug":"threat-intelligence--93","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/218967/thumbnails/400x300/b557e438-d5bc-498d-b306-32accfc29422-1.png","title":"Automotive-Themed Malspam Delivers Adwind RAT - 20201118","description":"From 12 to 13 November, Infoblox observed a malicious email campaign distributing the Adwind remote access trojan1  (RAT) via a spoofed O’Meara Auto Group invoice using Microsoft Excel spreadsheets (XLS) with malicious macros. ","seoConfigJson":"","rating":null,"contentUuid":"853bd453-2c10-4a4e-ab98-eafa5672b5df","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-automotive-themed-malspam-delivers-adwind-rat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":327,"url":"/threat-intelligence-reports/threat-intelligence--93","topics":["Cybersecurity","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":217421,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/217421/thumbnails/400x300/f53e428c-a25c-41ea-b04c-28e7319d98a5-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/217421/previews/f53e428c-a25c-41ea-b04c-28e7319d98a5-1.png","imageId":250561,"slug":"threat-intelligence--92","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/217421/thumbnails/400x300/f53e428c-a25c-41ea-b04c-28e7319d98a5-1.png","title":"AZORult Infostealer - 20201111","description":"From 3 to 4 November, Infoblox observed fashion and beautythemed malicious spam (malspam) campaigns that delivered AZORult information stealer (infostealer) via Microsoft Excel spreadsheets (XLS) with malicious macros. These spreadsheets used living off the land (LotL) techniques that abused preexisting software on the victim’s machine in order to perform malicious tasks.","seoConfigJson":"","rating":null,"contentUuid":"54e314a0-3ad4-41cd-aaba-2757e25f77a3","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-azorult-infostealer-nov-12.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":643,"url":"/threat-intelligence-reports/threat-intelligence--92","topics":["Cybersecurity","Threat intelligence","Cyber Intelligence Unit"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":214659,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/214659/thumbnails/400x300/a6341211-a937-44bc-ad86-0c9df45b605a-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/214659/previews/a6341211-a937-44bc-ad86-0c9df45b605a-1.png","imageId":244163,"slug":"threat-intelligence--91","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/214659/thumbnails/400x300/a6341211-a937-44bc-ad86-0c9df45b605a-1.png","title":"Formbook Infostealer Campaigns Continue - 20201105","description":"On October 30, Infoblox observed a malicious email campaign distributing Formbook malware via Roshal Archive (RAR) attachments that contained a malicious binary executable file. Emails in this campaign leveraged a SWIFT invoice lure to persuade victims to open and run the attached files.","seoConfigJson":"","rating":null,"contentUuid":"1804650c-6e4b-4e43-b2e4-f7bfe6c453ea","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-formbook-infostealer-campaigns-continue-nov-5.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":564,"url":"/threat-intelligence-reports/threat-intelligence--91","topics":["Threat intelligence","Cyber Intelligence Unit"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":213157,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/213157/thumbnails/400x300/729c5da8-a9f9-4e00-9f40-a3492f0d6a61-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/213157/previews/729c5da8-a9f9-4e00-9f40-a3492f0d6a61-1.png","imageId":241327,"slug":"threat-intelligence--90","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/213157/thumbnails/400x300/729c5da8-a9f9-4e00-9f40-a3492f0d6a61-1.png","title":"Emotet Gets Political - 20201028","description":"From October 16 to 19, we observed a malspam campaign that referenced political themes in the subject lines of the emails and in the attached file name. The campaign distributed the Emotet banking trojan. The threat actors spreading Emotet have previously used popular topics such as COVID-19 as lures.1","seoConfigJson":"","rating":null,"contentUuid":"d041e6c0-d8c0-4c8d-a2c8-25fa3f87ac0a","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-emotet-gets-political.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":577,"url":"/threat-intelligence-reports/threat-intelligence--90","topics":["Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":210221,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/210221/thumbnails/400x300/6f0afb84-6f53-4215-8085-5101c9a60695-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/210221/previews/6f0afb84-6f53-4215-8085-5101c9a60695-1.png","imageId":236563,"slug":"threat-intelligence--89","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/210221/thumbnails/400x300/6f0afb84-6f53-4215-8085-5101c9a60695-1.png","title":"404 Keylogger Campaigns - 20201020","description":"On October 11 and 15, Infoblox observed two related malicious spam (malspam) campaigns that used 7-Zip archive files to deliver the 404 Keylogger malware.","seoConfigJson":"","rating":null,"contentUuid":"c966a3f4-e297-4270-90d8-75efa2a2c8f3","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-404-keylogger-campaigns.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":827,"url":"/threat-intelligence-reports/threat-intelligence--89","topics":["Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":207010,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/207010/thumbnails/400x300/2266a9ff-3936-4dd8-b3a3-5476bcf03782-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/207010/previews/2266a9ff-3936-4dd8-b3a3-5476bcf03782-1.png","imageId":230642,"slug":"threat-intelligence--88","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/207010/thumbnails/400x300/2266a9ff-3936-4dd8-b3a3-5476bcf03782-1.png","title":"Realistic Delivery Notices Drop Dridex Banking Trojan - 20201007 ","description":"On 24 September, Infoblox observed a malicious spam (malspam) email campaign distributing the Dridex banking trojan via emails spoofing FedEx package delivery notifications","seoConfigJson":"","rating":null,"contentUuid":"79f2cbe4-41ab-4a30-a5e6-d6629ee02a73","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-realistic-delivery-notices-drop-dridex-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":756,"url":"/threat-intelligence-reports/threat-intelligence--88","topics":["Cybersecurity","Threat intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":205422,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/205422/thumbnails/400x300/58c374da-1105-4148-981f-d03bd9152445-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/205422/previews/58c374da-1105-4148-981f-d03bd9152445-1.png","imageId":227756,"slug":"threat-intelligence--87","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/205422/thumbnails/400x300/58c374da-1105-4148-981f-d03bd9152445-1.png","title":"Glupteba Backdoor Trojan - 20200930","description":"From 20 to 26 September, Infoblox detected communications between malicious Glupteba bots and command and control (C2) servers in customer DNS traffic. This activity was identified by our Threat Insight1  (TI) security solution, which employs machine learning models to detect and block certain types of malicious behavior, in this case data exfiltration.","seoConfigJson":"","rating":null,"contentUuid":"42375a6f-da22-4ba4-9470-7d536b6b522a","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-glupteba-backdoor-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":672,"url":"/threat-intelligence-reports/threat-intelligence--87","topics":["Cybersecurity","Threat intelligence","Cyber Intelligence Unit"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":204455,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/204455/thumbnails/400x300/316a993a-50fe-4988-b104-d83e314547d1-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/204455/previews/316a993a-50fe-4988-b104-d83e314547d1-1.png","imageId":225780,"slug":"threat-intelligence--86","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/204455/thumbnails/400x300/316a993a-50fe-4988-b104-d83e314547d1-1.png","title":"Malicious Spam Campaign Delivers Static Phishing Page - 20200923","description":"On 20 September, Infoblox observed a malicious spam (malspam) campaign delivering a malicious HTML file capable of phishing for credentials. While threat actor(s) used generic lures in their emails, the HTML file specifically targeted WeTransfer, a file-sharing service.","seoConfigJson":"","rating":null,"contentUuid":"6e7d4f27-345c-4b3e-a948-f1bf720167ba","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malicious-spam-campaign-delivers-static-phishing-page.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":614,"url":"/threat-intelligence-reports/threat-intelligence--86","topics":["Cybersecurity","Threat intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":203019,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/203019/thumbnails/400x300/0e0c4f74-4c0e-471d-a68b-21a766a2aca8-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/203019/previews/0e0c4f74-4c0e-471d-a68b-21a766a2aca8-1.png","imageId":223090,"slug":"threat-intelligence--85","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/203019/thumbnails/400x300/0e0c4f74-4c0e-471d-a68b-21a766a2aca8-1.png","title":"Raccoon InfoStealer Malspam Campaign - 20200916","description":"On 1 September, we observed a malicious spam (malspam) email campaign distributing Raccoon malware. Raccoon, also known as Racealer, is an information stealer (infostealer) that was first observed in April 2019.1","seoConfigJson":"","rating":null,"contentUuid":"15f7c025-82a6-4862-9cce-7d2a73784788","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-raccoon-infostealer-malspam.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":661,"url":"/threat-intelligence-reports/threat-intelligence--85","topics":["Cybersecurity","Threat intelligence","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":200780,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/200780/thumbnails/400x300/53006092-e164-4aac-8b86-fb0a8b996f3b-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/200780/previews/53006092-e164-4aac-8b86-fb0a8b996f3b-1.png","imageId":218778,"slug":"threat-intelligence--84","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/200780/thumbnails/400x300/53006092-e164-4aac-8b86-fb0a8b996f3b-1.png","title":"Metamorfo Banking Trojan - 20200911","description":"On 18 August, cybersecurity researchers at Menlo Security reported an ongoing malware campaign that used HTML smuggling techniques to deliver the Metamorfo banking trojan.","seoConfigJson":"","rating":null,"contentUuid":"6a00a07e-34dc-4426-bd74-1eac7cb25036","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-metamorfo-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":707,"url":"/threat-intelligence-reports/threat-intelligence--84","topics":["Cybersecurity","Threat intelligence","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":188122,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/188122/thumbnails/400x300/93702ae2-ab75-40bc-8243-4c3702f33d0e-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/188122/previews/93702ae2-ab75-40bc-8243-4c3702f33d0e-1.png","imageId":199464,"slug":"threat-intelligence--83","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/188122/thumbnails/400x300/93702ae2-ab75-40bc-8243-4c3702f33d0e-1.png","title":"njRAT Malspam Campaign - 20200825","description":"On 24 August, a malicious spam (malspam) email campaign distributed the njRAT malware, also known as Bladabindi and Njw0rm. njRAT is a remote access trojan (RAT) and information stealer (infostealer) that was first observed in January 2013.","seoConfigJson":"","rating":null,"contentUuid":"ef3ae704-32bf-4a0e-85fa-b3434d5bf34d","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-njrat-malspam-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1212,"url":"/threat-intelligence-reports/threat-intelligence--83","topics":["Cybersecurity"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":186472,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/186472/thumbnails/400x300/d1df3f9b-f3e4-4d0a-97da-5c29b751b2b0-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/186472/previews/d1df3f9b-f3e4-4d0a-97da-5c29b751b2b0-1.png","imageId":196318,"slug":"threat-intelligence--82","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/186472/thumbnails/400x300/d1df3f9b-f3e4-4d0a-97da-5c29b751b2b0-1.png","title":"MassLogger InfoStealer Malspam Campaign - 20200819","description":"On 11 August, we observed a malicious spam (malspam) email campaign distributing MassLogger malware. MassLogger is a relatively new information stealer (infostealer) that was reportedly first observed in April 2020.","seoConfigJson":"","rating":null,"contentUuid":"d71a0b3a-c73b-4cb5-86c7-dd621cb0cb81","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-masslogger-infostealer-malspam-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":527,"url":"/threat-intelligence-reports/threat-intelligence--82","topics":["Cybersecurity","DNS Security"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":182419,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/thumbnails/189436/thumbnails/400x300/5416c3d0-c1ab-443f-ad16-5dc658cf7d6d.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/thumbnails/189436/5416c3d0-c1ab-443f-ad16-5dc658cf7d6d.png","imageId":189436,"slug":"threat-intelligence--81","thumbnail":"https://cdn.pathfactory.com/assets/10336/thumbnails/189436/thumbnails/400x300/5416c3d0-c1ab-443f-ad16-5dc658cf7d6d.png","title":"Qakbot InfoStealer - 20200812","description":"On 3 August, security researcher Brad Duncan reported a malicious spam (malspam) campaign1  that used compressed Visual Basic Script (VBScript) files to deliver Qakbot malware","seoConfigJson":"","rating":null,"contentUuid":"7b915353-90a8-479a-af06-d64d0ddd8241","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-qakbot-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":657,"url":"/threat-intelligence-reports/threat-intelligence--81","topics":["Cybersecurity","Threat intelligence","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":[],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":181067,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/181067/thumbnails/400x300/9a7eeee3-e49f-4724-8163-a47748e012c4-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/181067/previews/9a7eeee3-e49f-4724-8163-a47748e012c4-1.png","imageId":186057,"slug":"threat-intelligence--80","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/181067/thumbnails/400x300/9a7eeee3-e49f-4724-8163-a47748e012c4-1.png","title":"Return Of Emotet - 20200805","description":"On 17 July, Proofpoint’s threat research team observed a malicious spam (malspam) campaign featuring the return of the Emotet malware after a five-month hiatus.","seoConfigJson":"","rating":null,"contentUuid":"d321b30b-faee-43ab-9247-e4fdfb7bc909","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-return-of-emotet.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":504,"url":"/threat-intelligence-reports/threat-intelligence--80","topics":["Threat intelligence","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":[],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":176834,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/176834/thumbnails/400x300/8c2e39fc-6abc-45b4-bb70-b2e1f56410b5-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/176834/previews/8c2e39fc-6abc-45b4-bb70-b2e1f56410b5-1.png","imageId":176322,"slug":"threat-intelligence--79","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/176834/thumbnails/400x300/8c2e39fc-6abc-45b4-bb70-b2e1f56410b5-1.png","title":"Vidar InfoStealer - 20200721","description":"From 25 to 30 June, we observed a malicious spam (malspam) email campaign distributing Vidar malware. Vidar is a trojan and information stealer (infostealer) that was first observed in December 2018.1  It is a variant of the Arkei infostealer.","seoConfigJson":"","rating":null,"contentUuid":"1812213f-206f-44ee-ada6-004b98731a08","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-vidar-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":545,"url":"/threat-intelligence-reports/threat-intelligence--79","topics":["Cybersecurity","Cyber Intelligence Unit"],"personas":[],"industries":[],"businessUnits":[],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":174013,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/174013/thumbnails/400x300/2b883f62-aacf-4ab0-91cb-86c125976435-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/174013/previews/2b883f62-aacf-4ab0-91cb-86c125976435-1.png","imageId":170201,"slug":"threat-intelligence--78","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/174013/thumbnails/400x300/2b883f62-aacf-4ab0-91cb-86c125976435-1.png","title":"Valak Downloader/InfoStealer Delivers IcedID Banking Trojan - 20200715","description":"Between 24 June and 1 July, security researcher Brad Duncan reported four malware campaigns that used the Valak malware loader to deliver the IcedID banking trojan.1,","seoConfigJson":"","rating":null,"contentUuid":"c0b618e6-c9b3-4bd5-9846-462ae306d5b3","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-valak-downloader.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":729,"url":"/threat-intelligence-reports/threat-intelligence--78","topics":["Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":171139,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/171139/thumbnails/400x300/ea482ec8-56b5-4e00-b521-e1cd85e61eff-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/171139/previews/ea482ec8-56b5-4e00-b521-e1cd85e61eff-1.png","imageId":163553,"slug":"threat-intelligence--77","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/171139/thumbnails/400x300/ea482ec8-56b5-4e00-b521-e1cd85e61eff-1.png","title":"BLM-Themed Malspam Delivers Trickbot Banking Trojan - 20200701","description":"On 25 June, Infoblox observed a Black Lives Matters (BLM)- themed malicious spam (malspam) campaign delivering Trickbot malware. Read More.","seoConfigJson":"","rating":null,"contentUuid":"8a35aafd-fef5-4294-a5d2-6a7e3b22f645","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-blm-themed-malspam-delivers-trickbot-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1585,"url":"/threat-intelligence-reports/threat-intelligence--77","topics":["Cybersecurity","Network Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":168836,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/168836/thumbnails/400x300/9183d3c6-869f-4c8c-99e9-bb1a9753628f-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/168836/previews/9183d3c6-869f-4c8c-99e9-bb1a9753628f-1.png","imageId":156602,"slug":"threat-intelligence--76","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/168836/thumbnails/400x300/9183d3c6-869f-4c8c-99e9-bb1a9753628f-1.png","title":"GuLoader Drops NanoCore - 20200624","description":"From 8 to 10 June, we observed a malicious spam (malspam) email campaign distributing the malware downloader GuLoader, which dropped the NanoCore remote access trojan (RAT).","seoConfigJson":"","rating":null,"contentUuid":"56e5223a-64e2-41de-813d-67ea240a34d9","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-guloader-drops-nanocore.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":665,"url":"/threat-intelligence-reports/threat-intelligence--76","topics":["Cybersecurity","Security","Cyber Intelligence Unit","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":164303,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/164303/thumbnails/400x300/ba59b6d7-6e7f-4f45-b1e6-f1c36f2c4180-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/164303/previews/ba59b6d7-6e7f-4f45-b1e6-f1c36f2c4180-1.png","imageId":150238,"slug":"threat-intelligence--75","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/164303/thumbnails/400x300/ba59b6d7-6e7f-4f45-b1e6-f1c36f2c4180-1.png","title":"New Ransomware – Avaddon - 20200617","description":"On 9 June, Infoblox detected a malicious spam (malspam) campaign delivering a new type of ransomware known as Avaddon. The threat actor used a ZIP compressed file containing malicious JavaScript files. Read More. ","seoConfigJson":"","rating":null,"contentUuid":"d7db388b-390b-4768-97bb-a4666c958bd8","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-new-ransom-avaddon.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1235,"url":"/threat-intelligence-reports/threat-intelligence--75","topics":["Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":160367,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/160367/thumbnails/400x300/af04542b-8977-4336-bfb2-96ee9f7969bd-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/160367/previews/af04542b-8977-4336-bfb2-96ee9f7969bd-1.png","imageId":144657,"slug":"threat-intelligence--74","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/160367/thumbnails/400x300/af04542b-8977-4336-bfb2-96ee9f7969bd-1.png","title":"New Malware Variant: Project Taurus Infostealer Follows in Predator the Thief’s Footprints - 20200608","description":"From 20 May through 6 June, Infoblox observed a series of large malicious spam (malspam) campaigns distributing a new malware available on the dark web, coined Taurus Project by its developers. It is advertised in Russian forums as an information stealer (infostealer) with a wide array of capabilities, including stealing VPN, social media, and cryptocurrency credentials; and taking screenshots of the victim’s desktop.","seoConfigJson":"","rating":null,"contentUuid":"404740e2-f317-4ae6-9c5a-da2aa5088fd6","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-project-taurus-infostealer-follows-in-predator-the-thiefs-footprints.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1678,"url":"/threat-intelligence-reports/threat-intelligence--74","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":159538,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/159538/thumbnails/400x300/a3919bb7-d5d9-440b-99ce-aadbfb748885-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/159538/previews/a3919bb7-d5d9-440b-99ce-aadbfb748885-1.png","imageId":142899,"slug":"threat-intelligence--73","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/159538/thumbnails/400x300/a3919bb7-d5d9-440b-99ce-aadbfb748885-1.png","title":"COVID-19 Unemployment Fraud - 20200522","description":"On 21 May, Agari Data published an article highlighting recent Coronavirus (COVID-19)-related unemployment fraud activities victimizing several states across the U.S. and targeting Washington State in particular. Read More.","seoConfigJson":"","rating":null,"contentUuid":"a6e55d56-d4bb-4f6b-98f0-5e721f640fde","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-covid-19-unemployment-fraud.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":799,"url":"/threat-intelligence-reports/threat-intelligence--73","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":145361,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/145361/thumbnails/400x300/74071f23-a6a1-43dc-9e39-214ab98887a8-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/145361/previews/74071f23-a6a1-43dc-9e39-214ab98887a8-1.png","imageId":116031,"slug":"threat-intelligence--72","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/145361/thumbnails/400x300/74071f23-a6a1-43dc-9e39-214ab98887a8-1.png","title":"Dridex Malspam Spoofs Messaging from Popular Accounting Software Company - 20200512","description":"On 5 May, Infoblox observed a malicious spam (malspam) campaign using Microsoft Excel (XLS) documents to deliver the Dridex banking trojan via embedded PowerShell commands.","seoConfigJson":"","rating":null,"contentUuid":"b38a8570-6c4b-4e81-917d-62c5a9900289","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-dridex-malspam-spoofs-messaging-from-popular-accounting-software-company.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1537,"url":"/threat-intelligence-reports/threat-intelligence--72","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":135781,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/135781/thumbnails/400x300/583a6a43-c35a-4087-bedb-d79bf1019a20-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/135781/previews/583a6a43-c35a-4087-bedb-d79bf1019a20-1.png","imageId":102623,"slug":"threat-intelligence--71","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/135781/thumbnails/400x300/583a6a43-c35a-4087-bedb-d79bf1019a20-1.png","title":"WebMonitor RAT Hidden in Videoconferencing Software Installer - 20200506","description":"On 29 April, Trend Micro reported a malicious campaign that used a booby-trapped installer for Zoom videoconferencing software to deliver the WebMonitor remote access trojan (RAT).","seoConfigJson":"","rating":null,"contentUuid":"0c8d1745-e69f-4985-acb7-be5610882ed1","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-webmonitor-rat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":962,"url":"/threat-intelligence-reports/threat-intelligence--71","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":133931,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/133931/thumbnails/400x300/b5a4321b-50df-4106-9149-11e080ca0edb-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/133931/previews/b5a4321b-50df-4106-9149-11e080ca0edb-1.png","imageId":100493,"slug":"threat-intelligence--70","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/133931/thumbnails/400x300/b5a4321b-50df-4106-9149-11e080ca0edb-1.png","title":"Zloader Campaign Uses Excel 4.0 Macros - 20200428","description":"On 17 April, we observed a malicious spam (malspam) campaign using Microsoft Excel documents to deliver Zloader malware via Excel 4.0 macros, also known as XLM macros. Excel 4.0 macros are the precursor to VBA macros and contain similar functionality. ","seoConfigJson":"","rating":null,"contentUuid":"e5e84ab2-cbab-485f-a520-f23e9bb0cbfd","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-zloader-campaign-uses-excel-4-macros.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1248,"url":"/threat-intelligence-reports/threat-intelligence--70","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":132408,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/132408/thumbnails/400x300/0449e177-b24f-4ccc-9ca4-d1a780dd28cf-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/132408/previews/0449e177-b24f-4ccc-9ca4-d1a780dd28cf-1.png","imageId":98773,"slug":"threat-intelligence--69","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/132408/thumbnails/400x300/0449e177-b24f-4ccc-9ca4-d1a780dd28cf-1.png","title":"Spoofed Humana Healthcare Malspam Campaign Delivers Hancitor Infostealer - 20200422","description":"As with recent campaigns Infoblox has observed, this campaign follows the trend of malicious actors using the fear and uncertainty surrounding the COVID-19 pandemic to take advantage of users.","seoConfigJson":"","rating":null,"contentUuid":"13c122af-5de0-435a-a51e-47568c4ffa83","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-humana-healthcare.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":921,"url":"/threat-intelligence-reports/threat-intelligence--69","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":127496,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/127496/thumbnails/400x300/81190884-5b99-4abe-aa1b-cac9268a939a-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/127496/previews/81190884-5b99-4abe-aa1b-cac9268a939a-1.png","imageId":94117,"slug":"threat-intelligence--68","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/127496/thumbnails/400x300/81190884-5b99-4abe-aa1b-cac9268a939a-1.png","title":"Qakbot Infostealer on Microsoft OneDrive - 20200415","description":"On 8 April, security researcher Brad Duncan reported a malicious campaign that used Microsoft OneDrive to host compressed Microsoft Word documents with malicious macros that delivered Qakbot malware.1","seoConfigJson":"","rating":null,"contentUuid":"d1a5dc5a-59a8-4786-a4da-1533345f42b6","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-qakbot-Infostealer-on-microsoft-onedrive.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":889,"url":"/threat-intelligence-reports/threat-intelligence--68","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":125231,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/125231/thumbnails/390x292/8eeca1a5-2a40-4175-9cba-139f6f948acc-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/125231/previews/8eeca1a5-2a40-4175-9cba-139f6f948acc-1.png","imageId":91531,"slug":"threat-intelligence--67","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/125231/thumbnails/390x292/8eeca1a5-2a40-4175-9cba-139f6f948acc-1.png","title":"Formbook Coronavirus Campaigns - 20200407","description":"From 24 March through 2 April, Infoblox observed several malicious spam (malspam) campaigns delivering Formbook malware. The campaigns are loosely connected by a Coronavirus or COVID-19-related theme in their subject lines or file attachment names.","seoConfigJson":"","rating":null,"contentUuid":"2d85e71c-4b17-41dc-9c5e-aa7626f9b653","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-formbook-coronavirus-campaigns.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":868,"url":"/threat-intelligence-reports/threat-intelligence--67","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":123500,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/123500/thumbnails/390x292/14dbcc01-1dab-4411-a4f7-994bfe479c28-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/123500/previews/14dbcc01-1dab-4411-a4f7-994bfe479c28-1.png","imageId":89796,"slug":"threat-intelligence--66","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/123500/thumbnails/390x292/14dbcc01-1dab-4411-a4f7-994bfe479c28-1.png","title":"Trickbot WHO - 20200401","description":"From 21 to 24 March, Infoblox observed another malicious spam (malspam) email campaign that used a fraudulent Coronavirus alert from the World Health Organization (WHO) to deliver Trickbot banking malware. Read More","seoConfigJson":"","rating":null,"contentUuid":"3f2b0053-5249-419e-a81f-415bc858d5d8","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-trickbot-who.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1227,"url":"/threat-intelligence-reports/threat-intelligence--66","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":122486,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/122486/thumbnails/390x292/e5c0b404-a7c6-436d-843e-5b3e6d9d20b1-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/122486/previews/e5c0b404-a7c6-436d-843e-5b3e6d9d20b1-1.png","imageId":88869,"slug":"threat-intelligence--65","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/122486/thumbnails/390x292/e5c0b404-a7c6-436d-843e-5b3e6d9d20b1-1.png","title":"Series of New Agent Tesla Infostealer Campaigns Use Coronavirus Themes - 20200324","description":"Since 16 March, we observed a series of campaigns using COVID-19 or Coronavirus-themed spam emails to distribute the Agent Tesla information stealer (infostealer). Read More. ","seoConfigJson":"","rating":null,"contentUuid":"5049397a-541a-4c2c-b7d4-df148a7ab73e","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-agent-telsa-infostealer-use-coronavirus-themes-v2.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1312,"url":"/threat-intelligence-reports/threat-intelligence--65","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":121080,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/121080/thumbnails/390x292/d335d9ea-8183-49b7-bf19-8bd18a885a35-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/121080/previews/d335d9ea-8183-49b7-bf19-8bd18a885a35-1.png","imageId":87343,"slug":"threat-intelligence--63","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/121080/thumbnails/390x292/d335d9ea-8183-49b7-bf19-8bd18a885a35-1.png","title":"Spoofed Coronavirus Map Delivers AZORult Infostealer - 20200318","description":"Infoblox has been monitoring Coronavirus-themed lures; this is our second Cyber Campaign Brief on the topic. Read More.","seoConfigJson":"","rating":null,"contentUuid":"b037266f-8db1-4dc0-b49e-38795c647467","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-spoofed-coronavirus-map-delivers-azorult-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1257,"url":"/threat-intelligence-reports/threat-intelligence--63","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":119478,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/119478/thumbnails/390x292/c6ec9893-5af6-434d-bcbc-e98133642d2d-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/119478/previews/c6ec9893-5af6-434d-bcbc-e98133642d2d-1.png","imageId":85908,"slug":"threat-intelligence--62","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/119478/thumbnails/390x292/c6ec9893-5af6-434d-bcbc-e98133642d2d-1.png","title":"Lokibot Rides Fear Of Coronavirus - 20200310","description":"From 3 to 6 March, we observed two malicious spam (malspam) email campaigns distributing LokiBot under the guise of providing information on Coronavirus’ impact on supply chains. Read More.","seoConfigJson":"","rating":null,"contentUuid":"6559c514-c1e7-46af-9495-54d69c39ccaf","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-lokibot-rides-fear-of-coronavirus.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1541,"url":"/threat-intelligence-reports/threat-intelligence--62","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":117898,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/117898/thumbnails/390x292/6061e691-fd25-47aa-a794-1b01c54fb1c1-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/117898/previews/6061e691-fd25-47aa-a794-1b01c54fb1c1-1.png","imageId":84606,"slug":"threat-intelligence--61","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/117898/thumbnails/390x292/6061e691-fd25-47aa-a794-1b01c54fb1c1-1.png","title":"Nemty Ransomware Loves You  - 20200304","description":"Last week, Nemty ransomware made its first attempt to target English-speaking victims with a malicious spam (malspam) campaign.","seoConfigJson":"","rating":null,"contentUuid":"f2c8e688-5424-4fd3-804c-8bcbd55c0157","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-nemty-ransomware-loves-you.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1106,"url":"/threat-intelligence-reports/threat-intelligence--61","topics":["Malware","Ransomware"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":115878,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/115878/thumbnails/390x292/0e3bcea1-7946-4e9e-ad31-3b3de07c88d4-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/115878/previews/0e3bcea1-7946-4e9e-ad31-3b3de07c88d4-1.png","imageId":82979,"slug":"threat-intelligence--60","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/115878/thumbnails/390x292/0e3bcea1-7946-4e9e-ad31-3b3de07c88d4-1.png","title":"Nemty Ransomware - 20200219","description":"On 12 February, we observed a series of samples that delivered Nemty ransomware via a ZIP compressed file embedded with a malicious VBScript (Visual Basic Script). Nemty was first discovered in August 2019. Read More. ","seoConfigJson":"","rating":null,"contentUuid":"d1afea1e-ca0e-4178-80b1-04460491080b","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-nemty-ransomware.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1271,"url":"/threat-intelligence-reports/threat-intelligence--60","topics":["Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":114449,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/114449/thumbnails/390x292/bb5d4f9b-9f73-4747-9aba-0bccc2b15e25-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/114449/previews/bb5d4f9b-9f73-4747-9aba-0bccc2b15e25-1.png","imageId":81536,"slug":"threat-intelligence--58","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/114449/thumbnails/390x292/bb5d4f9b-9f73-4747-9aba-0bccc2b15e25-1.png","title":"Linked SWIFT-Themed Campaigns Deliver Keyloggers and Infostealers - 20200212","description":"From 1 through 6 February, we observed several campaigns using malicious spam emails (malspam) with themes pertaining to SWIFT payments or SWIFT copies. Read more.","seoConfigJson":"","rating":null,"contentUuid":"dd8917b5-f60b-4286-bf24-10ea044b95d7","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-linked-swift-themed.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1163,"url":"/threat-intelligence-reports/threat-intelligence--58","topics":[],"personas":[],"industries":[],"businessUnits":[],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":113453,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/113453/thumbnails/390x292/5fc2e47d-e2b1-45eb-9abb-57fdc438c9d8-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/113453/previews/5fc2e47d-e2b1-45eb-9abb-57fdc438c9d8-1.png","imageId":80679,"slug":"threat-intelligence--57","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/113453/thumbnails/390x292/5fc2e47d-e2b1-45eb-9abb-57fdc438c9d8-1.png","title":"Large, Similar VBS Files Link Campaigns Delivering DanaBot, Ursnif and More - 20200205","description":"Between 28 and 29 January, Infoblox observed malicious email campaigns using unusually large and similar compressed Visual Basic Script (VBS) files to deliver multiple families of malware, including DanaBot, Ursnif, and at least one other. Read More.","seoConfigJson":"","rating":null,"contentUuid":"b417c22d-7f4c-4ec6-83ec-dc1a88d92b79","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-danabot-ursnif-and-more.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":902,"url":"/threat-intelligence-reports/threat-intelligence--57","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":112603,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/112603/thumbnails/390x292/5838f131-1682-4913-9ca3-626c452b5364-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/112603/previews/5838f131-1682-4913-9ca3-626c452b5364-1.png","imageId":79914,"slug":"threat-intelligence--56","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/112603/thumbnails/390x292/5838f131-1682-4913-9ca3-626c452b5364-1.png","title":"Ursnif Banking Trojan Targets Germany and Italy - 20200129","description":"Between 23 and 24 January, security researcher Brad Duncan reported two separate malicious spam campaigns that used compressed Microsoft Word documents with malicious macros to deliver Ursnif malware. Read More.","seoConfigJson":"","rating":null,"contentUuid":"b64e9365-198c-4859-9efa-1f110d69dc07","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-ursnif-banking-trojan-targets-germany-and-italy.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":974,"url":"/threat-intelligence-reports/threat-intelligence--56","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":111296,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/111296/thumbnails/390x292/1239137d-20ad-4c2c-a15e-7ed4c830178e-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/111296/previews/1239137d-20ad-4c2c-a15e-7ed4c830178e-1.png","imageId":78847,"slug":"threat-intelligence--55","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/111296/thumbnails/390x292/1239137d-20ad-4c2c-a15e-7ed4c830178e-1.png","title":"Malspam Campaigns Deliver Predator the Thief InfoStealer - 20200122","description":"From late December through 14 January, we observed two malspam campaigns delivering an information stealer called Predator the Thief (Predator).","seoConfigJson":"","rating":null,"contentUuid":"33d0d989-7523-4439-8057-9cb679d75c5e","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malspam-campaigns-deliver-predator-thief-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":960,"url":"/threat-intelligence-reports/threat-intelligence--55","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":109729,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/109729/thumbnails/390x292/45d9744f-969f-44ab-8273-32b545417190-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/109729/previews/45d9744f-969f-44ab-8273-32b545417190-1.png","imageId":77352,"slug":"threat-intelligence--54","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/109729/thumbnails/390x292/45d9744f-969f-44ab-8273-32b545417190-1.png","title":"Brushaloader Shows New Features in Campaign Targeting Polish Speakers - 20200114","description":"During the week of 6 January, we observed an email campaign that distributed Brushaloader to Polish speaking users. Read More.","seoConfigJson":"","rating":null,"contentUuid":"07d46d23-a4f8-46ee-aadd-0061cd93af0c","mediaType":"pdf","sourceUrl":"https://cdn.pathfactory.com/assets/10336/contents/109729/45d9744f-969f-44ab-8273-32b545417190.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1025,"url":"/threat-intelligence-reports/threat-intelligence--54","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":108955,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/108955/thumbnails/390x292/4b8269e5-aef4-43b7-94cf-c6b8b2844730-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/108955/previews/4b8269e5-aef4-43b7-94cf-c6b8b2844730-1.png","imageId":76656,"slug":"threat-intelligence--53","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/108955/thumbnails/390x292/4b8269e5-aef4-43b7-94cf-c6b8b2844730-1.png","title":"How Emotet Stole Christmas - 20200107","description":"Emotet is an information stealer and trojan downloader that targets businesses and individuals around the world. Read More.","seoConfigJson":"","rating":null,"contentUuid":"d5eec9a6-51f5-49f8-8c54-29b44d203e33","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-how-emotet-stole-christmas.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1086,"url":"/threat-intelligence-reports/threat-intelligence--53","topics":["Cyberspace"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":107386,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/107386/thumbnails/390x292/1dab0b66-9f53-4018-a052-5198b8ae01b6-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/107386/previews/1dab0b66-9f53-4018-a052-5198b8ae01b6-1.png","imageId":75089,"slug":"threat-intelligence--52","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/107386/thumbnails/390x292/1dab0b66-9f53-4018-a052-5198b8ae01b6-1.png","title":"PsiXBot InfoStealer Uses DNS over HTTPS - 20191217","description":"On 11 December, Malware Traffic Analysis reported on a campaign in which a threat actor was delivering PsiXBot via the Spelevo exploit kit (EK).1 PsiXBot steals information, adds computers to its botnet and uses DNS over HTTPS (DoH). Read More.","seoConfigJson":"","rating":null,"contentUuid":"9d7ba8ef-8d68-4441-8052-a32cc896ae68","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-psixbot-infostealer-uses-dns-over-https.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1728,"url":"/threat-intelligence-reports/threat-intelligence--52","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":106043,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/106043/thumbnails/390x292/cf7d0d60-f40f-47df-977e-3591422fb551-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/106043/previews/cf7d0d60-f40f-47df-977e-3591422fb551-1.png","imageId":73889,"slug":"threat-intelligence--51","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/106043/thumbnails/390x292/cf7d0d60-f40f-47df-977e-3591422fb551-1.png","title":"Dridex Banking Trojan Hides in Fake Payroll Notifications - 20191210","description":"On 5 December, the Department of Treasury Financial Sector Cyber Information Group and the Department of the Treasury’s Financial Crimes Enforcement Network published a joint awareness alert regarding Dridex. Read More.","seoConfigJson":"","rating":null,"contentUuid":"a2e7b77b-4607-4658-a958-8dad7869c963","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-dridex-banking-trojan-fake-payroll.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1243,"url":"/threat-intelligence-reports/threat-intelligence--51","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":104694,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/104694/thumbnails/390x292/9a91dfc1-3392-45bb-ac19-15b7b52814e3-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/104694/previews/9a91dfc1-3392-45bb-ac19-15b7b52814e3-1.png","imageId":72686,"slug":"threat-intelligence--48","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/104694/thumbnails/390x292/9a91dfc1-3392-45bb-ac19-15b7b52814e3-1.png","title":"Polish Malspam Delivers Ursnif Banking Trojan - 20191126","description":"On 21 November, Infoblox observed a malicious email campaign delivering the Ursnif banking trojan. This campaign targeted Polish-speaking victims and used tax return deadlines as a lure. Read More.","seoConfigJson":"","rating":null,"contentUuid":"b224e77f-b295-4a81-ac96-513f31b80df8","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-polish-malspam-delivers-ursnif-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1059,"url":"/threat-intelligence-reports/threat-intelligence--48","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":103457,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/103457/thumbnails/390x292/39e73c5d-b00c-4ef7-8c22-6fdbd5c07cdf-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/103457/previews/39e73c5d-b00c-4ef7-8c22-6fdbd5c07cdf-1.png","imageId":71342,"slug":"threat-intelligence--47","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/103457/thumbnails/390x292/39e73c5d-b00c-4ef7-8c22-6fdbd5c07cdf-1.png","title":"Dreambot Banking Trojan Targets Czech and Slovenian Speakers - 20191120","description":"On 7 November, we observed two email campaigns distributing the banking trojan Dreambot, which is a variant of Ursnif.1  Threat actors have distributed Dreambot since 2016, targeting financial customers in Australia, Italy, Switzerland, the U.K., the U.S., Poland, and Canada.2","seoConfigJson":"","rating":null,"contentUuid":"18c788ef-23ca-4bc1-a754-178d25f7bfb0","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-dreambot-banking-trojan-targets-czech-and-slovenian-speakers.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1105,"url":"/threat-intelligence-reports/threat-intelligence--47","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":105475,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/105475/thumbnails/390x292/3115c801-f597-417e-962e-576a24f9a077-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/105475/previews/3115c801-f597-417e-962e-576a24f9a077-1.png","imageId":73334,"slug":"threat-intelligence--50","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/105475/thumbnails/390x292/3115c801-f597-417e-962e-576a24f9a077-1.png","title":"Rig Exploit Kit Drops Predator - 20191119","description":"On 17 November, Broad Analysis reported1 a campaign that used Rig exploit kit to distribute an infostealer known as Predator The Thief, followed by a variant of CrySIS ransomware. Read More. ","seoConfigJson":"","rating":null,"contentUuid":"e2e5cffe-5221-4b7c-a687-37a112d1200e","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-rig-exploit-kit-drops-predator.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1164,"url":"/threat-intelligence-reports/threat-intelligence--50","topics":["Cybersecurity"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":102408,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/102408/thumbnails/390x292/88a9209f-f789-48a9-bd2c-ec74d5b6eee0-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/102408/previews/88a9209f-f789-48a9-bd2c-ec74d5b6eee0-1.png","imageId":70373,"slug":"threat-intelligence--46","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/102408/thumbnails/390x292/88a9209f-f789-48a9-bd2c-ec74d5b6eee0-1.png","title":"Maze Ransomware Campaign - 20191105","description":"On 29 October, we detected a campaign distributing Maze ransomware (a variant of ChaCha ransomware) to Italian-speaking users. Read More.","seoConfigJson":"","rating":null,"contentUuid":"35ca221e-d9b1-4fb0-b17f-38d9306b8d2d","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-maze-ransomware-campaign-spoofs-Italian-revenue-agency-correspondence.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1125,"url":"/threat-intelligence-reports/threat-intelligence--46","topics":["Cyberspace"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":99594,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/99594/thumbnails/390x292/0e6d4a50-9036-4316-8ece-3a0811baf5a5-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/99594/previews/0e6d4a50-9036-4316-8ece-3a0811baf5a5-1.png","imageId":67820,"slug":"threat-intelligence--45","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/99594/thumbnails/390x292/0e6d4a50-9036-4316-8ece-3a0811baf5a5-1.png","title":"Netwire Remote Access Trojan (RAT) - 20191029","description":"On 22 October, we observed an email campaign distributing the Netwire remote access trojan (RAT), also known as Recam and NetWiredRC.1 Since 2012, threat actors and at least one advanced persistent threat (APT) group2 have been using this publicly available, multiplatform tool in campaigns targeting a variety of systems and industries in the Middle East. read More.","seoConfigJson":"","rating":null,"contentUuid":"98488f30-012e-415e-a5e9-9b3c40902c9b","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-netwire-remote-access-trojan-rat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1594,"url":"/threat-intelligence-reports/threat-intelligence--45","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":98287,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/98287/thumbnails/390x292/b15ccce7-c3ec-4e2b-b306-2494799d5592-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/98287/previews/b15ccce7-c3ec-4e2b-b306-2494799d5592-1.png","imageId":66685,"slug":"threat-intelligence--44","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/98287/thumbnails/390x292/b15ccce7-c3ec-4e2b-b306-2494799d5592-1.png","title":"FTCODE Ransomware Target Victims In Italy - 20191022","description":"From 15 to 17 October, CERT-PA of Italy reported on an email campaign delivering FTCODE ransomware to victims in Italy.1 FTCODE is a family of ransomware that recently resurfaced after a six year hiatus. Read More.","seoConfigJson":"","rating":null,"contentUuid":"a4a26401-6304-45c7-a77c-cf900939ea27","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-ftcode-ransomware-target-victims-in-italy.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1063,"url":"/threat-intelligence-reports/threat-intelligence--44","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":97131,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/97131/thumbnails/390x292/fe6b378b-1a71-42ed-855a-faf0879ed399-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/97131/previews/fe6b378b-1a71-42ed-855a-faf0879ed399-1.png","imageId":65621,"slug":"threat-intelligence--43","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/97131/thumbnails/390x292/fe6b378b-1a71-42ed-855a-faf0879ed399-1.png","title":"Series of MageCart Campaigns Target Financial Information - 20191015","description":"Between 30 September and 9 October, at least three threat research teams published independent reports on MageCart malware campaigns they had observed in the wild. Read More.","seoConfigJson":"","rating":null,"contentUuid":"2d678863-fd43-4378-9fc9-820e36c7f707","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-series-of-magecart-campaigns-target-financial-information.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1138,"url":"/threat-intelligence-reports/threat-intelligence--43","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":95325,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/95325/thumbnails/390x292/82852023-efd0-4a33-aa69-319cccb8a29d-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/95325/previews/82852023-efd0-4a33-aa69-319cccb8a29d-1.png","imageId":64261,"slug":"threat-intelligence--42","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/95325/thumbnails/390x292/82852023-efd0-4a33-aa69-319cccb8a29d-1.png","title":"Quasar Remote Access Trojan (RAT) - 20191002","description":"During 24-26 September, we discovered a large malicious email (malspam) campaign distributing the Quasar remote administration tool. Read More.","seoConfigJson":"","rating":null,"contentUuid":"40fd12f8-374b-47e6-b6d9-f5fa3146e875","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-quasar-remote-access-trojan-rat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1576,"url":"/threat-intelligence-reports/threat-intelligence--42","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":93344,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/93344/thumbnails/390x292/23066e0d-5430-414b-8824-b3128b9bfe80-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/93344/previews/23066e0d-5430-414b-8824-b3128b9bfe80-1.png","imageId":62637,"slug":"threat-intelligence--39","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/93344/thumbnails/390x292/23066e0d-5430-414b-8824-b3128b9bfe80-1.png","title":"Formbook Infostealer Campaigns Continue - 20190917","description":"On 13 September, Infoblox observed a malicious email campaign delivering Formbook malware via rich text format (RTF) file attachments. We have seen Formbook malware being delivered this way throughout the year. In this campaign, emails appear to come from Makati Development Corporation, a construction firm in the Philippines. Read More.","seoConfigJson":"","rating":null,"contentUuid":"a15b835b-9684-4f51-82c3-8f956b5e3c9b","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-formbook-infostealer-campaigns-continue.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1142,"url":"/threat-intelligence-reports/threat-intelligence--39","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":93543,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/93543/thumbnails/390x292/threat-intelligence-report-radio-ek-drops-nemty-ransomware-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/93543/previews/threat-intelligence-report-radio-ek-drops-nemty-ransomware-1.png","imageId":82115,"slug":"threat-intelligence--41","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/93543/thumbnails/390x292/threat-intelligence-report-radio-ek-drops-nemty-ransomware-1.png","title":"Radio EK Drops Nemty Ransomware - 20190911","description":"On 9 September, cybersecurity research group “nao_sec” reported a malicious advertising (malvertising) campaign that used the Radio exploit kit (EK) to infect vulnerable systems with Nemty ransomware. Keep reading...","seoConfigJson":"","rating":null,"contentUuid":"5af4cc9d-67fc-451c-8661-55523818a714","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-radio-ek-drops-nemty-ransomware.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":974,"url":"/threat-intelligence-reports/threat-intelligence--41","topics":["Cybersecurity"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":93359,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/93359/thumbnails/390x292/threat-intelligence-report-hidden-cobra-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/93359/previews/threat-intelligence-report-hidden-cobra-1.png","imageId":62781,"slug":"threat-intelligence--40","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/93359/thumbnails/390x292/threat-intelligence-report-hidden-cobra-1.png","title":"Hidden Cobra - 20190910","description":"On 9 September the Department of Homeland Security (DHS), the Federal Bureau of Investigation (FBI), and the Department of Defense (DoD) jointly published updates to their Malware Analysis Reports (MARs) about trojan malware variants known as BADCALL1 and ELECTRICFISH2. Read More.","seoConfigJson":"","rating":null,"contentUuid":"cfedafdf-bf4d-4088-af4d-80463dbb8de9","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-hidden-cobra.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":939,"url":"/threat-intelligence-reports/threat-intelligence--40","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":91711,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/91711/thumbnails/390x292/threat-intelligence-report-malspam-campaigns-deliver-orcas-rat-and-revengerat-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/91711/previews/threat-intelligence-report-malspam-campaigns-deliver-orcas-rat-and-revengerat-1.png","imageId":61398,"slug":"threat-intelligence--38","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/91711/thumbnails/390x292/threat-intelligence-report-malspam-campaigns-deliver-orcas-rat-and-revengerat-1.png","title":"Malspam Campaigns Deliver Orcas RAT And RevengeRAT - 20190904","description":"According to a 28 August report, a recent set of malicious email campaigns sought to deliver two remote access trojans (RATs) to financial services organizations, IT service providers, and government entities. Read More.","seoConfigJson":"","rating":null,"contentUuid":"7e955d11-590a-41bd-ac33-fb561b7be2f6","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malspam-campaigns-deliver-orcas-rat-and-revengerat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1038,"url":"/threat-intelligence-reports/threat-intelligence--38","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":90906,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/90906/thumbnails/390x292/a67d38f7-32bd-4e3b-89e2-939e38af0450-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/90906/previews/a67d38f7-32bd-4e3b-89e2-939e38af0450-1.png","imageId":60640,"slug":"threat-intelligence--37","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/90906/thumbnails/390x292/a67d38f7-32bd-4e3b-89e2-939e38af0450-1.png","title":"Shade Ransomware Targets Russian Speaking Users - 20190827","description":"During 20-21 August, we detected a large number of emails distributing Shade ransomware to Russian-speaking users. Read More.","seoConfigJson":"","rating":null,"contentUuid":"f2ff9941-ac2f-4974-b0f1-9451ad0974ec","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-shade-ransomware-targets-russian-speaking-users.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":899,"url":"/threat-intelligence-reports/threat-intelligence--37","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":90176,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/90176/thumbnails/390x292/3784543f-db25-45fc-ad6b-75e9f03972b5-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/90176/previews/3784543f-db25-45fc-ad6b-75e9f03972b5-1.png","imageId":60013,"slug":"threat-intelligence--35","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/90176/thumbnails/390x292/3784543f-db25-45fc-ad6b-75e9f03972b5-1.png","title":"Threat Intelligence Report Jasperloader Delivers Gootkit Banking Trojan - 20190820","description":"In late July and early August, Infoblox observed a campaign targeting Italy that distributed the GootKit banking trojan via JasperLoader. GootKit first emerged in 2014. Read More.","seoConfigJson":"","rating":null,"contentUuid":"3323e52d-2cda-4b45-ae06-a12e79c5f66c","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-jasperloader-delivers-gootkit-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":887,"url":"/threat-intelligence-reports/threat-intelligence--35","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":90903,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/90903/thumbnails/390x292/61beea24-3c23-4010-be54-a3ce4bc264c3-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/90903/previews/61beea24-3c23-4010-be54-a3ce4bc264c3-1.png","imageId":60637,"slug":"threat-intelligence--36","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/90903/thumbnails/390x292/61beea24-3c23-4010-be54-a3ce4bc264c3-1.png","title":"Amadey Trojan And Botnet -  20190814","description":"We observed a large number of emails related to this campaign. Amadey was first seen in late 2018 when the author put the botnet up for sale on Russian online forums. Read More.","seoConfigJson":"","rating":null,"contentUuid":"06a1c73f-1fcf-4279-807a-b0b185bcf6de","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-amadey-trojan-and-botnet.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":896,"url":"/threat-intelligence-reports/threat-intelligence--36","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":88587,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/88587/thumbnails/390x292/threat-intelligence-report-adwind-remote-access-trojan-rat-campaign-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/88587/previews/threat-intelligence-report-adwind-remote-access-trojan-rat-campaign-1.png","imageId":58898,"slug":"threat-intelligence--34","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/88587/thumbnails/390x292/threat-intelligence-report-adwind-remote-access-trojan-rat-campaign-1.png","title":"Adwind Remote Access Trojan (RAT) Campaign - 20190807","description":"In late July and early August, Infoblox observed a campaign distributing the Adwind remote access trojan (RAT). Adwind is a widely used Malware-as-a-Service (MaaS) platform that first appeared in 2012 as the Frutas RAT. ","seoConfigJson":"","rating":null,"contentUuid":"790f258b-875b-413c-a727-23bdf5f57ae2","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-adwind-remote-access-trojan-rat-campaign.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1003,"url":"/threat-intelligence-reports/threat-intelligence--34","topics":["Cybersecurity","Security","Cyber Threat Intelligence"],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":[],"assetTypes":[]},{"id":87132,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/87132/thumbnails/390x292/0756b203-2ace-479c-8827-627d580fd50c-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/87132/previews/0756b203-2ace-479c-8827-627d580fd50c-1.png","imageId":57420,"slug":"threat-intelligence--33","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/87132/thumbnails/390x292/0756b203-2ace-479c-8827-627d580fd50c-1.png","title":"New Andromut Downloader Drops Flawedammyy Rat - 20190731","description":"From 22 to 24 July, we observed a malicious email campaign distributing the new AndroMut downloader, which in turn dropped the FlawedAmmyy remote access trojan (RAT). Proofpoint attributed the campaign to threat actor TA505, which they assess is also linked to other prevalent malware such as the Dridex banking trojan, Locky ransomware, and Jaff ransomware. Read more.","seoConfigJson":"","rating":null,"contentUuid":"e90d8948-88df-46cb-910c-fb25ec9a9aec","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-new-andromut-downloader-drops-flawedammyy-rat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1036,"url":"/threat-intelligence-reports/threat-intelligence--33","topics":[],"personas":[],"industries":[],"businessUnits":[],"funnelStages":[],"assetTypes":[]},{"id":86622,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/86622/thumbnails/390x292/6656d1f4-088e-4c65-b34d-fbd8dd868401-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/86622/previews/6656d1f4-088e-4c65-b34d-fbd8dd868401-1.png","imageId":56924,"slug":"threat-intelligence--32","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/86622/thumbnails/390x292/6656d1f4-088e-4c65-b34d-fbd8dd868401-1.png","title":"New Remcos RAT Campaign Uses Simplified Delivery Tactic - 20190724","description":"From mid-June to July, Infoblox observed a campaign distributing the Remcos remote access trojan (RAT). We previously wrote about Remcos in December 2018, regarding a campaign in which Microsoft Word files with embedded dynamic data exchange (DDE) protocol prompted the recipient to update the file. Read more. ","seoConfigJson":"","rating":null,"contentUuid":"7d858580-2fb2-48e1-bc91-5b90cd8276dd","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-new-remcos-rat-campaign-uses-simplified-delivery-tactic.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":727,"url":"/threat-intelligence-reports/threat-intelligence--32","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":85551,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/55901/390x292/1024_1563898346-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/5b3182e0-ce7c-4082-b72c-c082f3795d42/1024_1563898346-1.png","imageId":55901,"slug":"threat-intelligence--30","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/55901/390x292/1024_1563898346-1.png","title":"Warezov Email Worm - 20190717","description":"During 9-12 July, we discovered a malicious spam campaign distributing the Warezov worm. Read more.","seoConfigJson":"","rating":null,"contentUuid":"684a32fd-0393-4637-ac11-b9eaff4c74d9","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-warezov-email-worm.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":902,"url":"/threat-intelligence-reports/threat-intelligence--30","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":85556,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/55906/390x292/1024_1563898895-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/94ee19e0-4d7b-4c50-b2e7-ac70fa57d07c/1024_1563898895-1.png","imageId":55906,"slug":"threat-intelligence--31","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/55906/390x292/1024_1563898895-1.png","title":"Smokeloader Downloader Delivers Spoofed HBL Bank Invoice - 20190702","description":"On 26 June, Infoblox observed an email campaign that distributed Smokeloader via malicious email attachments. Messages in this campaign appeared to be financial correspondence containing an HBL Bank invoice.","seoConfigJson":"","rating":null,"contentUuid":"5dad9c64-a402-4bd6-8a9e-44b1cc6d08e6","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-smokeloader-ader-downloader-delivers-spoofed-hbl-bank-invoice.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":871,"url":"/threat-intelligence-reports/threat-intelligence--31","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":83178,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54020/390x292/1024_1562606670-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/436b85fa-47b2-4c51-9495-6236196ccda1/1024_1562606670-1.png","imageId":54020,"slug":"threat-intelligence--18","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54020/390x292/1024_1562606670-1.png","title":"Detecting DNSpionage FQDNs - 20190626","description":"DNSpionage is a type of information stealer malware that uses Domain Name System (DNS) tunneling to covertly exfiltrate stolen data from government targets. Read More","seoConfigJson":"","rating":null,"contentUuid":"45dd9871-41e6-474a-aa47-696812d39111","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-detecting-dnspionage-fqdns.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1008,"url":"/threat-intelligence-reports/threat-intelligence--18","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":83185,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54157/390x292/1024_1562696800-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/a0507dd8-4da8-4a8d-830a-967c08fce52c/1024_1562696800-1.png","imageId":54157,"slug":"threat-intelligence--21","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54157/390x292/1024_1562696800-1.png","title":"Sodinokibi Ransomware Rises After Gandcrab Retires - 20190625","description":"Infoblox observed a malicious spam campaign that used Microsoft Word documents with malicious macros to deliver Sodinokibi ransomware. Read more about the ransomware.","seoConfigJson":"","rating":null,"contentUuid":"b80842ea-95c3-4eb7-9f20-6b7b253a5db2","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-sodinokibi-ransomware.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1164,"url":"/threat-intelligence-reports/threat-intelligence--21","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cloud"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":83204,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://cdn.pathfactory.com/assets/10336/contents/83204/thumbnails/390x292/threat-intelligence-report-cyber-threat-advisory-email-scam-spoofed-dhs-cyber-alert-1.png","imageUrlOriginal":"https://cdn.pathfactory.com/assets/10336/contents/83204/previews/threat-intelligence-report-cyber-threat-advisory-email-scam-spoofed-dhs-cyber-alert-1.png","imageId":56265,"slug":"threat-intelligence--28","thumbnail":"https://cdn.pathfactory.com/assets/10336/contents/83204/thumbnails/390x292/threat-intelligence-report-cyber-threat-advisory-email-scam-spoofed-dhs-cyber-alert-1.png","title":"Cyber Threat Advisory: Email Scam-Spoofed DHS Cyber Alert - 20190619","description":"On 18 June, the Department of Homeland Security (DHS) Cybersecurity and Infrastructure Security Agency (CISA) sent out a warning about an email phishing scam spoofing a DHS alert that is meant to entice users to open a malicious attachment. Read more","seoConfigJson":"","rating":null,"contentUuid":"a07d9067-c77c-4886-b902-23e4d47be8bb","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-cyber-threat-advisory-email-scam-spoofed-dhs-cyber-alert.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":935,"url":"/threat-intelligence-reports/threat-intelligence--28","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cloud","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":83179,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54022/390x292/1024_1562607046-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/6358560d-6cfc-4247-98c4-8dce238523b3/1024_1562607046-1.png","imageId":54022,"slug":"threat-intelligence--19","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54022/390x292/1024_1562607046-1.png","title":"Dridex Banking Trojan - 20190619","description":"Learn more about the emails distributing a banking trojan named Dridex which was discovered on 13 June.","seoConfigJson":"","rating":null,"contentUuid":"b84afe87-928d-47b0-b009-d371d42569da","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-dridex-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1026,"url":"/threat-intelligence-reports/threat-intelligence--19","topics":[],"personas":[],"industries":[],"businessUnits":["Security","NCCM"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":80475,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/51509/390x292/1024_1560545685-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/06a79004-bd38-4127-b7c9-f5bbc6536aef/1024_1560545685-1.png","imageId":51509,"slug":"threat-intelligence--15","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/51509/390x292/1024_1560545685-1.png","title":"MageCart Credit Card Skimmers - 20190611","description":"Read More about MageCart Credit Card Skimmers Found on Custom CloudFront CDN Libraries","seoConfigJson":"","rating":null,"contentUuid":"0dcc63aa-0b7a-4466-9f1e-b558408de154","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-magecart-credit-card.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1224,"url":"/threat-intelligence-reports/threat-intelligence--15","topics":["Cybersecurity"],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":80478,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/52166/390x292/1024_1561132298-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/c7af789c-7112-4710-98eb-b280ad5fd45d/1024_1561132298-1.png","imageId":52166,"slug":"threat-intelligence--17","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/52166/390x292/1024_1561132298-1.png","title":"AZORult Infostealer Delivered by Agent Tesla Keylogger - 20190605","description":"On 31 May, Infoblox observed a malicious email campaign masquerading as financial correspondence from Zenith Bank. The message attachments deliver the Agent Tesla keylogger, which unpacks and runs the AZORult infostealer upon infection.","seoConfigJson":"","rating":0,"contentUuid":"f931b20e-22ba-468f-bd04-81c60e53e512","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-azorult-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1196,"url":"/threat-intelligence-reports/threat-intelligence--17","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":80477,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54035/390x292/1024_1562610144-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/d923a606-f0cd-45b3-b0cf-d5b16c50ff27/1024_1562610144-1.png","imageId":54035,"slug":"threat-intelligence--16","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54035/390x292/1024_1562610144-1.png","title":"LokiBot InfoStealer Uses NGROK Tunneling Report - 20190530","description":"On 31 May, Infoblox observed a malicious email campaign On 28 May, My Online Security reported a LokiBot campaign abusing the NGROK tunneling service to create public URLs for malware payloads hosted on the attacker’s local systems. Keep reading.","seoConfigJson":"","rating":null,"contentUuid":"ec0898e6-a2a0-4b1f-9307-d869c8727b2f","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-lokibot-infostealer-uses-ngrok-tunneling.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1110,"url":"/threat-intelligence-reports/threat-intelligence--16","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cross Portfolio"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":76323,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/47998/390x292/1024_1558370692-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/efdd6718-050f-4b1c-af45-5513eb9b930b/1024_1558370692-1.png","imageId":47998,"slug":"threat-intelligence--13","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/47998/390x292/1024_1558370692-1.png","title":"MegaCortex Ransomware Report - 20190515","description":"Read more how this ransomware showed advanced capabilities that set it apart from traditional ransomware and enabled it to propagate to other devices on the target’s local area network (LAN).","seoConfigJson":"","rating":null,"contentUuid":"c308c97d-e6ad-4b79-bebf-6a774861a896","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-megacortex-ransomware.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1534,"url":"/threat-intelligence-reports/threat-intelligence--13","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":76324,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/47999/390x292/1024_1558370920-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/0319daf3-433a-496a-a1ac-621383980d54/1024_1558370920-1.png","imageId":47999,"slug":"threat-intelligence--14","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/47999/390x292/1024_1558370920-1.png","title":"njRAT/Bladabindi RAT Download Agent Tesla Keylogger - 20190508","description":"njRAT/Bladabindi can operate silently on a victim’s system and send information back to the attacker. Keep Reading.","seoConfigJson":"","rating":null,"contentUuid":"c3af6253-3e0c-4382-868e-8fc378982c03","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-njrat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":2181,"url":"/threat-intelligence-reports/threat-intelligence--14","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":74728,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/46309/390x292/1024_1557338603-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/e78d375f-f32b-4800-9a02-f03434c4f8c7/1024_1557338603-1.png","imageId":46309,"slug":"threat-intelligence--11","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/46309/390x292/1024_1557338603-1.png","title":"AveMaria Infostealer Uses VBA-Stomping to Obfuscate its Macros Report - 20190501","description":"From 22 to 24 April, we observed a malicious email campaign delivering the AveMaria infostealer. On 22 April, a post on security blog myonlinesecurity.co.uk described the delivery mechanism as a difficult-to-analyze Microsoft Word document.1 It used VBA-stomping, a relatively new style of macro obfuscation.2 Using the information from the blog post, we were able to discover two additional, related files to those mentioned in the blog post. ","seoConfigJson":"","rating":null,"contentUuid":"db8fc4db-5ee4-49d1-ba43-9a356b1d28fc","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-avemaria-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1473,"url":"/threat-intelligence-reports/threat-intelligence--11","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":83210,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54059/390x292/1024_1562618377-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/e3bb77af-9a68-4364-9777-e8c6595b0d2a/1024_1562618377-1.png","imageId":54059,"slug":"threat-intelligence--29","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54059/390x292/1024_1562618377-1.png","title":"Malicious Activity Report AZORult Infostealer - 20190424","description":"AZORult is a popular information stealer (infostealer) that the cyber security community first identified in 2016.","seoConfigJson":"","rating":null,"contentUuid":"608b4670-a8b4-4377-b8a1-74b1ca0c2b75","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-malicious-activity-report-azorult-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":858,"url":"/threat-intelligence-reports/threat-intelligence--29","topics":["Cybersecurity"],"personas":[],"industries":[],"businessUnits":["Security","Cloud","Cross Portfolio"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":74730,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/46311/390x292/1024_1557338836-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/299fb734-f362-49ed-adfe-1d22f9e79e29/1024_1557338836-1.png","imageId":46311,"slug":"threat-intelligence--12","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/46311/390x292/1024_1557338836-1.png","title":"DanaBot Banking Trojan Report - 20190423","description":"On 19 April, security researcher Brad Duncan reported a malicious spam campaign that used compressed Windows link files (LNK) to deliver DanaBot malware.1 DanaBot is a relatively advanced banking trojan with a modular design that allows for multiple vectors of attack. Read more.","seoConfigJson":"","rating":0,"contentUuid":"9fae4531-f58c-4fa9-b499-951ee0d5c235","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-danabot-banking-trojan.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1100,"url":"/threat-intelligence-reports/threat-intelligence--12","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":72222,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/44152/390x292/1024_1555622310-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/bd29c2bf-d470-4e0a-900e-d28cc6e47f93/1024_1555622310-1.png","imageId":44152,"slug":"threat-intelligence--10","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/44152/390x292/1024_1555622310-1.png","title":"TajMahal Advanced Persistent Threat Report - 20190417","description":"The researchers report that TajMahal has one of the highest numbers of plug-ins they have seen in an APT toolset. They identified up to 80 modules in Yokohama’s encrypted virtual file system (VFS). Read More.","seoConfigJson":"","rating":null,"contentUuid":"80ad5f69-68c8-4050-b592-e69c8b50cc65","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-tajmajal-advanced-persistent-threat.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":885,"url":"/threat-intelligence-reports/threat-intelligence--10","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":72221,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/44151/390x292/1024_1555621812-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/250ac59c-2187-4a0b-a524-3de011c03814/1024_1555621812-1.png","imageId":44151,"slug":"threat-intelligence--9","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/44151/390x292/1024_1555621812-1.png","title":"New Elknot Campaign Targets Linux Os Report - 20190409","description":"The binaries contained the Elknot trojan\n(aka ChickDDoS or Mayday), which can force an infected system\nto participate in distributed denial-of-service (DDoS) attacks. Read More.","seoConfigJson":"","rating":null,"contentUuid":"8c0e835c-79af-414d-a68e-8858355a6370","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-new-elknot-campaign-targets-linux-os.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":913,"url":"/threat-intelligence-reports/threat-intelligence--9","topics":[],"personas":[],"industries":[],"businessUnits":["Security"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":83200,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54051/390x292/1024_1562613661-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/bad832bd-d287-40f6-ba58-013d129f1a83/1024_1562613661-1.png","imageId":54051,"slug":"threat-intelligence--26","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54051/390x292/1024_1562613661-1.png","title":"Geo Restricted Ursnif Spam - 20190323","description":"Read how between 21 and 22 March, Infoblox observed a malicious email campaign distributing the Ursnif banking trojan.","seoConfigJson":"","rating":null,"contentUuid":"ec756dcb-8f40-4434-a4e2-34848e000ed9","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-geo-restricted-ursnif-spam.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":672,"url":"/threat-intelligence-reports/threat-intelligence--26","topics":[],"personas":[],"industries":[],"businessUnits":["Security","NCCM"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":83188,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54034/390x292/1024_1562609794-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/47c71dd4-7e18-429a-9cfa-d70880e9ae7c/1024_1562609794-1.png","imageId":54034,"slug":"threat-intelligence--23","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54034/390x292/1024_1562609794-1.png","title":"Brushaloader Malware - 20190305","description":"Read how security researchers on Twitter reported several domains affiliated with a malware loader called Brushaloader.","seoConfigJson":"","rating":null,"contentUuid":"38a846fa-c5a6-435f-8002-3a5f0415d403","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-brushaloader-malware.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":720,"url":"/threat-intelligence-reports/threat-intelligence--23","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cloud"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":83199,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54050/390x292/1024_1562613422-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/71de0583-1abc-454b-a0da-ebb3279b8f6e/1024_1562613422-1.png","imageId":54050,"slug":"threat-intelligence--25","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54050/390x292/1024_1562613422-1.png","title":"Hawkeye Keylogger Steals and Exfiltrates Victim Information - 20190226","description":"Read how a campaign delivering Hawkeye Keylogger malware via malicious spam email (malspam). ","seoConfigJson":"","rating":null,"contentUuid":"07e1eb97-12b8-4bd7-8a9d-d0a223c13951","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-hawkeye-keylogger.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":635,"url":"/threat-intelligence-reports/threat-intelligence--25","topics":[],"personas":[],"industries":[],"businessUnits":["Security","NCCM"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":83201,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54052/390x292/1024_1562614055-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/202f389e-c650-4166-b4bd-d9a757abd4a7/1024_1562614055-1.png","imageId":54052,"slug":"threat-intelligence--27","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54052/390x292/1024_1562614055-1.png","title":"Similar RTF Files Download Lokibot Or Formbook - 20190220","description":"On 14 February, Infoblox observed two malicious email campaigns, one delivering Formbook, the other delivering Lokibot. These campaigns were notable because they both used attachments that were functionally the same between campaigns.","seoConfigJson":"","rating":null,"contentUuid":"c153e3af-f4ea-426e-aa49-6623d06c0728","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-similar-rtf-files-download-lokibot-or-formbook.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":561,"url":"/threat-intelligence-reports/threat-intelligence--27","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":83186,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54053/390x292/1024_1562614723-01.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/cfd88ad4-3c12-4c0f-9078-fa101f72d69f/1024_1562614723-01.png","imageId":54053,"slug":"threat-intelligence--22","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54053/390x292/1024_1562614723-01.png","title":"Malicious Activity Report: Elements of Lokibot Infostealer - 20190131","description":"Read more about the Lokibot threat characteristics","seoConfigJson":"","rating":null,"contentUuid":"22347d70-84e1-4aa3-8c34-9a0fb0a6243f","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-elements-of-lokibot-infostealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1324,"url":"/threat-intelligence-reports/threat-intelligence--22","topics":["Cybersecurity","Network Security"],"personas":[],"industries":[],"businessUnits":["Security","Core DDI"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":64832,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37194/390x292/1024_1550860282-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/03d64e20-b236-4c53-9ba2-68136636b0ab/1024_1550860282-1.png","imageId":37194,"slug":"threat-intelligence--2","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37194/390x292/1024_1550860282-1.png","title":"Cryptomix Ransomware Cyber Report - 20190125","description":"Earlier this month, the cyber intelligence community detected a new CryptoMix ransomware campaign that exploited real stories of children diagnosed with cancer. The campaign pretended to represent a real children’s charity and alleged that the victim’s ransom payment was for a good cause. Read More about the report.","seoConfigJson":"","rating":0,"contentUuid":"ea8ec5c5-4434-4257-b1f2-b0ea99b596cc","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-cryptomix-ransomware-cyber-report.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1342,"url":"/threat-intelligence-reports/threat-intelligence--2","topics":["Security"],"personas":[],"industries":[],"businessUnits":["Security","Cloud"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":64857,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37212/390x292/1024_1550861545-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/e7fd8623-19e6-4be4-8fd5-4d838ec15a7f/1024_1550861545-1.png","imageId":37212,"slug":"threat-intelligence--7","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37212/390x292/1024_1550861545-1.png","title":"Survey Of 2018 Ransomware Cyber Report - 20190123","description":"Read the paper to learn more about several of the most prominent ransomware campaigns from 2018.","seoConfigJson":"","rating":null,"contentUuid":"6636d06a-af6d-403f-8ec9-9eea966e9ec8","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-survey-of-2018-ransomware-cyber-report.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1190,"url":"/threat-intelligence-reports/threat-intelligence--7","topics":["Security"],"personas":[],"industries":[],"businessUnits":["Security","Cloud","Cross Portfolio"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":64843,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37202/390x292/1024_1550860823-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/b6177720-3646-4f1f-a3fb-fc2c07fd9f8c/1024_1550860823-1.png","imageId":37202,"slug":"threat-intelligence--3","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37202/390x292/1024_1550860823-1.png","title":"Ryuk Ransomware Cyber Report - 20190110","description":"Ryuk encrypts files and attempts to encrypt network drives. Ryuk then runs a Windows batch script to delete its encryption key, shadow copies of files, and any available backup files. Read More.","seoConfigJson":"","rating":null,"contentUuid":"893a664c-ece8-42c1-8614-92df0d328926","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-ryuk-ransomeware-cyber-report.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":1067,"url":"/threat-intelligence-reports/threat-intelligence--3","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cloud"],"funnelStages":["Top of Funnel"],"assetTypes":[]},{"id":83198,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54049/390x292/1024_1562613150-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/3ceda019-a141-491a-8f94-1c913880d249/1024_1562613150-1.png","imageId":54049,"slug":"threat-intelligence--24","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/54049/390x292/1024_1562613150-1.png","title":"Formbook Information Stealer - 20190108","description":"On 2 January, Infoblox observed an email campaign that used malicious ZIP attachments to distribute Formbook malware. ","seoConfigJson":"","rating":null,"contentUuid":"b96aaf7c-6d4d-47af-b429-85d2e2fbcdc9","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-formbook-information-stealer.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":713,"url":"/threat-intelligence-reports/threat-intelligence--24","topics":["Cybersecurity"],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cloud"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":64849,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37205/390x292/1024_1550861077-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/be137c52-cbef-414e-bc97-132d01479fd8/1024_1550861077-1.png","imageId":37205,"slug":"threat-intelligence--4","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37205/390x292/1024_1550861077-1.png","title":"Keypass Ransomware Cyber Report - 20180817","description":"Kaspersky and others report that they have seen the malware spread through fake installers, a previously seen though less common attack vector. Read more about the ransomware.","seoConfigJson":"","rating":null,"contentUuid":"b4cfb073-2458-42d9-a216-a58fbbb1eca1","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-keypass-ransomware-cyber-report.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":909,"url":"/threat-intelligence-reports/threat-intelligence--4","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cloud","Cross Portfolio"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":64853,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37206/390x292/1024_1550861233-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/5f7fbdc9-1f47-4c99-9945-51754b608118/1024_1550861233-1.png","imageId":37206,"slug":"threat-intelligence--5","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37206/390x292/1024_1550861233-1.png","title":"Hermes Ransomware Cyber Report - 20180727","description":"Read about Hermes ransomware that was first detected in February 2017 and how Infoblox observed an influx of spam emails delivering malicious Microsoft Word documents that downloaded Hermes 2.1 via the AZORult trojan.","seoConfigJson":"","rating":null,"contentUuid":"d4ba32d5-0eab-43ef-a198-0821c5b207f4","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-hermes-ransomware-cyber-report.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":944,"url":"/threat-intelligence-reports/threat-intelligence--5","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Cloud","Cross Portfolio"],"funnelStages":["Middle of Funnel"],"assetTypes":[]},{"id":64856,"experienceId":19647,"isExcluded":false,"targetDelay":0,"titleOverride":null,"nextPromoterTitle":"Next","descriptionOverride":null,"nextSignpostTitle":"Next","previousSignpostTitle":"Previous","nextSignpostBehavior":null,"videoStartTime":null,"videoRelatedEnabled":null,"openExternallyEnabled":false,"videoAutoplayDisabled":null,"customSlug":null,"thumbnailOverride":null,"imageOverrideUrl":null,"imageUrl":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37209/390x292/1024_1550861395-1.png","imageUrlOriginal":"https://app.cdn.lookbookhq.com/production/content-previews/da887832-1930-4b50-ba63-9cef7bd4726a/1024_1550861395-1.png","imageId":37209,"slug":"threat-intelligence--6","thumbnail":"https://app.cdn.lookbookhq.com/lbhq-development/10336/content_thumbnails/37209/390x292/1024_1550861395-1.png","title":"Gandcrab Ransomware Cyber Report - 20180531","description":"Learn how GandCrab ransomware believed to target Scandinavian and English-speaking countries via exploit kits and malicious spam email. Messages sent to victims tend to be vague and the victims are prompted to open an attached file.","seoConfigJson":"","rating":null,"contentUuid":"e678ad60-e848-4558-877b-578fab509848","mediaType":"pdf","sourceUrl":"https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-gandcrab-ransomware-cyber-report.pdf","enableIframeSandbox":0,"languageId":0,"contentTypeName":"Report","contentTypeId":2405,"customUrl":"threat-intelligence-reports","views":849,"url":"/threat-intelligence-reports/threat-intelligence--6","topics":[],"personas":[],"industries":[],"businessUnits":["Security","Core DDI","Cloud"],"funnelStages":["Middle of Funnel"],"assetTypes":[]}],
          recommendedContent: null,
          cookieWhitelist: ["ELOQUA","_mkto_trk","RegExp::^visitor_id[0-9]+$::pardot_visitor_id","hubspotutk"],
          customFonts: [],
          showCookieConsent: true,
          refreshAfterGdprAccept: true
        },
        environment: {
          clientId: "LB-F4A92B32-10336",
          appId: "d96ff491-93b4-4847-8396-1817ed54e855",
          contentId: 83186,
          contentUuid: "22347d70-84e1-4aa3-8c34-9a0fb0a6243f",
          experienceId: 19647,
          experienceType: "target",
          experienceUuid: "e1980ce0-b3fd-488c-ac50-21571b5756f7",
          landingExperienceLink: "",
          deviceType: "desktop",
          environment: "production",
          serverRenderFlow: false,
          cookieDomain: "https://infoblox.lookbookhq.com/cookie-iframe.html",
          apiHost: "https://jukebox.lookbookhq.com"
        }
      }
    </script>
    <style>
      * {
        box-sizing: border-box;
      }

      body, html {
        height: 100%;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      #lookbook-video-player { width: 100%; height: 100%; overflow: hidden; }
      #lb-app-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        -webkit-overflow-scrolling: touch;
        background: #fff;
        overflow: auto;
      }
      .standard { height: 100%; width: 100%; margin: 0; }
      .overlay {
        height: 80%;
        width: 80%;
        margin: auto;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      @media (max-width: 480px) {
        .overlay { height: 100%; width: 100%; }
      }


    </style>
  </head>
  <body class="standard flow-enabled loadingInProgress" style="border: 0; padding: 0; overflow: hidden;">
      <!-- Google Tag Manager (noscript) -->

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-F7RMF"

height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

<!-- End Google Tag Manager (noscript) -->

    <div id="lb-app-container" data-source-url="https://www.infoblox.com/wp-content/uploads/threat-intelligence-report-elements-of-lokibot-infostealer.pdf">
        <!--
Copyright 2012 Mozilla Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Adobe CMap resources are covered by their own copyright but the same license:

    Copyright 1990-2015 Adobe Systems Incorporated.

See https://github.com/adobe-type-tools/cmap-resources
-->

  <link rel="stylesheet" href="https://cdn.pathfactory.com/pdfjs/2.5.207/web/viewer.css">
  <link rel="resource" type="application/l10n" href="https://cdn.pathfactory.com/pdfjs/2.5.207/web/locale/locale.properties" />
  <script src="https://cdn.pathfactory.com/pdfjs/2.5.207/build/pdf.min.js"></script>
  <script src="https://cdn.pathfactory.com/pdfjs/2.5.207/build/pdf.worker.min.js"></script>
  <script>
/*
This file was taken from https://mozilla.github.io/pdf.js/web/viewer.js

When upgrading to a new version, the following must be noted:
- Keep the section before the licence info block starts
- Remove setting document.title = title from setTitle function
- Make sure wherever TrackEvent() is called is reproduced in the updated version
- Update the following values in the defaultOptions object
  - Set the value for defaultUrl, pointing to the pdf endpoint in Baker
  - Set the cMapUrl value to the latest version cdn url
  - Set the workerSrc value to the latest version cdn url
- Set Client-Id in the httpHeaders in the async open funtion
*/

if (false) {
  window.location.hash="#page=1";
}

var CLICK_DOWNLOAD_PDF = "click_download_pdf";

var TrackEvent = function(eventName) {
  if (window.lbhq) {
    window.lbhq("sendEvent", { eventName: eventName });
  } else {
    window.setTimeout(function() {
      window.lbhq && window.lbhq("sendEvent", { eventName: eventName });
    }, 5000);
  }
};

/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2020 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


;
let pdfjsWebApp, pdfjsWebAppOptions;
{
  pdfjsWebApp = __webpack_require__(1);
  pdfjsWebAppOptions = __webpack_require__(3);
}
;
{
  __webpack_require__(33);
}
;
{
  __webpack_require__(38);
}

function getViewerConfiguration() {
  return {
    appContainer: document.body,
    mainContainer: document.getElementById("viewerContainer"),
    viewerContainer: document.getElementById("viewer"),
    eventBus: null,
    toolbar: {
      container: document.getElementById("toolbarViewer"),
      numPages: document.getElementById("numPages"),
      pageNumber: document.getElementById("pageNumber"),
      scaleSelectContainer: document.getElementById("scaleSelectContainer"),
      scaleSelect: document.getElementById("scaleSelect"),
      customScaleOption: document.getElementById("customScaleOption"),
      previous: document.getElementById("previous"),
      next: document.getElementById("next"),
      zoomIn: document.getElementById("zoomIn"),
      zoomOut: document.getElementById("zoomOut"),
      viewFind: document.getElementById("viewFind"),
      openFile: document.getElementById("openFile"),
      print: document.getElementById("print"),
      presentationModeButton: document.getElementById("presentationMode"),
      download: document.getElementById("download"),
      viewBookmark: document.getElementById("viewBookmark")
    },
    secondaryToolbar: {
      toolbar: document.getElementById("secondaryToolbar"),
      toggleButton: document.getElementById("secondaryToolbarToggle"),
      toolbarButtonContainer: document.getElementById("secondaryToolbarButtonContainer"),
      presentationModeButton: document.getElementById("secondaryPresentationMode"),
      openFileButton: document.getElementById("secondaryOpenFile"),
      printButton: document.getElementById("secondaryPrint"),
      downloadButton: document.getElementById("secondaryDownload"),
      viewBookmarkButton: document.getElementById("secondaryViewBookmark"),
      firstPageButton: document.getElementById("firstPage"),
      lastPageButton: document.getElementById("lastPage"),
      pageRotateCwButton: document.getElementById("pageRotateCw"),
      pageRotateCcwButton: document.getElementById("pageRotateCcw"),
      cursorSelectToolButton: document.getElementById("cursorSelectTool"),
      cursorHandToolButton: document.getElementById("cursorHandTool"),
      scrollVerticalButton: document.getElementById("scrollVertical"),
      scrollHorizontalButton: document.getElementById("scrollHorizontal"),
      scrollWrappedButton: document.getElementById("scrollWrapped"),
      spreadNoneButton: document.getElementById("spreadNone"),
      spreadOddButton: document.getElementById("spreadOdd"),
      spreadEvenButton: document.getElementById("spreadEven"),
      documentPropertiesButton: document.getElementById("documentProperties")
    },
    fullscreen: {
      contextFirstPage: document.getElementById("contextFirstPage"),
      contextLastPage: document.getElementById("contextLastPage"),
      contextPageRotateCw: document.getElementById("contextPageRotateCw"),
      contextPageRotateCcw: document.getElementById("contextPageRotateCcw")
    },
    sidebar: {
      outerContainer: document.getElementById("outerContainer"),
      viewerContainer: document.getElementById("viewerContainer"),
      toggleButton: document.getElementById("sidebarToggle"),
      thumbnailButton: document.getElementById("viewThumbnail"),
      outlineButton: document.getElementById("viewOutline"),
      attachmentsButton: document.getElementById("viewAttachments"),
      thumbnailView: document.getElementById("thumbnailView"),
      outlineView: document.getElementById("outlineView"),
      attachmentsView: document.getElementById("attachmentsView")
    },
    sidebarResizer: {
      outerContainer: document.getElementById("outerContainer"),
      resizer: document.getElementById("sidebarResizer")
    },
    findBar: {
      bar: document.getElementById("findbar"),
      toggleButton: document.getElementById("viewFind"),
      findField: document.getElementById("findInput"),
      highlightAllCheckbox: document.getElementById("findHighlightAll"),
      caseSensitiveCheckbox: document.getElementById("findMatchCase"),
      entireWordCheckbox: document.getElementById("findEntireWord"),
      findMsg: document.getElementById("findMsg"),
      findResultsCount: document.getElementById("findResultsCount"),
      findPreviousButton: document.getElementById("findPrevious"),
      findNextButton: document.getElementById("findNext")
    },
    passwordOverlay: {
      overlayName: "passwordOverlay",
      container: document.getElementById("passwordOverlay"),
      label: document.getElementById("passwordText"),
      input: document.getElementById("password"),
      submitButton: document.getElementById("passwordSubmit"),
      cancelButton: document.getElementById("passwordCancel")
    },
    documentProperties: {
      overlayName: "documentPropertiesOverlay",
      container: document.getElementById("documentPropertiesOverlay"),
      closeButton: document.getElementById("documentPropertiesClose"),
      fields: {
        fileName: document.getElementById("fileNameField"),
        fileSize: document.getElementById("fileSizeField"),
        title: document.getElementById("titleField"),
        author: document.getElementById("authorField"),
        subject: document.getElementById("subjectField"),
        keywords: document.getElementById("keywordsField"),
        creationDate: document.getElementById("creationDateField"),
        modificationDate: document.getElementById("modificationDateField"),
        creator: document.getElementById("creatorField"),
        producer: document.getElementById("producerField"),
        version: document.getElementById("versionField"),
        pageCount: document.getElementById("pageCountField"),
        pageSize: document.getElementById("pageSizeField"),
        linearized: document.getElementById("linearizedField")
      }
    },
    errorWrapper: {
      container: document.getElementById("errorWrapper"),
      errorMessage: document.getElementById("errorMessage"),
      closeButton: document.getElementById("errorClose"),
      errorMoreInfo: document.getElementById("errorMoreInfo"),
      moreInfoButton: document.getElementById("errorShowMore"),
      lessInfoButton: document.getElementById("errorShowLess")
    },
    printContainer: document.getElementById("printContainer"),
    openFileInputName: "fileInput",
    debuggerScriptPath: "./debugger.js"
  };
}

function webViewerLoad() {
  const config = getViewerConfiguration();
  window.PDFViewerApplication = pdfjsWebApp.PDFViewerApplication;
  window.PDFViewerApplicationOptions = pdfjsWebAppOptions.AppOptions;
  const event = document.createEvent("CustomEvent");
  event.initCustomEvent("webviewerloaded", true, true, {
    source: window
  });

  document.addEventListener('webviewerloaded', function() {
      window.PDFViewerApplicationOptions.set('disablePreferences', true);
      window.PDFViewerApplicationOptions.set('externalLinkTarget', 2);
  });

  try {
    parent.document.dispatchEvent(event);
  } catch (ex) {
    console.error(`webviewerloaded: ${ex}`);
    document.dispatchEvent(event);
  }

  pdfjsWebApp.PDFViewerApplication.run(config);
}

if (document.readyState === "interactive" || document.readyState === "complete") {
  webViewerLoad();
} else {
  document.addEventListener("DOMContentLoaded", webViewerLoad, true);
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFPrintServiceFactory = exports.DefaultExternalServices = exports.PDFViewerApplication = void 0;

var _ui_utils = __webpack_require__(2);

var _app_options = __webpack_require__(3);

var _pdfjsLib = __webpack_require__(5);

var _pdf_cursor_tools = __webpack_require__(6);

var _pdf_rendering_queue = __webpack_require__(8);

var _pdf_sidebar = __webpack_require__(9);

var _overlay_manager = __webpack_require__(10);

var _password_prompt = __webpack_require__(11);

var _pdf_attachment_viewer = __webpack_require__(12);

var _pdf_document_properties = __webpack_require__(13);

var _pdf_find_bar = __webpack_require__(14);

var _pdf_find_controller = __webpack_require__(15);

var _pdf_history = __webpack_require__(17);

var _pdf_link_service = __webpack_require__(18);

var _pdf_outline_viewer = __webpack_require__(19);

var _pdf_presentation_mode = __webpack_require__(20);

var _pdf_sidebar_resizer = __webpack_require__(21);

var _pdf_thumbnail_viewer = __webpack_require__(22);

var _pdf_viewer = __webpack_require__(24);

var _secondary_toolbar = __webpack_require__(29);

var _toolbar = __webpack_require__(31);

var _view_history = __webpack_require__(32);

const DEFAULT_SCALE_DELTA = 1.1;
const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000;
const FORCE_PAGES_LOADED_TIMEOUT = 10000;
const WHEEL_ZOOM_DISABLED_TIMEOUT = 1000;
const ENABLE_PERMISSIONS_CLASS = "enablePermissions";
const ViewOnLoad = {
  UNKNOWN: -1,
  PREVIOUS: 0,
  INITIAL: 1
};

class DefaultExternalServices {
  constructor() {
    throw new Error("Cannot initialize DefaultExternalServices.");
  }

  static updateFindControlState(data) {}

  static updateFindMatchesCount(data) {}

  static initPassiveLoading(callbacks) {}

  static fallback(data, callback) {}

  static reportTelemetry(data) {}

  static createDownloadManager(options) {
    throw new Error("Not implemented: createDownloadManager");
  }

  static createPreferences() {
    throw new Error("Not implemented: createPreferences");
  }

  static createL10n(options) {
    throw new Error("Not implemented: createL10n");
  }

  static get supportsIntegratedFind() {
    return (0, _pdfjsLib.shadow)(this, "supportsIntegratedFind", false);
  }

  static get supportsDocumentFonts() {
    return (0, _pdfjsLib.shadow)(this, "supportsDocumentFonts", true);
  }

  static get supportedMouseWheelZoomModifierKeys() {
    return (0, _pdfjsLib.shadow)(this, "supportedMouseWheelZoomModifierKeys", {
      ctrlKey: true,
      metaKey: true
    });
  }

  static get isInAutomation() {
    return (0, _pdfjsLib.shadow)(this, "isInAutomation", false);
  }

}

exports.DefaultExternalServices = DefaultExternalServices;
const PDFViewerApplication = {
  initialBookmark: document.location.hash.substring(1),
  _initializedCapability: (0, _pdfjsLib.createPromiseCapability)(),
  fellback: false,
  appConfig: null,
  pdfDocument: null,
  pdfLoadingTask: null,
  printService: null,
  pdfViewer: null,
  pdfThumbnailViewer: null,
  pdfRenderingQueue: null,
  pdfPresentationMode: null,
  pdfDocumentProperties: null,
  pdfLinkService: null,
  pdfHistory: null,
  pdfSidebar: null,
  pdfSidebarResizer: null,
  pdfOutlineViewer: null,
  pdfAttachmentViewer: null,
  pdfCursorTools: null,
  store: null,
  downloadManager: null,
  overlayManager: null,
  preferences: null,
  toolbar: null,
  secondaryToolbar: null,
  eventBus: null,
  l10n: null,
  isInitialViewSet: false,
  downloadComplete: false,
  isViewerEmbedded: window.parent !== window,
  url: "",
  baseUrl: "",
  externalServices: DefaultExternalServices,
  _boundEvents: {},
  contentDispositionFilename: null,

  async initialize(appConfig) {
    this.preferences = this.externalServices.createPreferences();
    this.appConfig = appConfig;
    await this._readPreferences();
    await this._parseHashParameters();
    await this._initializeL10n();

    if (this.isViewerEmbedded && _app_options.AppOptions.get("externalLinkTarget") === _pdfjsLib.LinkTarget.NONE) {
      _app_options.AppOptions.set("externalLinkTarget", _pdfjsLib.LinkTarget.TOP);
    }

    await this._initializeViewerComponents();
    this.bindEvents();
    this.bindWindowEvents();
    const appContainer = appConfig.appContainer || document.documentElement;
    this.l10n.translate(appContainer).then(() => {
      this.eventBus.dispatch("localized", {
        source: this
      });
    });

    this._initializedCapability.resolve();
  },

  async _readPreferences() {
    if (_app_options.AppOptions.get("disablePreferences")) {
      return;
    }

    try {
      const prefs = await this.preferences.getAll();

      for (const name in prefs) {
        _app_options.AppOptions.set(name, prefs[name]);
      }
    } catch (reason) {
      console.error(`_readPreferences: "${reason.message}".`);
    }
  },

  async _parseHashParameters() {
    if (!_app_options.AppOptions.get("pdfBugEnabled")) {
      return undefined;
    }

    const hash = document.location.hash.substring(1);

    if (!hash) {
      return undefined;
    }

    const hashParams = (0, _ui_utils.parseQueryString)(hash),
          waitOn = [];

    if ("disableworker" in hashParams && hashParams.disableworker === "true") {
      waitOn.push(loadFakeWorker());
    }

    if ("disablerange" in hashParams) {
      _app_options.AppOptions.set("disableRange", hashParams.disablerange === "true");
    }

    if ("disablestream" in hashParams) {
      _app_options.AppOptions.set("disableStream", hashParams.disablestream === "true");
    }

    if ("disableautofetch" in hashParams) {
      _app_options.AppOptions.set("disableAutoFetch", hashParams.disableautofetch === "true");
    }

    if ("disablefontface" in hashParams) {
      _app_options.AppOptions.set("disableFontFace", hashParams.disablefontface === "true");
    }

    if ("disablehistory" in hashParams) {
      _app_options.AppOptions.set("disableHistory", hashParams.disablehistory === "true");
    }

    if ("webgl" in hashParams) {
      _app_options.AppOptions.set("enableWebGL", hashParams.webgl === "true");
    }

    if ("verbosity" in hashParams) {
      _app_options.AppOptions.set("verbosity", hashParams.verbosity | 0);
    }

    if ("textlayer" in hashParams) {
      switch (hashParams.textlayer) {
        case "off":
          _app_options.AppOptions.set("textLayerMode", _ui_utils.TextLayerMode.DISABLE);

          break;

        case "visible":
        case "shadow":
        case "hover":
          const viewer = this.appConfig.viewerContainer;
          viewer.classList.add("textLayer-" + hashParams.textlayer);
          break;
      }
    }

    if ("pdfbug" in hashParams) {
      _app_options.AppOptions.set("pdfBug", true);

      _app_options.AppOptions.set("fontExtraProperties", true);

      const enabled = hashParams.pdfbug.split(",");
      waitOn.push(loadAndEnablePDFBug(enabled));
    }

    if ("locale" in hashParams) {
      _app_options.AppOptions.set("locale", hashParams.locale);
    }

    return Promise.all(waitOn).catch(reason => {
      console.error(`_parseHashParameters: "${reason.message}".`);
    });
  },

  async _initializeL10n() {
    this.l10n = this.externalServices.createL10n({
      locale: _app_options.AppOptions.get("locale")
    });
    const dir = await this.l10n.getDirection();
    document.getElementsByTagName("html")[0].dir = dir;
  },

  async _initializeViewerComponents() {
    const appConfig = this.appConfig;
    const eventBus = appConfig.eventBus || new _ui_utils.EventBus({
      isInAutomation: this.externalServices.isInAutomation
    });
    this.eventBus = eventBus;
    this.overlayManager = new _overlay_manager.OverlayManager();
    const pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
    pdfRenderingQueue.onIdle = this.cleanup.bind(this);
    this.pdfRenderingQueue = pdfRenderingQueue;
    const pdfLinkService = new _pdf_link_service.PDFLinkService({
      eventBus,
      externalLinkTarget: _app_options.AppOptions.get("externalLinkTarget"),
      externalLinkRel: _app_options.AppOptions.get("externalLinkRel"),
      ignoreDestinationZoom: _app_options.AppOptions.get("ignoreDestinationZoom")
    });
    this.pdfLinkService = pdfLinkService;
    const downloadManager = this.externalServices.createDownloadManager({
      disableCreateObjectURL: _app_options.AppOptions.get("disableCreateObjectURL")
    });
    this.downloadManager = downloadManager;
    const findController = new _pdf_find_controller.PDFFindController({
      linkService: pdfLinkService,
      eventBus
    });
    this.findController = findController;
    const container = appConfig.mainContainer;
    const viewer = appConfig.viewerContainer;
    this.pdfViewer = new _pdf_viewer.PDFViewer({
      container,
      viewer,
      eventBus,
      renderingQueue: pdfRenderingQueue,
      linkService: pdfLinkService,
      downloadManager,
      findController,
      renderer: _app_options.AppOptions.get("renderer"),
      enableWebGL: _app_options.AppOptions.get("enableWebGL"),
      l10n: this.l10n,
      textLayerMode: _app_options.AppOptions.get("textLayerMode"),
      imageResourcesPath: _app_options.AppOptions.get("imageResourcesPath"),
      renderInteractiveForms: _app_options.AppOptions.get("renderInteractiveForms"),
      enablePrintAutoRotate: _app_options.AppOptions.get("enablePrintAutoRotate"),
      useOnlyCssZoom: _app_options.AppOptions.get("useOnlyCssZoom"),
      maxCanvasPixels: _app_options.AppOptions.get("maxCanvasPixels")
    });
    pdfRenderingQueue.setViewer(this.pdfViewer);
    pdfLinkService.setViewer(this.pdfViewer);
    this.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({
      container: appConfig.sidebar.thumbnailView,
      renderingQueue: pdfRenderingQueue,
      linkService: pdfLinkService,
      l10n: this.l10n
    });
    pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);
    this.pdfHistory = new _pdf_history.PDFHistory({
      linkService: pdfLinkService,
      eventBus
    });
    pdfLinkService.setHistory(this.pdfHistory);

    if (!this.supportsIntegratedFind) {
      this.findBar = new _pdf_find_bar.PDFFindBar(appConfig.findBar, eventBus, this.l10n);
    }

    this.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);
    this.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({
      container,
      eventBus,
      cursorToolOnLoad: _app_options.AppOptions.get("cursorToolOnLoad")
    });
    this.toolbar = new _toolbar.Toolbar(appConfig.toolbar, eventBus, this.l10n);
    this.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

    if (this.supportsFullscreen) {
      this.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({
        container,
        pdfViewer: this.pdfViewer,
        eventBus,
        contextMenuItems: appConfig.fullscreen
      });
    }

    this.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n);
    this.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({
      container: appConfig.sidebar.outlineView,
      eventBus,
      linkService: pdfLinkService
    });
    this.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({
      container: appConfig.sidebar.attachmentsView,
      eventBus,
      downloadManager
    });
    this.pdfSidebar = new _pdf_sidebar.PDFSidebar({
      elements: appConfig.sidebar,
      pdfViewer: this.pdfViewer,
      pdfThumbnailViewer: this.pdfThumbnailViewer,
      eventBus,
      l10n: this.l10n
    });
    this.pdfSidebar.onToggled = this.forceRendering.bind(this);
    this.pdfSidebarResizer = new _pdf_sidebar_resizer.PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);
  },

  run(config) {
    this.initialize(config).then(webViewerInitialized);
  },

  get initialized() {
    return this._initializedCapability.settled;
  },

  get initializedPromise() {
    return this._initializedCapability.promise;
  },

  zoomIn(ticks) {
    if (this.pdfViewer.isInPresentationMode) {
      return;
    }

    let newScale = this.pdfViewer.currentScale;

    do {
      newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);
      newScale = Math.ceil(newScale * 10) / 10;
      newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
    } while (--ticks > 0 && newScale < _ui_utils.MAX_SCALE);

    this.pdfViewer.currentScaleValue = newScale;
  },

  zoomOut(ticks) {
    if (this.pdfViewer.isInPresentationMode) {
      return;
    }

    let newScale = this.pdfViewer.currentScale;

    do {
      newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);
      newScale = Math.floor(newScale * 10) / 10;
      newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
    } while (--ticks > 0 && newScale > _ui_utils.MIN_SCALE);

    this.pdfViewer.currentScaleValue = newScale;
  },

  zoomReset() {
    if (this.pdfViewer.isInPresentationMode) {
      return;
    }

    this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
  },

  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  },

  get page() {
    return this.pdfViewer.currentPageNumber;
  },

  set page(val) {
    this.pdfViewer.currentPageNumber = val;
  },

  get printing() {
    return !!this.printService;
  },

  get supportsPrinting() {
    return PDFPrintServiceFactory.instance.supportsPrinting;
  },

  get supportsFullscreen() {
    let support;
    const doc = document.documentElement;
    support = !!(doc.requestFullscreen || doc.mozRequestFullScreen || doc.webkitRequestFullScreen || doc.msRequestFullscreen);

    if (document.fullscreenEnabled === false || document.mozFullScreenEnabled === false || document.webkitFullscreenEnabled === false || document.msFullscreenEnabled === false) {
      support = false;
    }

    return (0, _pdfjsLib.shadow)(this, "supportsFullscreen", support);
  },

  get supportsIntegratedFind() {
    return this.externalServices.supportsIntegratedFind;
  },

  get supportsDocumentFonts() {
    return this.externalServices.supportsDocumentFonts;
  },

  get loadingBar() {
    const bar = new _ui_utils.ProgressBar("#loadingBar");
    return (0, _pdfjsLib.shadow)(this, "loadingBar", bar);
  },

  get supportedMouseWheelZoomModifierKeys() {
    return this.externalServices.supportedMouseWheelZoomModifierKeys;
  },

  initPassiveLoading() {
    throw new Error("Not implemented: initPassiveLoading");
  },

  setTitleUsingUrl(url = "") {
    this.url = url;
    this.baseUrl = url.split("#")[0];
    let title = (0, _ui_utils.getPDFFileNameFromURL)(url, "");

    if (!title) {
      try {
        title = decodeURIComponent((0, _pdfjsLib.getFilenameFromUrl)(url)) || url;
      } catch (ex) {
        title = url;
      }
    }

    this.setTitle(title);
  },

  setTitle(title) {
    if (this.isViewerEmbedded) {
      return;
    }
  },

  async close() {
    const errorWrapper = this.appConfig.errorWrapper.container;
    errorWrapper.setAttribute("hidden", "true");

    if (!this.pdfLoadingTask) {
      return undefined;
    }

    const promise = this.pdfLoadingTask.destroy();
    this.pdfLoadingTask = null;

    if (this.pdfDocument) {
      this.pdfDocument = null;
      this.pdfThumbnailViewer.setDocument(null);
      this.pdfViewer.setDocument(null);
      this.pdfLinkService.setDocument(null);
      this.pdfDocumentProperties.setDocument(null);
    }

    webViewerResetPermissions();
    this.store = null;
    this.isInitialViewSet = false;
    this.downloadComplete = false;
    this.url = "";
    this.baseUrl = "";
    this.contentDispositionFilename = null;
    this.pdfSidebar.reset();
    this.pdfOutlineViewer.reset();
    this.pdfAttachmentViewer.reset();

    if (this.pdfHistory) {
      this.pdfHistory.reset();
    }

    if (this.findBar) {
      this.findBar.reset();
    }

    this.toolbar.reset();
    this.secondaryToolbar.reset();

    if (typeof PDFBug !== "undefined") {
      PDFBug.cleanup();
    }

    return promise;
  },

  async open(file, args) {
    if (this.pdfLoadingTask) {
      await this.close();
    }

    const workerParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.WORKER);

    for (const key in workerParameters) {
      _pdfjsLib.GlobalWorkerOptions[key] = workerParameters[key];
    }

    const parameters = Object.create(null);

    if (typeof file === "string") {
      this.setTitleUsingUrl(file);
      parameters.url = file;
    } else if (file && "byteLength" in file) {
      parameters.data = file;
    } else if (file.url && file.originalUrl) {
      this.setTitleUsingUrl(file.originalUrl);
      parameters.url = file.url;
    }

    const apiParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.API);

    for (const key in apiParameters) {
      let value = apiParameters[key];

      if (key === "docBaseUrl" && !value) {}

      parameters[key] = value;
    }

    if (args) {
      for (const key in args) {
        const value = args[key];

        if (key === "length") {
          this.pdfDocumentProperties.setFileSize(value);
        }

        parameters[key] = value;
      }
    }

    parameters['httpHeaders'] = {
      'Client-Id': "LB-F4A92B32-10336"
    };

    const loadingTask = (0, _pdfjsLib.getDocument)(parameters);
    this.pdfLoadingTask = loadingTask;

    loadingTask.onPassword = (updateCallback, reason) => {
      this.pdfLinkService.externalLinkEnabled = false;
      this.passwordPrompt.setUpdateCallback(updateCallback, reason);
      this.passwordPrompt.open();
    };

    loadingTask.onProgress = ({
      loaded,
      total
    }) => {
      this.progress(loaded / total);
    };

    loadingTask.onUnsupportedFeature = this.fallback.bind(this);
    return loadingTask.promise.then(pdfDocument => {
      this.load(pdfDocument);
    }, exception => {
      if (loadingTask !== this.pdfLoadingTask) {
        return undefined;
      }

      const message = exception && exception.message;
      let loadingErrorMessage;

      if (exception instanceof _pdfjsLib.InvalidPDFException) {
        loadingErrorMessage = this.l10n.get("invalid_file_error", null, "Invalid or corrupted PDF file.");
      } else if (exception instanceof _pdfjsLib.MissingPDFException) {
        loadingErrorMessage = this.l10n.get("missing_file_error", null, "Missing PDF file.");
      } else if (exception instanceof _pdfjsLib.UnexpectedResponseException) {
        loadingErrorMessage = this.l10n.get("unexpected_response_error", null, "Unexpected server response.");
      } else {
        loadingErrorMessage = this.l10n.get("loading_error", null, "An error occurred while loading the PDF.");
      }

      return loadingErrorMessage.then(msg => {
        this.error(msg, {
          message
        });
        throw exception;
      });
    });
  },

  download() {
    function downloadByUrl() {
      downloadManager.downloadUrl(url, filename);
    }

    const url = this.baseUrl;
    const filename = this.contentDispositionFilename || (0, _ui_utils.getPDFFileNameFromURL)(this.url);
    const downloadManager = this.downloadManager;

    downloadManager.onerror = err => {
      this.error(`PDF failed to download: ${err}`);
    };

    if (!this.pdfDocument || !this.downloadComplete) {
      downloadByUrl();
      return;
    }

    this.pdfDocument.getData().then(function (data) {
      const blob = new Blob([data], {
        type: "application/pdf"
      });
      downloadManager.download(blob, url, filename);
    }).catch(downloadByUrl);
  },

  fallback(featureId) {
    if (this.fellback) {
      return;
    }

    this.fellback = true;
    this.externalServices.fallback({
      featureId,
      url: this.baseUrl
    }, function response(download) {
      if (!download) {
        return;
      }

      PDFViewerApplication.download();
    });
  },

  error(message, moreInfo) {
    const moreInfoText = [this.l10n.get("error_version_info", {
      version: _pdfjsLib.version || "?",
      build: _pdfjsLib.build || "?"
    }, "PDF.js v{{version}} (build: {{build}})")];

    if (moreInfo) {
      moreInfoText.push(this.l10n.get("error_message", {
        message: moreInfo.message
      }, "Message: {{message}}"));

      if (moreInfo.stack) {
        moreInfoText.push(this.l10n.get("error_stack", {
          stack: moreInfo.stack
        }, "Stack: {{stack}}"));
      } else {
        if (moreInfo.filename) {
          moreInfoText.push(this.l10n.get("error_file", {
            file: moreInfo.filename
          }, "File: {{file}}"));
        }

        if (moreInfo.lineNumber) {
          moreInfoText.push(this.l10n.get("error_line", {
            line: moreInfo.lineNumber
          }, "Line: {{line}}"));
        }
      }
    }

    const errorWrapperConfig = this.appConfig.errorWrapper;
    const errorWrapper = errorWrapperConfig.container;
    errorWrapper.removeAttribute("hidden");
    const errorMessage = errorWrapperConfig.errorMessage;
    errorMessage.textContent = message;
    const closeButton = errorWrapperConfig.closeButton;

    closeButton.onclick = function () {
      errorWrapper.setAttribute("hidden", "true");
    };

    const errorMoreInfo = errorWrapperConfig.errorMoreInfo;
    const moreInfoButton = errorWrapperConfig.moreInfoButton;
    const lessInfoButton = errorWrapperConfig.lessInfoButton;

    moreInfoButton.onclick = function () {
      errorMoreInfo.removeAttribute("hidden");
      moreInfoButton.setAttribute("hidden", "true");
      lessInfoButton.removeAttribute("hidden");
      errorMoreInfo.style.height = errorMoreInfo.scrollHeight + "px";
    };

    lessInfoButton.onclick = function () {
      errorMoreInfo.setAttribute("hidden", "true");
      moreInfoButton.removeAttribute("hidden");
      lessInfoButton.setAttribute("hidden", "true");
    };

    moreInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
    lessInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
    closeButton.oncontextmenu = _ui_utils.noContextMenuHandler;
    moreInfoButton.removeAttribute("hidden");
    lessInfoButton.setAttribute("hidden", "true");
    Promise.all(moreInfoText).then(parts => {
      errorMoreInfo.value = parts.join("\n");
    });
  },

  progress(level) {
    if (this.downloadComplete) {
      return;
    }

    const percent = Math.round(level * 100);

    if (percent > this.loadingBar.percent || isNaN(percent)) {
      this.loadingBar.percent = percent;
      const disableAutoFetch = this.pdfDocument ? this.pdfDocument.loadingParams.disableAutoFetch : _app_options.AppOptions.get("disableAutoFetch");

      if (disableAutoFetch && percent) {
        if (this.disableAutoFetchLoadingBarTimeout) {
          clearTimeout(this.disableAutoFetchLoadingBarTimeout);
          this.disableAutoFetchLoadingBarTimeout = null;
        }

        this.loadingBar.show();
        this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {
          this.loadingBar.hide();
          this.disableAutoFetchLoadingBarTimeout = null;
        }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);
      }
    }
  },

  load(pdfDocument) {
    this.pdfDocument = pdfDocument;
    pdfDocument.getDownloadInfo().then(() => {
      this.downloadComplete = true;
      this.loadingBar.hide();
      firstPagePromise.then(() => {
        this.eventBus.dispatch("documentloaded", {
          source: this
        });
      });
    });
    const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {});
    const pageModePromise = pdfDocument.getPageMode().catch(function () {});
    const openActionPromise = pdfDocument.getOpenAction().catch(function () {});
    this.toolbar.setPagesCount(pdfDocument.numPages, false);
    this.secondaryToolbar.setPagesCount(pdfDocument.numPages);
    let baseDocumentUrl;
    baseDocumentUrl = null;
    this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);
    this.pdfDocumentProperties.setDocument(pdfDocument, this.url);
    const pdfViewer = this.pdfViewer;
    pdfViewer.setDocument(pdfDocument);
    const {
      firstPagePromise,
      onePageRendered,
      pagesPromise
    } = pdfViewer;
    const pdfThumbnailViewer = this.pdfThumbnailViewer;
    pdfThumbnailViewer.setDocument(pdfDocument);
    const storedPromise = (this.store = new _view_history.ViewHistory(pdfDocument.fingerprint)).getMultiple({
      page: null,
      zoom: _ui_utils.DEFAULT_SCALE_VALUE,
      scrollLeft: "0",
      scrollTop: "0",
      rotation: null,
      sidebarView: _pdf_sidebar.SidebarView.UNKNOWN,
      scrollMode: _ui_utils.ScrollMode.UNKNOWN,
      spreadMode: _ui_utils.SpreadMode.UNKNOWN
    }).catch(() => {
      return Object.create(null);
    });
    firstPagePromise.then(pdfPage => {
      this.loadingBar.setWidth(this.appConfig.viewerContainer);
      Promise.all([_ui_utils.animationStarted, storedPromise, pageLayoutPromise, pageModePromise, openActionPromise]).then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) => {
        const viewOnLoad = _app_options.AppOptions.get("viewOnLoad");

        this._initializePdfHistory({
          fingerprint: pdfDocument.fingerprint,
          viewOnLoad,
          initialDest: openAction && openAction.dest
        });

        const initialBookmark = this.initialBookmark;

        const zoom = _app_options.AppOptions.get("defaultZoomValue");

        let hash = zoom ? `zoom=${zoom}` : null;
        let rotation = null;

        let sidebarView = _app_options.AppOptions.get("sidebarViewOnLoad");

        let scrollMode = _app_options.AppOptions.get("scrollModeOnLoad");

        let spreadMode = _app_options.AppOptions.get("spreadModeOnLoad");

        if (stored.page && viewOnLoad !== ViewOnLoad.INITIAL) {
          hash = `page=${stored.page}&zoom=${zoom || stored.zoom},` + `${stored.scrollLeft},${stored.scrollTop}`;
          rotation = parseInt(stored.rotation, 10);

          if (sidebarView === _pdf_sidebar.SidebarView.UNKNOWN) {
            sidebarView = stored.sidebarView | 0;
          }

          if (scrollMode === _ui_utils.ScrollMode.UNKNOWN) {
            scrollMode = stored.scrollMode | 0;
          }

          if (spreadMode === _ui_utils.SpreadMode.UNKNOWN) {
            spreadMode = stored.spreadMode | 0;
          }
        }

        if (pageMode && sidebarView === _pdf_sidebar.SidebarView.UNKNOWN) {
          sidebarView = apiPageModeToSidebarView(pageMode);
        }

        if (pageLayout && spreadMode === _ui_utils.SpreadMode.UNKNOWN) {
          spreadMode = apiPageLayoutToSpreadMode(pageLayout);
        }

        this.setInitialView(hash, {
          rotation,
          sidebarView,
          scrollMode,
          spreadMode
        });
        this.eventBus.dispatch("documentinit", {
          source: this
        });

        if (!this.isViewerEmbedded) {
          pdfViewer.focus();
        }

        this._initializePermissions(pdfDocument);

        await Promise.race([pagesPromise, new Promise(resolve => {
          setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);
        })]);

        if (!initialBookmark && !hash) {
          return;
        }

        if (pdfViewer.hasEqualPageSizes) {
          return;
        }

        this.initialBookmark = initialBookmark;
        pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;
        this.setInitialView(hash);
      }).catch(() => {
        this.setInitialView();
      }).then(function () {
        pdfViewer.update();
      });
    });
    pagesPromise.then(() => {
      this._initializeAutoPrint(pdfDocument, openActionPromise);
    });
    onePageRendered.then(() => {
      pdfDocument.getOutline().then(outline => {
        this.pdfOutlineViewer.render({
          outline
        });
      });
      pdfDocument.getAttachments().then(attachments => {
        this.pdfAttachmentViewer.render({
          attachments
        });
      });
    });

    this._initializePageLabels(pdfDocument);

    this._initializeMetadata(pdfDocument);
  },

  async _initializeAutoPrint(pdfDocument, openActionPromise) {
    const [openAction, javaScript] = await Promise.all([openActionPromise, pdfDocument.getJavaScript()]);

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    let triggerAutoPrint = false;

    if (openAction && openAction.action === "Print") {
      triggerAutoPrint = true;
    }

    if (javaScript) {
      javaScript.some(js => {
        if (!js) {
          return false;
        }

        console.warn("Warning: JavaScript is not supported");
        this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.javaScript);
        return true;
      });

      if (!triggerAutoPrint) {
        for (const js of javaScript) {
          if (js && _ui_utils.AutoPrintRegExp.test(js)) {
            triggerAutoPrint = true;
            break;
          }
        }
      }
    }

    if (!this.supportsPrinting) {
      return;
    }

    if (triggerAutoPrint) {
      setTimeout(function () {
        window.print();
      });
    }
  },

  async _initializeMetadata(pdfDocument) {
    const {
      info,
      metadata,
      contentDispositionFilename
    } = await pdfDocument.getMetadata();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    this.documentInfo = info;
    this.metadata = metadata;
    this.contentDispositionFilename = contentDispositionFilename;
    console.log(`PDF ${pdfDocument.fingerprint} [${info.PDFFormatVersion} ` + `${(info.Producer || "-").trim()} / ${(info.Creator || "-").trim()}] ` + `(PDF.js: ${_pdfjsLib.version || "-"}` + `${this.pdfViewer.enableWebGL ? " [WebGL]" : ""})`);
    let pdfTitle;
    const infoTitle = info && info.Title;

    if (infoTitle) {
      pdfTitle = infoTitle;
    }

    const metadataTitle = metadata && metadata.get("dc:title");

    if (metadataTitle) {
      if (metadataTitle !== "Untitled" && !/[\uFFF0-\uFFFF]/g.test(metadataTitle)) {
        pdfTitle = metadataTitle;
      }
    }

    if (pdfTitle) {
      this.setTitle(`${pdfTitle} - ${contentDispositionFilename || document.title}`);
    } else if (contentDispositionFilename) {
      this.setTitle(contentDispositionFilename);
    }

    if (info.IsAcroFormPresent) {
      console.warn("Warning: AcroForm/XFA is not supported");
      this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.forms);
    }

    let versionId = "other";
    const KNOWN_VERSIONS = ["1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "1.9", "2.0", "2.1", "2.2", "2.3"];

    if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {
      versionId = `v${info.PDFFormatVersion.replace(".", "_")}`;
    }

    let generatorId = "other";
    const KNOWN_GENERATORS = ["acrobat distiller", "acrobat pdfwriter", "adobe livecycle", "adobe pdf library", "adobe photoshop", "ghostscript", "tcpdf", "cairo", "dvipdfm", "dvips", "pdftex", "pdfkit", "itext", "prince", "quarkxpress", "mac os x", "microsoft", "openoffice", "oracle", "luradocument", "pdf-xchange", "antenna house", "aspose.cells", "fpdf"];

    if (info.Producer) {
      const producer = info.Producer.toLowerCase();
      KNOWN_GENERATORS.some(function (generator) {
        if (!producer.includes(generator)) {
          return false;
        }

        generatorId = generator.replace(/[ .\-]/g, "_");
        return true;
      });
    }

    let formType = null;

    if (info.IsAcroFormPresent) {
      formType = info.IsXFAPresent ? "xfa" : "acroform";
    }

    this.externalServices.reportTelemetry({
      type: "documentInfo",
      version: versionId,
      generator: generatorId,
      formType
    });
  },

  async _initializePageLabels(pdfDocument) {
    const labels = await pdfDocument.getPageLabels();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    if (!labels || _app_options.AppOptions.get("disablePageLabels")) {
      return;
    }

    const numLabels = labels.length;

    if (numLabels !== this.pagesCount) {
      console.error("The number of Page Labels does not match the number of pages in the document.");
      return;
    }

    let i = 0;

    while (i < numLabels && labels[i] === (i + 1).toString()) {
      i++;
    }

    if (i === numLabels) {
      return;
    }

    const {
      pdfViewer,
      pdfThumbnailViewer,
      toolbar
    } = this;
    pdfViewer.setPageLabels(labels);
    pdfThumbnailViewer.setPageLabels(labels);
    toolbar.setPagesCount(numLabels, true);
    toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
  },

  _initializePdfHistory({
    fingerprint,
    viewOnLoad,
    initialDest = null
  }) {
    if (this.isViewerEmbedded || _app_options.AppOptions.get("disableHistory")) {
      return;
    }

    this.pdfHistory.initialize({
      fingerprint,
      resetHistory: viewOnLoad === ViewOnLoad.INITIAL,
      updateUrl: _app_options.AppOptions.get("historyUpdateUrl")
    });

    if (this.pdfHistory.initialBookmark) {
      this.initialBookmark = this.pdfHistory.initialBookmark;
      this.initialRotation = this.pdfHistory.initialRotation;
    }

    if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) {
      this.initialBookmark = JSON.stringify(initialDest);
      this.pdfHistory.push({
        explicitDest: initialDest,
        pageNumber: null
      });
    }
  },

  async _initializePermissions(pdfDocument) {
    const permissions = await pdfDocument.getPermissions();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    if (!permissions || !_app_options.AppOptions.get("enablePermissions")) {
      return;
    }

    if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY)) {
      this.appConfig.viewerContainer.classList.add(ENABLE_PERMISSIONS_CLASS);
    }
  },

  setInitialView(storedHash, {
    rotation,
    sidebarView,
    scrollMode,
    spreadMode
  } = {}) {
    const setRotation = angle => {
      if ((0, _ui_utils.isValidRotation)(angle)) {
        this.pdfViewer.pagesRotation = angle;
      }
    };

    const setViewerModes = (scroll, spread) => {
      if ((0, _ui_utils.isValidScrollMode)(scroll)) {
        this.pdfViewer.scrollMode = scroll;
      }

      if ((0, _ui_utils.isValidSpreadMode)(spread)) {
        this.pdfViewer.spreadMode = spread;
      }
    };

    this.isInitialViewSet = true;
    this.pdfSidebar.setInitialView(sidebarView);
    setViewerModes(scrollMode, spreadMode);

    if (this.initialBookmark) {
      setRotation(this.initialRotation);
      delete this.initialRotation;
      this.pdfLinkService.setHash(this.initialBookmark);
      this.initialBookmark = null;
    } else if (storedHash) {
      setRotation(rotation);
      this.pdfLinkService.setHash(storedHash);
    }

    this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);
    this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);

    if (!this.pdfViewer.currentScaleValue) {
      this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
    }
  },

  cleanup() {
    if (!this.pdfDocument) {
      return;
    }

    this.pdfViewer.cleanup();
    this.pdfThumbnailViewer.cleanup();

    if (this.pdfViewer.renderer !== _ui_utils.RendererType.SVG) {
      this.pdfDocument.cleanup();
    }
  },

  forceRendering() {
    this.pdfRenderingQueue.printing = this.printing;
    this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;
    this.pdfRenderingQueue.renderHighestPriority();
  },

  beforePrint() {
    if (this.printService) {
      return;
    }

    if (!this.supportsPrinting) {
      this.l10n.get("printing_not_supported", null, "Warning: Printing is not fully supported by this browser.").then(printMessage => {
        this.error(printMessage);
      });
      return;
    }

    if (!this.pdfViewer.pageViewsReady) {
      this.l10n.get("printing_not_ready", null, "Warning: The PDF is not fully loaded for printing.").then(notReadyMessage => {
        window.alert(notReadyMessage);
      });
      return;
    }

    const pagesOverview = this.pdfViewer.getPagesOverview();
    const printContainer = this.appConfig.printContainer;
    const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, this.l10n);
    this.printService = printService;
    this.forceRendering();
    printService.layout();
    this.externalServices.reportTelemetry({
      type: "print"
    });
  },

  afterPrint() {
    if (this.printService) {
      this.printService.destroy();
      this.printService = null;
    }

    this.forceRendering();
  },

  rotatePages(delta) {
    if (!this.pdfDocument) {
      return;
    }

    const newRotation = (this.pdfViewer.pagesRotation + 360 + delta) % 360;
    this.pdfViewer.pagesRotation = newRotation;
  },

  requestPresentationMode() {
    if (!this.pdfPresentationMode) {
      return;
    }

    this.pdfPresentationMode.request();
  },

  bindEvents() {
    const {
      eventBus,
      _boundEvents
    } = this;
    _boundEvents.beforePrint = this.beforePrint.bind(this);
    _boundEvents.afterPrint = this.afterPrint.bind(this);

    eventBus._on("resize", webViewerResize);

    eventBus._on("hashchange", webViewerHashchange);

    eventBus._on("beforeprint", _boundEvents.beforePrint);

    eventBus._on("afterprint", _boundEvents.afterPrint);

    eventBus._on("pagerendered", webViewerPageRendered);

    eventBus._on("updateviewarea", webViewerUpdateViewarea);

    eventBus._on("pagechanging", webViewerPageChanging);

    eventBus._on("scalechanging", webViewerScaleChanging);

    eventBus._on("rotationchanging", webViewerRotationChanging);

    eventBus._on("sidebarviewchanged", webViewerSidebarViewChanged);

    eventBus._on("pagemode", webViewerPageMode);

    eventBus._on("namedaction", webViewerNamedAction);

    eventBus._on("presentationmodechanged", webViewerPresentationModeChanged);

    eventBus._on("presentationmode", webViewerPresentationMode);

    eventBus._on("print", webViewerPrint);

    eventBus._on("download", webViewerDownload);

    eventBus._on("firstpage", webViewerFirstPage);

    eventBus._on("lastpage", webViewerLastPage);

    eventBus._on("nextpage", webViewerNextPage);

    eventBus._on("previouspage", webViewerPreviousPage);

    eventBus._on("zoomin", webViewerZoomIn);

    eventBus._on("zoomout", webViewerZoomOut);

    eventBus._on("zoomreset", webViewerZoomReset);

    eventBus._on("pagenumberchanged", webViewerPageNumberChanged);

    eventBus._on("scalechanged", webViewerScaleChanged);

    eventBus._on("rotatecw", webViewerRotateCw);

    eventBus._on("rotateccw", webViewerRotateCcw);

    eventBus._on("switchscrollmode", webViewerSwitchScrollMode);

    eventBus._on("scrollmodechanged", webViewerScrollModeChanged);

    eventBus._on("switchspreadmode", webViewerSwitchSpreadMode);

    eventBus._on("spreadmodechanged", webViewerSpreadModeChanged);

    eventBus._on("documentproperties", webViewerDocumentProperties);

    eventBus._on("find", webViewerFind);

    eventBus._on("findfromurlhash", webViewerFindFromUrlHash);

    eventBus._on("updatefindmatchescount", webViewerUpdateFindMatchesCount);

    eventBus._on("updatefindcontrolstate", webViewerUpdateFindControlState);

    eventBus._on("fileinputchange", webViewerFileInputChange);

    eventBus._on("openfile", webViewerOpenFile);
  },

  bindWindowEvents() {
    const {
      eventBus,
      _boundEvents
    } = this;

    _boundEvents.windowResize = () => {
      eventBus.dispatch("resize", {
        source: window
      });
    };

    _boundEvents.windowHashChange = () => {
      eventBus.dispatch("hashchange", {
        source: window,
        hash: document.location.hash.substring(1)
      });
    };

    _boundEvents.windowBeforePrint = () => {
      eventBus.dispatch("beforeprint", {
        source: window
      });
    };

    _boundEvents.windowAfterPrint = () => {
      eventBus.dispatch("afterprint", {
        source: window
      });
    };

    window.addEventListener("visibilitychange", webViewerVisibilityChange);
    window.addEventListener("wheel", webViewerWheel, {
      passive: false
    });
    window.addEventListener("click", webViewerClick);
    window.addEventListener("keydown", webViewerKeyDown);
    window.addEventListener("resize", _boundEvents.windowResize);
    window.addEventListener("hashchange", _boundEvents.windowHashChange);
    window.addEventListener("beforeprint", _boundEvents.windowBeforePrint);
    window.addEventListener("afterprint", _boundEvents.windowAfterPrint);
  },

  unbindEvents() {
    const {
      eventBus,
      _boundEvents
    } = this;

    eventBus._off("resize", webViewerResize);

    eventBus._off("hashchange", webViewerHashchange);

    eventBus._off("beforeprint", _boundEvents.beforePrint);

    eventBus._off("afterprint", _boundEvents.afterPrint);

    eventBus._off("pagerendered", webViewerPageRendered);

    eventBus._off("updateviewarea", webViewerUpdateViewarea);

    eventBus._off("pagechanging", webViewerPageChanging);

    eventBus._off("scalechanging", webViewerScaleChanging);

    eventBus._off("rotationchanging", webViewerRotationChanging);

    eventBus._off("sidebarviewchanged", webViewerSidebarViewChanged);

    eventBus._off("pagemode", webViewerPageMode);

    eventBus._off("namedaction", webViewerNamedAction);

    eventBus._off("presentationmodechanged", webViewerPresentationModeChanged);

    eventBus._off("presentationmode", webViewerPresentationMode);

    eventBus._off("print", webViewerPrint);

    eventBus._off("download", webViewerDownload);

    eventBus._off("firstpage", webViewerFirstPage);

    eventBus._off("lastpage", webViewerLastPage);

    eventBus._off("nextpage", webViewerNextPage);

    eventBus._off("previouspage", webViewerPreviousPage);

    eventBus._off("zoomin", webViewerZoomIn);

    eventBus._off("zoomout", webViewerZoomOut);

    eventBus._off("zoomreset", webViewerZoomReset);

    eventBus._off("pagenumberchanged", webViewerPageNumberChanged);

    eventBus._off("scalechanged", webViewerScaleChanged);

    eventBus._off("rotatecw", webViewerRotateCw);

    eventBus._off("rotateccw", webViewerRotateCcw);

    eventBus._off("switchscrollmode", webViewerSwitchScrollMode);

    eventBus._off("scrollmodechanged", webViewerScrollModeChanged);

    eventBus._off("switchspreadmode", webViewerSwitchSpreadMode);

    eventBus._off("spreadmodechanged", webViewerSpreadModeChanged);

    eventBus._off("documentproperties", webViewerDocumentProperties);

    eventBus._off("find", webViewerFind);

    eventBus._off("findfromurlhash", webViewerFindFromUrlHash);

    eventBus._off("updatefindmatchescount", webViewerUpdateFindMatchesCount);

    eventBus._off("updatefindcontrolstate", webViewerUpdateFindControlState);

    eventBus._off("fileinputchange", webViewerFileInputChange);

    eventBus._off("openfile", webViewerOpenFile);

    _boundEvents.beforePrint = null;
    _boundEvents.afterPrint = null;
  },

  unbindWindowEvents() {
    const {
      _boundEvents
    } = this;
    window.removeEventListener("visibilitychange", webViewerVisibilityChange);
    window.removeEventListener("wheel", webViewerWheel, {
      passive: false
    });
    window.removeEventListener("click", webViewerClick);
    window.removeEventListener("keydown", webViewerKeyDown);
    window.removeEventListener("resize", _boundEvents.windowResize);
    window.removeEventListener("hashchange", _boundEvents.windowHashChange);
    window.removeEventListener("beforeprint", _boundEvents.windowBeforePrint);
    window.removeEventListener("afterprint", _boundEvents.windowAfterPrint);
    _boundEvents.windowResize = null;
    _boundEvents.windowHashChange = null;
    _boundEvents.windowBeforePrint = null;
    _boundEvents.windowAfterPrint = null;
  }

};
exports.PDFViewerApplication = PDFViewerApplication;
let validateFileURL;
{
  const HOSTED_VIEWER_ORIGINS = ["null", "http://mozilla.github.io", "https://mozilla.github.io"];

  validateFileURL = function (file) {
    if (file === undefined) {
      return;
    }

    try {
      const viewerOrigin = new URL(window.location.href).origin || "null";

      if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {
        return;
      }

      const {
        origin,
        protocol
      } = new URL(file, window.location.href);

      if (origin !== viewerOrigin && protocol !== "blob:") {
        throw new Error("file origin does not match viewer's");
      }
    } catch (ex) {
      const message = ex && ex.message;
      PDFViewerApplication.l10n.get("loading_error", null, "An error occurred while loading the PDF.").then(loadingErrorMessage => {
        PDFViewerApplication.error(loadingErrorMessage, {
          message
        });
      });
      throw ex;
    }
  };
}

async function loadFakeWorker() {
  if (!_pdfjsLib.GlobalWorkerOptions.workerSrc) {
    _pdfjsLib.GlobalWorkerOptions.workerSrc = _app_options.AppOptions.get("workerSrc");
  }

  return (0, _pdfjsLib.loadScript)(_pdfjsLib.PDFWorker.getWorkerSrc());
}

function loadAndEnablePDFBug(enabledTabs) {
  const appConfig = PDFViewerApplication.appConfig;
  return (0, _pdfjsLib.loadScript)(appConfig.debuggerScriptPath).then(function () {
    PDFBug.enable(enabledTabs);
    PDFBug.init({
      OPS: _pdfjsLib.OPS
    }, appConfig.mainContainer);
  });
}

function webViewerInitialized() {
  const appConfig = PDFViewerApplication.appConfig;
  let file;
  const queryString = document.location.search.substring(1);
  const params = (0, _ui_utils.parseQueryString)(queryString);
  file = "file" in params ? params.file : _app_options.AppOptions.get("defaultUrl");
  validateFileURL(file);
  const fileInput = document.createElement("input");
  fileInput.id = appConfig.openFileInputName;
  fileInput.className = "fileInput";
  fileInput.setAttribute("type", "file");
  fileInput.oncontextmenu = _ui_utils.noContextMenuHandler;
  document.body.appendChild(fileInput);

  if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
    appConfig.toolbar.openFile.setAttribute("hidden", "true");
    appConfig.secondaryToolbar.openFileButton.setAttribute("hidden", "true");
  } else {
    fileInput.value = null;
  }

  fileInput.addEventListener("change", function (evt) {
    const files = evt.target.files;

    if (!files || files.length === 0) {
      return;
    }

    PDFViewerApplication.eventBus.dispatch("fileinputchange", {
      source: this,
      fileInput: evt.target
    });
  });
  appConfig.mainContainer.addEventListener("dragover", function (evt) {
    evt.preventDefault();
    evt.dataTransfer.dropEffect = "move";
  });
  appConfig.mainContainer.addEventListener("drop", function (evt) {
    evt.preventDefault();
    const files = evt.dataTransfer.files;

    if (!files || files.length === 0) {
      return;
    }

    PDFViewerApplication.eventBus.dispatch("fileinputchange", {
      source: this,
      fileInput: evt.dataTransfer
    });
  });

  if (!PDFViewerApplication.supportsDocumentFonts) {
    _app_options.AppOptions.set("disableFontFace", true);

    PDFViewerApplication.l10n.get("web_fonts_disabled", null, "Web fonts are disabled: unable to use embedded PDF fonts.").then(msg => {
      console.warn(msg);
    });
  }

  if (!PDFViewerApplication.supportsPrinting) {
    appConfig.toolbar.print.classList.add("hidden");
    appConfig.secondaryToolbar.printButton.classList.add("hidden");
  }

  if (!PDFViewerApplication.supportsFullscreen) {
    appConfig.toolbar.presentationModeButton.classList.add("hidden");
    appConfig.secondaryToolbar.presentationModeButton.classList.add("hidden");
  }

  if (PDFViewerApplication.supportsIntegratedFind) {
    appConfig.toolbar.viewFind.classList.add("hidden");
  }

  appConfig.mainContainer.addEventListener("transitionend", function (evt) {
    if (evt.target === this) {
      PDFViewerApplication.eventBus.dispatch("resize", {
        source: this
      });
    }
  }, true);

  try {
    webViewerOpenFileViaURL(file);
  } catch (reason) {
    PDFViewerApplication.l10n.get("loading_error", null, "An error occurred while loading the PDF.").then(msg => {
      PDFViewerApplication.error(msg, reason);
    });
  }
}

let webViewerOpenFileViaURL;
{
  webViewerOpenFileViaURL = function (file) {
    if (file && file.lastIndexOf("file:", 0) === 0) {
      PDFViewerApplication.setTitleUsingUrl(file);
      const xhr = new XMLHttpRequest();

      xhr.onload = function () {
        PDFViewerApplication.open(new Uint8Array(xhr.response));
      };

      xhr.open("GET", file);
      xhr.responseType = "arraybuffer";
      xhr.send();
      return;
    }

    if (file) {
      PDFViewerApplication.open(file);
    }
  };
}

function webViewerResetPermissions() {
  const {
    appConfig
  } = PDFViewerApplication;

  if (!appConfig) {
    return;
  }

  appConfig.viewerContainer.classList.remove(ENABLE_PERMISSIONS_CLASS);
}

function webViewerPageRendered(evt) {
  const pageNumber = evt.pageNumber;
  const pageIndex = pageNumber - 1;
  const pageView = PDFViewerApplication.pdfViewer.getPageView(pageIndex);

  if (pageNumber === PDFViewerApplication.page) {
    PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);
  }

  if (!pageView) {
    return;
  }

  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
    const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageIndex);
    thumbnailView.setImage(pageView);
  }

  if (typeof Stats !== "undefined" && Stats.enabled && pageView.stats) {
    Stats.add(pageNumber, pageView.stats);
  }

  if (pageView.error) {
    PDFViewerApplication.l10n.get("rendering_error", null, "An error occurred while rendering the page.").then(msg => {
      PDFViewerApplication.error(msg, pageView.error);
    });
  }

  PDFViewerApplication.externalServices.reportTelemetry({
    type: "pageInfo",
    timestamp: evt.timestamp
  });
  PDFViewerApplication.pdfDocument.getStats().then(function (stats) {
    PDFViewerApplication.externalServices.reportTelemetry({
      type: "documentStats",
      stats
    });
  });
}

function webViewerPageMode({
  mode
}) {
  let view;

  switch (mode) {
    case "thumbs":
      view = _pdf_sidebar.SidebarView.THUMBS;
      break;

    case "bookmarks":
    case "outline":
      view = _pdf_sidebar.SidebarView.OUTLINE;
      break;

    case "attachments":
      view = _pdf_sidebar.SidebarView.ATTACHMENTS;
      break;

    case "none":
      view = _pdf_sidebar.SidebarView.NONE;
      break;

    default:
      console.error('Invalid "pagemode" hash parameter: ' + mode);
      return;
  }

  PDFViewerApplication.pdfSidebar.switchView(view, true);
}

function webViewerNamedAction(evt) {
  const action = evt.action;

  switch (action) {
    case "GoToPage":
      PDFViewerApplication.appConfig.toolbar.pageNumber.select();
      break;

    case "Find":
      if (!PDFViewerApplication.supportsIntegratedFind) {
        PDFViewerApplication.findBar.toggle();
      }

      break;
  }
}

function webViewerPresentationModeChanged({
  active,
  switchInProgress
}) {
  let state = _ui_utils.PresentationModeState.NORMAL;

  if (switchInProgress) {
    state = _ui_utils.PresentationModeState.CHANGING;
  } else if (active) {
    state = _ui_utils.PresentationModeState.FULLSCREEN;
  }

  PDFViewerApplication.pdfViewer.presentationModeState = state;
}

function webViewerSidebarViewChanged(evt) {
  PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;
  const store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.set("sidebarView", evt.view).catch(function () {});
  }
}

function webViewerUpdateViewarea(evt) {
  const location = evt.location,
        store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.setMultiple({
      page: location.pageNumber,
      zoom: location.scale,
      scrollLeft: location.left,
      scrollTop: location.top,
      rotation: location.rotation
    }).catch(function () {});
  }

  const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);
  PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;
  PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;
  const currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);
  const loading = currentPage.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED;
  PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);
}

function webViewerScrollModeChanged(evt) {
  const store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.set("scrollMode", evt.mode).catch(function () {});
  }
}

function webViewerSpreadModeChanged(evt) {
  const store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.set("spreadMode", evt.mode).catch(function () {});
  }
}

function webViewerResize() {
  const {
    pdfDocument,
    pdfViewer
  } = PDFViewerApplication;

  if (!pdfDocument) {
    return;
  }

  const currentScaleValue = pdfViewer.currentScaleValue;

  if (currentScaleValue === "auto" || currentScaleValue === "page-fit" || currentScaleValue === "page-width") {
    pdfViewer.currentScaleValue = currentScaleValue;
  }

  pdfViewer.update();
}

function webViewerHashchange(evt) {
  const hash = evt.hash;

  if (!hash) {
    return;
  }

  if (!PDFViewerApplication.isInitialViewSet) {
    PDFViewerApplication.initialBookmark = hash;
  } else if (!PDFViewerApplication.pdfHistory.popStateInProgress) {
    PDFViewerApplication.pdfLinkService.setHash(hash);
  }
}

let webViewerFileInputChange, webViewerOpenFile;
{
  webViewerFileInputChange = function (evt) {
    if (PDFViewerApplication.pdfViewer && PDFViewerApplication.pdfViewer.isInPresentationMode) {
      return;
    }

    const file = evt.fileInput.files[0];

    if (!_app_options.AppOptions.get("disableCreateObjectURL")) {
      let url = URL.createObjectURL(file);

      if (file.name) {
        url = {
          url,
          originalUrl: file.name
        };
      }

      PDFViewerApplication.open(url);
    } else {
      PDFViewerApplication.setTitleUsingUrl(file.name);
      const fileReader = new FileReader();

      fileReader.onload = function webViewerChangeFileReaderOnload(event) {
        const buffer = event.target.result;
        PDFViewerApplication.open(new Uint8Array(buffer));
      };

      fileReader.readAsArrayBuffer(file);
    }

    const appConfig = PDFViewerApplication.appConfig;
    appConfig.toolbar.viewBookmark.setAttribute("hidden", "true");
    appConfig.secondaryToolbar.viewBookmarkButton.setAttribute("hidden", "true");
    appConfig.toolbar.download.setAttribute("hidden", "true");
    appConfig.secondaryToolbar.downloadButton.setAttribute("hidden", "true");
  };

  webViewerOpenFile = function (evt) {
    const openFileInputName = PDFViewerApplication.appConfig.openFileInputName;
    document.getElementById(openFileInputName).click();
  };
}

function webViewerPresentationMode() {
  PDFViewerApplication.requestPresentationMode();
}

function webViewerPrint() {
  window.print();
}

function webViewerDownload() {
  PDFViewerApplication.download();
}

function webViewerFirstPage() {
  if (PDFViewerApplication.pdfDocument) {
    PDFViewerApplication.page = 1;
  }
}

function webViewerLastPage() {
  if (PDFViewerApplication.pdfDocument) {
    PDFViewerApplication.page = PDFViewerApplication.pagesCount;
  }
}

function webViewerNextPage() {
  PDFViewerApplication.page++;
}

function webViewerPreviousPage() {
  PDFViewerApplication.page--;
}

function webViewerZoomIn() {
  PDFViewerApplication.zoomIn();
}

function webViewerZoomOut() {
  PDFViewerApplication.zoomOut();
}

function webViewerZoomReset() {
  PDFViewerApplication.zoomReset();
}

function webViewerPageNumberChanged(evt) {
  const pdfViewer = PDFViewerApplication.pdfViewer;

  if (evt.value !== "") {
    pdfViewer.currentPageLabel = evt.value;
  }

  if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {
    PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
  }
}

function webViewerScaleChanged(evt) {
  PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;
}

function webViewerRotateCw() {
  PDFViewerApplication.rotatePages(90);
}

function webViewerRotateCcw() {
  PDFViewerApplication.rotatePages(-90);
}

function webViewerSwitchScrollMode(evt) {
  PDFViewerApplication.pdfViewer.scrollMode = evt.mode;
}

function webViewerSwitchSpreadMode(evt) {
  PDFViewerApplication.pdfViewer.spreadMode = evt.mode;
}

function webViewerDocumentProperties() {
  PDFViewerApplication.pdfDocumentProperties.open();
}

function webViewerFind(evt) {
  PDFViewerApplication.findController.executeCommand("find" + evt.type, {
    query: evt.query,
    phraseSearch: evt.phraseSearch,
    caseSensitive: evt.caseSensitive,
    entireWord: evt.entireWord,
    highlightAll: evt.highlightAll,
    findPrevious: evt.findPrevious
  });
}

function webViewerFindFromUrlHash(evt) {
  PDFViewerApplication.findController.executeCommand("find", {
    query: evt.query,
    phraseSearch: evt.phraseSearch,
    caseSensitive: false,
    entireWord: false,
    highlightAll: true,
    findPrevious: false
  });
}

function webViewerUpdateFindMatchesCount({
  matchesCount
}) {
  if (PDFViewerApplication.supportsIntegratedFind) {
    PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);
  } else {
    PDFViewerApplication.findBar.updateResultsCount(matchesCount);
  }
}

function webViewerUpdateFindControlState({
  state,
  previous,
  matchesCount
}) {
  if (PDFViewerApplication.supportsIntegratedFind) {
    PDFViewerApplication.externalServices.updateFindControlState({
      result: state,
      findPrevious: previous,
      matchesCount
    });
  } else {
    PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);
  }
}

function webViewerScaleChanging(evt) {
  PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);
  PDFViewerApplication.pdfViewer.update();
}

function webViewerRotationChanging(evt) {
  PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;
  PDFViewerApplication.forceRendering();
  PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;
}

function webViewerPageChanging(evt) {
  const page = evt.pageNumber;
  PDFViewerApplication.toolbar.setPageNumber(page, evt.pageLabel || null);
  PDFViewerApplication.secondaryToolbar.setPageNumber(page);

  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
    PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(page);
  }

  if (typeof Stats !== "undefined" && Stats.enabled) {
    const pageView = PDFViewerApplication.pdfViewer.getPageView(page - 1);

    if (pageView && pageView.stats) {
      Stats.add(page, pageView.stats);
    }
  }
}

function webViewerVisibilityChange(evt) {
  if (document.visibilityState === "visible") {
    setZoomDisabledTimeout();
  }
}

let zoomDisabledTimeout = null;

function setZoomDisabledTimeout() {
  if (zoomDisabledTimeout) {
    clearTimeout(zoomDisabledTimeout);
  }

  zoomDisabledTimeout = setTimeout(function () {
    zoomDisabledTimeout = null;
  }, WHEEL_ZOOM_DISABLED_TIMEOUT);
}

function webViewerWheel(evt) {
  const {
    pdfViewer,
    supportedMouseWheelZoomModifierKeys
  } = PDFViewerApplication;

  if (pdfViewer.isInPresentationMode) {
    return;
  }

  if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) {
    evt.preventDefault();

    if (zoomDisabledTimeout || document.visibilityState === "hidden") {
      return;
    }

    const previousScale = pdfViewer.currentScale;
    const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
    const MOUSE_WHEEL_DELTA_PER_PAGE_SCALE = 3.0;
    const ticks = delta * MOUSE_WHEEL_DELTA_PER_PAGE_SCALE;

    if (ticks < 0) {
      PDFViewerApplication.zoomOut(-ticks);
    } else {
      PDFViewerApplication.zoomIn(ticks);
    }

    const currentScale = pdfViewer.currentScale;

    if (previousScale !== currentScale) {
      const scaleCorrectionFactor = currentScale / previousScale - 1;
      const rect = pdfViewer.container.getBoundingClientRect();
      const dx = evt.clientX - rect.left;
      const dy = evt.clientY - rect.top;
      pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;
      pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;
    }
  } else {
    setZoomDisabledTimeout();
  }
}

function webViewerClick(evt) {
  if (!PDFViewerApplication.secondaryToolbar.isOpen) {
    return;
  }

  const appConfig = PDFViewerApplication.appConfig;

  if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {
    PDFViewerApplication.secondaryToolbar.close();
  }
}

function webViewerKeyDown(evt) {
  if (PDFViewerApplication.overlayManager.active) {
    return;
  }

  let handled = false,
      ensureViewerFocused = false;
  const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);
  const pdfViewer = PDFViewerApplication.pdfViewer;
  const isViewerInPresentationMode = pdfViewer && pdfViewer.isInPresentationMode;

  if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {
    switch (evt.keyCode) {
      case 70:
        if (!PDFViewerApplication.supportsIntegratedFind) {
          PDFViewerApplication.findBar.open();
          handled = true;
        }

        break;

      case 71:
        if (!PDFViewerApplication.supportsIntegratedFind) {
          const findState = PDFViewerApplication.findController.state;

          if (findState) {
            PDFViewerApplication.findController.executeCommand("findagain", {
              query: findState.query,
              phraseSearch: findState.phraseSearch,
              caseSensitive: findState.caseSensitive,
              entireWord: findState.entireWord,
              highlightAll: findState.highlightAll,
              findPrevious: cmd === 5 || cmd === 12
            });
          }

          handled = true;
        }

        break;

      case 61:
      case 107:
      case 187:
      case 171:
        if (!isViewerInPresentationMode) {
          PDFViewerApplication.zoomIn();
        }

        handled = true;
        break;

      case 173:
      case 109:
      case 189:
        if (!isViewerInPresentationMode) {
          PDFViewerApplication.zoomOut();
        }

        handled = true;
        break;

      case 48:
      case 96:
        if (!isViewerInPresentationMode) {
          setTimeout(function () {
            PDFViewerApplication.zoomReset();
          });
          handled = false;
        }

        break;

      case 38:
        if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
          PDFViewerApplication.page = 1;
          handled = true;
          ensureViewerFocused = true;
        }

        break;

      case 40:
        if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
          PDFViewerApplication.page = PDFViewerApplication.pagesCount;
          handled = true;
          ensureViewerFocused = true;
        }

        break;
    }
  }

  const {
    eventBus
  } = PDFViewerApplication;

  if (cmd === 1 || cmd === 8) {
    switch (evt.keyCode) {
      case 83:
        eventBus.dispatch("download", {
          source: window
        });
        handled = true;
        break;

      case 79:
        {
          eventBus.dispatch("openfile", {
            source: window
          });
          handled = true;
        }
        break;
    }
  }

  if (cmd === 3 || cmd === 10) {
    switch (evt.keyCode) {
      case 80:
        PDFViewerApplication.requestPresentationMode();
        handled = true;
        break;

      case 71:
        PDFViewerApplication.appConfig.toolbar.pageNumber.select();
        handled = true;
        break;
    }
  }

  if (handled) {
    if (ensureViewerFocused && !isViewerInPresentationMode) {
      pdfViewer.focus();
    }

    evt.preventDefault();
    return;
  }

  const curElement = document.activeElement || document.querySelector(":focus");
  const curElementTagName = curElement && curElement.tagName.toUpperCase();

  if (curElementTagName === "INPUT" || curElementTagName === "TEXTAREA" || curElementTagName === "SELECT" || curElement && curElement.isContentEditable) {
    if (evt.keyCode !== 27) {
      return;
    }
  }

  if (cmd === 0) {
    let turnPage = 0,
        turnOnlyIfPageFit = false;

    switch (evt.keyCode) {
      case 38:
      case 33:
        if (pdfViewer.isVerticalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

        turnPage = -1;
        break;

      case 8:
        if (!isViewerInPresentationMode) {
          turnOnlyIfPageFit = true;
        }

        turnPage = -1;
        break;

      case 37:
        if (pdfViewer.isHorizontalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

      case 75:
      case 80:
        turnPage = -1;
        break;

      case 27:
        if (PDFViewerApplication.secondaryToolbar.isOpen) {
          PDFViewerApplication.secondaryToolbar.close();
          handled = true;
        }

        if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {
          PDFViewerApplication.findBar.close();
          handled = true;
        }

        break;

      case 40:
      case 34:
        if (pdfViewer.isVerticalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

        turnPage = 1;
        break;

      case 13:
      case 32:
        if (!isViewerInPresentationMode) {
          turnOnlyIfPageFit = true;
        }

        turnPage = 1;
        break;

      case 39:
        if (pdfViewer.isHorizontalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

      case 74:
      case 78:
        turnPage = 1;
        break;

      case 36:
        if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
          PDFViewerApplication.page = 1;
          handled = true;
          ensureViewerFocused = true;
        }

        break;

      case 35:
        if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
          PDFViewerApplication.page = PDFViewerApplication.pagesCount;
          handled = true;
          ensureViewerFocused = true;
        }

        break;

      case 83:
        PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.SELECT);
        break;

      case 72:
        PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.HAND);
        break;

      case 82:
        PDFViewerApplication.rotatePages(90);
        break;

      case 115:
        PDFViewerApplication.pdfSidebar.toggle();
        break;
    }

    if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === "page-fit")) {
      if (turnPage > 0) {
        if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
          PDFViewerApplication.page++;
        }
      } else {
        if (PDFViewerApplication.page > 1) {
          PDFViewerApplication.page--;
        }
      }

      handled = true;
    }
  }

  if (cmd === 4) {
    switch (evt.keyCode) {
      case 13:
      case 32:
        if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== "page-fit") {
          break;
        }

        if (PDFViewerApplication.page > 1) {
          PDFViewerApplication.page--;
        }

        handled = true;
        break;

      case 82:
        PDFViewerApplication.rotatePages(-90);
        break;
    }
  }

  if (!handled && !isViewerInPresentationMode) {
    if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== "BUTTON") {
      ensureViewerFocused = true;
    }
  }

  if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {
    pdfViewer.focus();
  }

  if (handled) {
    evt.preventDefault();
  }
}

function apiPageLayoutToSpreadMode(layout) {
  switch (layout) {
    case "SinglePage":
    case "OneColumn":
      return _ui_utils.SpreadMode.NONE;

    case "TwoColumnLeft":
    case "TwoPageLeft":
      return _ui_utils.SpreadMode.ODD;

    case "TwoColumnRight":
    case "TwoPageRight":
      return _ui_utils.SpreadMode.EVEN;
  }

  return _ui_utils.SpreadMode.NONE;
}

function apiPageModeToSidebarView(mode) {
  switch (mode) {
    case "UseNone":
      return _pdf_sidebar.SidebarView.NONE;

    case "UseThumbs":
      return _pdf_sidebar.SidebarView.THUMBS;

    case "UseOutlines":
      return _pdf_sidebar.SidebarView.OUTLINE;

    case "UseAttachments":
      return _pdf_sidebar.SidebarView.ATTACHMENTS;

    case "UseOC":
  }

  return _pdf_sidebar.SidebarView.NONE;
}

const PDFPrintServiceFactory = {
  instance: {
    supportsPrinting: false,

    createPrintService() {
      throw new Error("Not implemented: createPrintService");
    }

  }
};
exports.PDFPrintServiceFactory = PDFPrintServiceFactory;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isValidRotation = isValidRotation;
exports.isValidScrollMode = isValidScrollMode;
exports.isValidSpreadMode = isValidSpreadMode;
exports.isPortraitOrientation = isPortraitOrientation;
exports.clamp = clamp;
exports.getPDFFileNameFromURL = getPDFFileNameFromURL;
exports.noContextMenuHandler = noContextMenuHandler;
exports.parseQueryString = parseQueryString;
exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
exports.getVisibleElements = getVisibleElements;
exports.roundToDivide = roundToDivide;
exports.getPageSizeInches = getPageSizeInches;
exports.approximateFraction = approximateFraction;
exports.getOutputScale = getOutputScale;
exports.scrollIntoView = scrollIntoView;
exports.watchScroll = watchScroll;
exports.binarySearchFirstItem = binarySearchFirstItem;
exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
exports.moveToEndOfArray = moveToEndOfArray;
exports.WaitOnType = exports.animationStarted = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.SpreadMode = exports.ScrollMode = exports.TextLayerMode = exports.RendererType = exports.PresentationModeState = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = exports.AutoPrintRegExp = void 0;
const CSS_UNITS = 96.0 / 72.0;
exports.CSS_UNITS = CSS_UNITS;
const DEFAULT_SCALE_VALUE = "auto";
exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
const DEFAULT_SCALE = 1.0;
exports.DEFAULT_SCALE = DEFAULT_SCALE;
const MIN_SCALE = 0.1;
exports.MIN_SCALE = MIN_SCALE;
const MAX_SCALE = 10.0;
exports.MAX_SCALE = MAX_SCALE;
const UNKNOWN_SCALE = 0;
exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
const MAX_AUTO_SCALE = 1.25;
exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
const SCROLLBAR_PADDING = 40;
exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
const VERTICAL_PADDING = 5;
exports.VERTICAL_PADDING = VERTICAL_PADDING;
const PresentationModeState = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
};
exports.PresentationModeState = PresentationModeState;
const RendererType = {
  CANVAS: "canvas",
  SVG: "svg"
};
exports.RendererType = RendererType;
const TextLayerMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_ENHANCE: 2
};
exports.TextLayerMode = TextLayerMode;
const ScrollMode = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2
};
exports.ScrollMode = ScrollMode;
const SpreadMode = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
exports.SpreadMode = SpreadMode;
const AutoPrintRegExp = /\bprint\s*\(/;
exports.AutoPrintRegExp = AutoPrintRegExp;

function formatL10nValue(text, args) {
  if (!args) {
    return text;
  }

  return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
    return name in args ? args[name] : "{{" + name + "}}";
  });
}

const NullL10n = {
  async getLanguage() {
    return "en-us";
  },

  async getDirection() {
    return "ltr";
  },

  async get(property, args, fallback) {
    return formatL10nValue(fallback, args);
  },

  async translate(element) {}

};
exports.NullL10n = NullL10n;

function getOutputScale(ctx) {
  const devicePixelRatio = window.devicePixelRatio || 1;
  const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
  const pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}

function scrollIntoView(element, spot, skipOverflowHiddenElements = false) {
  let parent = element.offsetParent;

  if (!parent) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }

  let offsetY = element.offsetTop + element.clientTop;
  let offsetX = element.offsetLeft + element.clientLeft;

  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") {
    if (parent.dataset._scaleY) {
      offsetY /= parent.dataset._scaleY;
      offsetX /= parent.dataset._scaleX;
    }

    offsetY += parent.offsetTop;
    offsetX += parent.offsetLeft;
    parent = parent.offsetParent;

    if (!parent) {
      return;
    }
  }

  if (spot) {
    if (spot.top !== undefined) {
      offsetY += spot.top;
    }

    if (spot.left !== undefined) {
      offsetX += spot.left;
      parent.scrollLeft = offsetX;
    }
  }

  parent.scrollTop = offsetY;
}

function watchScroll(viewAreaElement, callback) {
  const debounceScroll = function (evt) {
    if (rAF) {
      return;
    }

    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      const currentX = viewAreaElement.scrollLeft;
      const lastX = state.lastX;

      if (currentX !== lastX) {
        state.right = currentX > lastX;
      }

      state.lastX = currentX;
      const currentY = viewAreaElement.scrollTop;
      const lastY = state.lastY;

      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }

      state.lastY = currentY;
      callback(state);
    });
  };

  const state = {
    right: true,
    down: true,
    lastX: viewAreaElement.scrollLeft,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  let rAF = null;
  viewAreaElement.addEventListener("scroll", debounceScroll, true);
  return state;
}

function parseQueryString(query) {
  const parts = query.split("&");
  const params = Object.create(null);

  for (let i = 0, ii = parts.length; i < ii; ++i) {
    const param = parts[i].split("=");
    const key = param[0].toLowerCase();
    const value = param.length > 1 ? param[1] : null;
    params[decodeURIComponent(key)] = decodeURIComponent(value);
  }

  return params;
}

function binarySearchFirstItem(items, condition) {
  let minIndex = 0;
  let maxIndex = items.length - 1;

  if (maxIndex < 0 || !condition(items[maxIndex])) {
    return items.length;
  }

  if (condition(items[minIndex])) {
    return minIndex;
  }

  while (minIndex < maxIndex) {
    const currentIndex = minIndex + maxIndex >> 1;
    const currentItem = items[currentIndex];

    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }

  return minIndex;
}

function approximateFraction(x) {
  if (Math.floor(x) === x) {
    return [x, 1];
  }

  const xinv = 1 / x;
  const limit = 8;

  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }

  const x_ = x > 1 ? xinv : x;
  let a = 0,
      b = 1,
      c = 1,
      d = 1;

  while (true) {
    const p = a + c,
          q = b + d;

    if (q > limit) {
      break;
    }

    if (x_ <= p / q) {
      c = p;
      d = q;
    } else {
      a = p;
      b = q;
    }
  }

  let result;

  if (x_ - a / b < c / d - x_) {
    result = x_ === x ? [a, b] : [b, a];
  } else {
    result = x_ === x ? [c, d] : [d, c];
  }

  return result;
}

function roundToDivide(x, div) {
  const r = x % div;
  return r === 0 ? x : Math.round(x - r + div);
}

function getPageSizeInches({
  view,
  userUnit,
  rotate
}) {
  const [x1, y1, x2, y2] = view;
  const changeOrientation = rotate % 180 !== 0;
  const width = (x2 - x1) / 72 * userUnit;
  const height = (y2 - y1) / 72 * userUnit;
  return {
    width: changeOrientation ? height : width,
    height: changeOrientation ? width : height
  };
}

function backtrackBeforeAllVisibleElements(index, views, top) {
  if (index < 2) {
    return index;
  }

  let elt = views[index].div;
  let pageTop = elt.offsetTop + elt.clientTop;

  if (pageTop >= top) {
    elt = views[index - 1].div;
    pageTop = elt.offsetTop + elt.clientTop;
  }

  for (let i = index - 2; i >= 0; --i) {
    elt = views[i].div;

    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
      break;
    }

    index = i;
  }

  return index;
}

function getVisibleElements(scrollEl, views, sortByVisibility = false, horizontal = false) {
  const top = scrollEl.scrollTop,
        bottom = top + scrollEl.clientHeight;
  const left = scrollEl.scrollLeft,
        right = left + scrollEl.clientWidth;

  function isElementBottomAfterViewTop(view) {
    const element = view.div;
    const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }

  function isElementRightAfterViewLeft(view) {
    const element = view.div;
    const elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;
    return elementRight > left;
  }

  const visible = [],
        numViews = views.length;
  let firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop);

  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
  }

  let lastEdge = horizontal ? right : -1;

  for (let i = firstVisibleElementInd; i < numViews; i++) {
    const view = views[i],
          element = view.div;
    const currentWidth = element.offsetLeft + element.clientLeft;
    const currentHeight = element.offsetTop + element.clientTop;
    const viewWidth = element.clientWidth,
          viewHeight = element.clientHeight;
    const viewRight = currentWidth + viewWidth;
    const viewBottom = currentHeight + viewHeight;

    if (lastEdge === -1) {
      if (viewBottom >= bottom) {
        lastEdge = viewBottom;
      }
    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
      break;
    }

    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
      continue;
    }

    const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
    const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
    const percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view,
      percent
    });
  }

  const first = visible[0],
        last = visible[visible.length - 1];

  if (sortByVisibility) {
    visible.sort(function (a, b) {
      const pc = a.percent - b.percent;

      if (Math.abs(pc) > 0.001) {
        return -pc;
      }

      return a.id - b.id;
    });
  }

  return {
    first,
    last,
    views: visible
  };
}

function noContextMenuHandler(evt) {
  evt.preventDefault();
}

function isDataSchema(url) {
  let i = 0;
  const ii = url.length;

  while (i < ii && url[i].trim() === "") {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === "data:";
}

function getPDFFileNameFromURL(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }

  if (isDataSchema(url)) {
    console.warn("getPDFFileNameFromURL: " + 'ignoring "data:" URL for performance reasons.');
    return defaultFilename;
  }

  const reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {}
    }
  }

  return suggestedFilename || defaultFilename;
}

function normalizeWheelEventDelta(evt) {
  let delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
  const angle = Math.atan2(evt.deltaY, evt.deltaX);

  if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
    delta = -delta;
  }

  const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
  const MOUSE_DOM_DELTA_LINE_MODE = 1;
  const MOUSE_PIXELS_PER_LINE = 30;
  const MOUSE_LINES_PER_PAGE = 30;

  if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
    delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
  } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
    delta /= MOUSE_LINES_PER_PAGE;
  }

  return delta;
}

function isValidRotation(angle) {
  return Number.isInteger(angle) && angle % 90 === 0;
}

function isValidScrollMode(mode) {
  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}

function isValidSpreadMode(mode) {
  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}

function isPortraitOrientation(size) {
  return size.width <= size.height;
}

const WaitOnType = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
exports.WaitOnType = WaitOnType;

function waitOnEventOrTimeout({
  target,
  name,
  delay = 0
}) {
  return new Promise(function (resolve, reject) {
    if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
      throw new Error("waitOnEventOrTimeout - invalid parameters.");
    }

    function handler(type) {
      if (target instanceof EventBus) {
        target._off(name, eventHandler);
      } else {
        target.removeEventListener(name, eventHandler);
      }

      if (timeout) {
        clearTimeout(timeout);
      }

      resolve(type);
    }

    const eventHandler = handler.bind(null, WaitOnType.EVENT);

    if (target instanceof EventBus) {
      target._on(name, eventHandler);
    } else {
      target.addEventListener(name, eventHandler);
    }

    const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
    const timeout = setTimeout(timeoutHandler, delay);
  });
}

const animationStarted = new Promise(function (resolve) {
  window.requestAnimationFrame(resolve);
});
exports.animationStarted = animationStarted;

function dispatchDOMEvent(eventName, args = null) {
  throw new Error("Not implemented: dispatchDOMEvent");
}

class EventBus {
  constructor(options) {
    this._listeners = Object.create(null);
  }

  on(eventName, listener) {
    this._on(eventName, listener, {
      external: true
    });
  }

  off(eventName, listener) {
    this._off(eventName, listener, {
      external: true
    });
  }

  dispatch(eventName) {
    const eventListeners = this._listeners[eventName];

    if (!eventListeners || eventListeners.length === 0) {
      return;
    }

    const args = Array.prototype.slice.call(arguments, 1);
    let externalListeners;
    eventListeners.slice(0).forEach(function ({
      listener,
      external
    }) {
      if (external) {
        if (!externalListeners) {
          externalListeners = [];
        }

        externalListeners.push(listener);
        return;
      }

      listener.apply(null, args);
    });

    if (externalListeners) {
      externalListeners.forEach(function (listener) {
        listener.apply(null, args);
      });
      externalListeners = null;
    }
  }

  _on(eventName, listener, options = null) {
    let eventListeners = this._listeners[eventName];

    if (!eventListeners) {
      this._listeners[eventName] = eventListeners = [];
    }

    eventListeners.push({
      listener,
      external: (options && options.external) === true
    });
  }

  _off(eventName, listener, options = null) {
    const eventListeners = this._listeners[eventName];

    if (!eventListeners) {
      return;
    }

    for (let i = 0, ii = eventListeners.length; i < ii; i++) {
      if (eventListeners[i].listener === listener) {
        eventListeners.splice(i, 1);
        return;
      }
    }
  }

}

exports.EventBus = EventBus;

function clamp(v, min, max) {
  return Math.min(Math.max(v, min), max);
}

class ProgressBar {
  constructor(id, {
    height,
    width,
    units
  } = {}) {
    this.visible = true;
    this.div = document.querySelector(id + " .progress");
    this.bar = this.div.parentNode;
    this.height = height || 100;
    this.width = width || 100;
    this.units = units || "%";
    this.div.style.height = this.height + this.units;
    this.percent = 0;
  }

  _updateBar() {
    if (this._indeterminate) {
      this.div.classList.add("indeterminate");
      this.div.style.width = this.width + this.units;
      return;
    }

    this.div.classList.remove("indeterminate");
    const progressSize = this.width * this._percent / 100;
    this.div.style.width = progressSize + this.units;
  }

  get percent() {
    return this._percent;
  }

  set percent(val) {
    this._indeterminate = isNaN(val);
    this._percent = clamp(val, 0, 100);

    this._updateBar();
  }

  setWidth(viewer) {
    if (!viewer) {
      return;
    }

    const container = viewer.parentNode;
    const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

    if (scrollbarWidth > 0) {
      this.bar.style.width = `calc(100% - ${scrollbarWidth}px)`;
    }
  }

  hide() {
    if (!this.visible) {
      return;
    }

    this.visible = false;
    this.bar.classList.add("hidden");
    document.body.classList.remove("loadingInProgress");
  }

  show() {
    if (this.visible) {
      return;
    }

    this.visible = true;
    document.body.classList.add("loadingInProgress");
    this.bar.classList.remove("hidden");
  }

}

exports.ProgressBar = ProgressBar;

function moveToEndOfArray(arr, condition) {
  const moved = [],
        len = arr.length;
  let write = 0;

  for (let read = 0; read < len; ++read) {
    if (condition(arr[read])) {
      moved.push(arr[read]);
    } else {
      arr[write] = arr[read];
      ++write;
    }
  }

  for (let read = 0; write < len; ++read, ++write) {
    arr[write] = moved[read];
  }
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionKind = exports.AppOptions = void 0;

var _viewer_compatibility = __webpack_require__(4);

const OptionKind = {
  VIEWER: 0x02,
  API: 0x04,
  WORKER: 0x08,
  PREFERENCE: 0x80
};
exports.OptionKind = OptionKind;
const defaultOptions = {
  cursorToolOnLoad: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  defaultUrl: {
    value: window.location.origin + "/pdf/83186",
    kind: OptionKind.VIEWER
  },
  defaultZoomValue: {
    value: "",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  disableCreateObjectURL: {
    value: false,
    compatibility: _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL,
    kind: OptionKind.VIEWER
  },
  disableHistory: {
    value: false,
    kind: OptionKind.VIEWER
  },
  disablePageLabels: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enablePermissions: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableWebGL: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: OptionKind.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  historyUpdateUrl: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: OptionKind.VIEWER
  },
  maxCanvasPixels: {
    value: 16777216,
    compatibility: _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels,
    kind: OptionKind.VIEWER
  },
  pdfBugEnabled: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: OptionKind.VIEWER
  },
  renderer: {
    value: "canvas",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  renderInteractiveForms: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  useOnlyCssZoom: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  cMapPacked: {
    value: true,
    kind: OptionKind.API
  },
  cMapUrl: {
    value: "https://cdn.pathfactory.com/pdfjs/2.5.207/web/cmaps/",
    kind: OptionKind.API
  },
  disableAutoFetch: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableFontFace: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableRange: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableStream: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: OptionKind.API
  },
  fontExtraProperties: {
    value: false,
    kind: OptionKind.API
  },
  isEvalSupported: {
    value: true,
    kind: OptionKind.API
  },
  maxImageSize: {
    value: -1,
    kind: OptionKind.API
  },
  pdfBug: {
    value: false,
    kind: OptionKind.API
  },
  verbosity: {
    value: 1,
    kind: OptionKind.API
  },
  workerPort: {
    value: null,
    kind: OptionKind.WORKER
  },
  workerSrc: {
    value: "https://cdn.pathfactory.com/pdfjs/2.5.207/build/pdf.worker.min.js",
    kind: OptionKind.WORKER
  }
};
{
  defaultOptions.disablePreferences = {
    value: false,
    kind: OptionKind.VIEWER
  };
  defaultOptions.locale = {
    value: typeof navigator !== "undefined" ? navigator.language : "en-US",
    kind: OptionKind.VIEWER
  };
}
const userOptions = Object.create(null);

class AppOptions {
  constructor() {
    throw new Error("Cannot initialize AppOptions.");
  }

  static get(name) {
    const userOption = userOptions[name];

    if (userOption !== undefined) {
      return userOption;
    }

    const defaultOption = defaultOptions[name];

    if (defaultOption !== undefined) {
      return defaultOption.compatibility || defaultOption.value;
    }

    return undefined;
  }

  static getAll(kind = null) {
    const options = Object.create(null);

    for (const name in defaultOptions) {
      const defaultOption = defaultOptions[name];

      if (kind) {
        if ((kind & defaultOption.kind) === 0) {
          continue;
        }

        if (kind === OptionKind.PREFERENCE) {
          const value = defaultOption.value,
                valueType = typeof value;

          if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
            options[name] = value;
            continue;
          }

          throw new Error(`Invalid type for preference: ${name}`);
        }
      }

      const userOption = userOptions[name];
      options[name] = userOption !== undefined ? userOption : defaultOption.compatibility || defaultOption.value;
    }

    return options;
  }

  static set(name, value) {
    userOptions[name] = value;
  }

  static remove(name) {
    delete userOptions[name];
  }

}

exports.AppOptions = AppOptions;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.viewerCompatibilityParams = void 0;
const compatibilityParams = Object.create(null);
{
  const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
  const platform = typeof navigator !== "undefined" && navigator.platform || "";
  const maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1;
  const isAndroid = /Android/.test(userAgent);
  const isIE = /Trident/.test(userAgent);
  const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
  const isIOSChrome = /CriOS/.test(userAgent);

  (function checkOnBlobSupport() {
    if (isIE || isIOSChrome) {
      compatibilityParams.disableCreateObjectURL = true;
    }
  })();

  (function checkCanvasSizeLimitation() {
    if (isIOS || isAndroid) {
      compatibilityParams.maxCanvasPixels = 5242880;
    }
  })();
}
const viewerCompatibilityParams = Object.freeze(compatibilityParams);
exports.viewerCompatibilityParams = viewerCompatibilityParams;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


let pdfjsLib;

if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
  pdfjsLib = window["pdfjs-dist/build/pdf"];
} else {
  pdfjsLib = require("../build/pdf.js");
}

module.exports = pdfjsLib;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFCursorTools = exports.CursorTool = void 0;

var _grab_to_pan = __webpack_require__(7);

const CursorTool = {
  SELECT: 0,
  HAND: 1,
  ZOOM: 2
};
exports.CursorTool = CursorTool;

class PDFCursorTools {
  constructor({
    container,
    eventBus,
    cursorToolOnLoad = CursorTool.SELECT
  }) {
    this.container = container;
    this.eventBus = eventBus;
    this.active = CursorTool.SELECT;
    this.activeBeforePresentationMode = null;
    this.handTool = new _grab_to_pan.GrabToPan({
      element: this.container
    });

    this._addEventListeners();

    Promise.resolve().then(() => {
      this.switchTool(cursorToolOnLoad);
    });
  }

  get activeTool() {
    return this.active;
  }

  switchTool(tool) {
    if (this.activeBeforePresentationMode !== null) {
      return;
    }

    if (tool === this.active) {
      return;
    }

    const disableActiveTool = () => {
      switch (this.active) {
        case CursorTool.SELECT:
          break;

        case CursorTool.HAND:
          this.handTool.deactivate();
          break;

        case CursorTool.ZOOM:
      }
    };

    switch (tool) {
      case CursorTool.SELECT:
        disableActiveTool();
        break;

      case CursorTool.HAND:
        disableActiveTool();
        this.handTool.activate();
        break;

      case CursorTool.ZOOM:
      default:
        console.error(`switchTool: "${tool}" is an unsupported value.`);
        return;
    }

    this.active = tool;

    this._dispatchEvent();
  }

  _dispatchEvent() {
    this.eventBus.dispatch("cursortoolchanged", {
      source: this,
      tool: this.active
    });
  }

  _addEventListeners() {
    this.eventBus._on("switchcursortool", evt => {
      this.switchTool(evt.tool);
    });

    this.eventBus._on("presentationmodechanged", evt => {
      if (evt.switchInProgress) {
        return;
      }

      let previouslyActive;

      if (evt.active) {
        previouslyActive = this.active;
        this.switchTool(CursorTool.SELECT);
        this.activeBeforePresentationMode = previouslyActive;
      } else {
        previouslyActive = this.activeBeforePresentationMode;
        this.activeBeforePresentationMode = null;
        this.switchTool(previouslyActive);
      }
    });
  }

}

exports.PDFCursorTools = PDFCursorTools;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GrabToPan = GrabToPan;

function GrabToPan(options) {
  this.element = options.element;
  this.document = options.element.ownerDocument;

  if (typeof options.ignoreTarget === "function") {
    this.ignoreTarget = options.ignoreTarget;
  }

  this.onActiveChanged = options.onActiveChanged;
  this.activate = this.activate.bind(this);
  this.deactivate = this.deactivate.bind(this);
  this.toggle = this.toggle.bind(this);
  this._onmousedown = this._onmousedown.bind(this);
  this._onmousemove = this._onmousemove.bind(this);
  this._endPan = this._endPan.bind(this);
  const overlay = this.overlay = document.createElement("div");
  overlay.className = "grab-to-pan-grabbing";
}

GrabToPan.prototype = {
  CSS_CLASS_GRAB: "grab-to-pan-grab",
  activate: function GrabToPan_activate() {
    if (!this.active) {
      this.active = true;
      this.element.addEventListener("mousedown", this._onmousedown, true);
      this.element.classList.add(this.CSS_CLASS_GRAB);

      if (this.onActiveChanged) {
        this.onActiveChanged(true);
      }
    }
  },
  deactivate: function GrabToPan_deactivate() {
    if (this.active) {
      this.active = false;
      this.element.removeEventListener("mousedown", this._onmousedown, true);

      this._endPan();

      this.element.classList.remove(this.CSS_CLASS_GRAB);

      if (this.onActiveChanged) {
        this.onActiveChanged(false);
      }
    }
  },
  toggle: function GrabToPan_toggle() {
    if (this.active) {
      this.deactivate();
    } else {
      this.activate();
    }
  },
  ignoreTarget: function GrabToPan_ignoreTarget(node) {
    return node[matchesSelector]("a[href], a[href] *, input, textarea, button, button *, select, option");
  },
  _onmousedown: function GrabToPan__onmousedown(event) {
    if (event.button !== 0 || this.ignoreTarget(event.target)) {
      return;
    }

    if (event.originalTarget) {
      try {
        event.originalTarget.tagName;
      } catch (e) {
        return;
      }
    }

    this.scrollLeftStart = this.element.scrollLeft;
    this.scrollTopStart = this.element.scrollTop;
    this.clientXStart = event.clientX;
    this.clientYStart = event.clientY;
    this.document.addEventListener("mousemove", this._onmousemove, true);
    this.document.addEventListener("mouseup", this._endPan, true);
    this.element.addEventListener("scroll", this._endPan, true);
    event.preventDefault();
    event.stopPropagation();
    const focusedElement = document.activeElement;

    if (focusedElement && !focusedElement.contains(event.target)) {
      focusedElement.blur();
    }
  },
  _onmousemove: function GrabToPan__onmousemove(event) {
    this.element.removeEventListener("scroll", this._endPan, true);

    if (isLeftMouseReleased(event)) {
      this._endPan();

      return;
    }

    const xDiff = event.clientX - this.clientXStart;
    const yDiff = event.clientY - this.clientYStart;
    const scrollTop = this.scrollTopStart - yDiff;
    const scrollLeft = this.scrollLeftStart - xDiff;

    if (this.element.scrollTo) {
      this.element.scrollTo({
        top: scrollTop,
        left: scrollLeft,
        behavior: "instant"
      });
    } else {
      this.element.scrollTop = scrollTop;
      this.element.scrollLeft = scrollLeft;
    }

    if (!this.overlay.parentNode) {
      document.body.appendChild(this.overlay);
    }
  },
  _endPan: function GrabToPan__endPan() {
    this.element.removeEventListener("scroll", this._endPan, true);
    this.document.removeEventListener("mousemove", this._onmousemove, true);
    this.document.removeEventListener("mouseup", this._endPan, true);
    this.overlay.remove();
  }
};
let matchesSelector;
["webkitM", "mozM", "msM", "oM", "m"].some(function (prefix) {
  let name = prefix + "atches";

  if (name in document.documentElement) {
    matchesSelector = name;
  }

  name += "Selector";

  if (name in document.documentElement) {
    matchesSelector = name;
  }

  return matchesSelector;
});
const isNotIEorIsIE10plus = !document.documentMode || document.documentMode > 9;
const chrome = window.chrome;
const isChrome15OrOpera15plus = chrome && (chrome.webstore || chrome.app);
const isSafari6plus = /Apple/.test(navigator.vendor) && /Version\/([6-9]\d*|[1-5]\d+)/.test(navigator.userAgent);

function isLeftMouseReleased(event) {
  if ("buttons" in event && isNotIEorIsIE10plus) {
    return !(event.buttons & 1);
  }

  if (isChrome15OrOpera15plus || isSafari6plus) {
    return event.which === 0;
  }

  return false;
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFRenderingQueue = exports.RenderingStates = void 0;
const CLEANUP_TIMEOUT = 30000;
const RenderingStates = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
};
exports.RenderingStates = RenderingStates;

class PDFRenderingQueue {
  constructor() {
    this.pdfViewer = null;
    this.pdfThumbnailViewer = null;
    this.onIdle = null;
    this.highestPriorityPage = null;
    this.idleTimeout = null;
    this.printing = false;
    this.isThumbnailViewEnabled = false;
  }

  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }

  setThumbnailViewer(pdfThumbnailViewer) {
    this.pdfThumbnailViewer = pdfThumbnailViewer;
  }

  isHighestPriority(view) {
    return this.highestPriorityPage === view.renderingId;
  }

  renderHighestPriority(currentlyVisiblePages) {
    if (this.idleTimeout) {
      clearTimeout(this.idleTimeout);
      this.idleTimeout = null;
    }

    if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
      return;
    }

    if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
      if (this.pdfThumbnailViewer.forceRendering()) {
        return;
      }
    }

    if (this.printing) {
      return;
    }

    if (this.onIdle) {
      this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
    }
  }

  getHighestPriority(visible, views, scrolledDown) {
    const visibleViews = visible.views;
    const numVisible = visibleViews.length;

    if (numVisible === 0) {
      return null;
    }

    for (let i = 0; i < numVisible; ++i) {
      const view = visibleViews[i].view;

      if (!this.isViewFinished(view)) {
        return view;
      }
    }

    if (scrolledDown) {
      const nextPageIndex = visible.last.id;

      if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
        return views[nextPageIndex];
      }
    } else {
      const previousPageIndex = visible.first.id - 2;

      if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
        return views[previousPageIndex];
      }
    }

    return null;
  }

  isViewFinished(view) {
    return view.renderingState === RenderingStates.FINISHED;
  }

  renderView(view) {
    switch (view.renderingState) {
      case RenderingStates.FINISHED:
        return false;

      case RenderingStates.PAUSED:
        this.highestPriorityPage = view.renderingId;
        view.resume();
        break;

      case RenderingStates.RUNNING:
        this.highestPriorityPage = view.renderingId;
        break;

      case RenderingStates.INITIAL:
        this.highestPriorityPage = view.renderingId;
        view.draw().finally(() => {
          this.renderHighestPriority();
        }).catch(reason => {
          console.error(`renderView: "${reason}"`);
        });
        break;
    }

    return true;
  }

}

exports.PDFRenderingQueue = PDFRenderingQueue;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFSidebar = exports.SidebarView = void 0;

var _ui_utils = __webpack_require__(2);

var _pdf_rendering_queue = __webpack_require__(8);

const UI_NOTIFICATION_CLASS = "pdfSidebarNotification";
const SidebarView = {
  UNKNOWN: -1,
  NONE: 0,
  THUMBS: 1,
  OUTLINE: 2,
  ATTACHMENTS: 3,
  LAYERS: 4
};
exports.SidebarView = SidebarView;

class PDFSidebar {
  constructor({
    elements,
    pdfViewer,
    pdfThumbnailViewer,
    eventBus,
    l10n = _ui_utils.NullL10n,
    disableNotification = false
  }) {
    this.isOpen = false;
    this.active = SidebarView.THUMBS;
    this.isInitialViewSet = false;
    this.onToggled = null;
    this.pdfViewer = pdfViewer;
    this.pdfThumbnailViewer = pdfThumbnailViewer;
    this.outerContainer = elements.outerContainer;
    this.viewerContainer = elements.viewerContainer;
    this.toggleButton = elements.toggleButton;
    this.thumbnailButton = elements.thumbnailButton;
    this.outlineButton = elements.outlineButton;
    this.attachmentsButton = elements.attachmentsButton;
    this.thumbnailView = elements.thumbnailView;
    this.outlineView = elements.outlineView;
    this.attachmentsView = elements.attachmentsView;
    this.eventBus = eventBus;
    this.l10n = l10n;
    this._disableNotification = disableNotification;

    this._addEventListeners();
  }

  reset() {
    this.isInitialViewSet = false;

    this._hideUINotification(null);

    this.switchView(SidebarView.THUMBS);
    this.outlineButton.disabled = false;
    this.attachmentsButton.disabled = false;
  }

  get visibleView() {
    return this.isOpen ? this.active : SidebarView.NONE;
  }

  get isThumbnailViewVisible() {
    return this.isOpen && this.active === SidebarView.THUMBS;
  }

  get isOutlineViewVisible() {
    return this.isOpen && this.active === SidebarView.OUTLINE;
  }

  get isAttachmentsViewVisible() {
    return this.isOpen && this.active === SidebarView.ATTACHMENTS;
  }

  setInitialView(view = SidebarView.NONE) {
    if (this.isInitialViewSet) {
      return;
    }

    this.isInitialViewSet = true;

    if (view === SidebarView.NONE || view === SidebarView.UNKNOWN) {
      this._dispatchEvent();

      return;
    }

    if (!this._switchView(view, true)) {
      this._dispatchEvent();
    }
  }

  switchView(view, forceOpen = false) {
    this._switchView(view, forceOpen);
  }

  _switchView(view, forceOpen = false) {
    const isViewChanged = view !== this.active;
    let shouldForceRendering = false;

    switch (view) {
      case SidebarView.NONE:
        if (this.isOpen) {
          this.close();
          return true;
        }

        return false;

      case SidebarView.THUMBS:
        if (this.isOpen && isViewChanged) {
          shouldForceRendering = true;
        }

        break;

      case SidebarView.OUTLINE:
        if (this.outlineButton.disabled) {
          return false;
        }

        break;

      case SidebarView.ATTACHMENTS:
        if (this.attachmentsButton.disabled) {
          return false;
        }

        break;

      default:
        console.error(`PDFSidebar._switchView: "${view}" is not a valid view.`);
        return false;
    }

    this.active = view;
    this.thumbnailButton.classList.toggle("toggled", view === SidebarView.THUMBS);
    this.outlineButton.classList.toggle("toggled", view === SidebarView.OUTLINE);
    this.attachmentsButton.classList.toggle("toggled", view === SidebarView.ATTACHMENTS);
    this.thumbnailView.classList.toggle("hidden", view !== SidebarView.THUMBS);
    this.outlineView.classList.toggle("hidden", view !== SidebarView.OUTLINE);
    this.attachmentsView.classList.toggle("hidden", view !== SidebarView.ATTACHMENTS);

    if (forceOpen && !this.isOpen) {
      this.open();
      return true;
    }

    if (shouldForceRendering) {
      this._updateThumbnailViewer();

      this._forceRendering();
    }

    if (isViewChanged) {
      this._dispatchEvent();
    }

    this._hideUINotification(this.active);

    return isViewChanged;
  }

  open() {
    if (this.isOpen) {
      return;
    }

    this.isOpen = true;
    this.toggleButton.classList.add("toggled");
    this.outerContainer.classList.add("sidebarMoving", "sidebarOpen");

    if (this.active === SidebarView.THUMBS) {
      this._updateThumbnailViewer();
    }

    this._forceRendering();

    this._dispatchEvent();

    this._hideUINotification(this.active);
  }

  close() {
    if (!this.isOpen) {
      return;
    }

    this.isOpen = false;
    this.toggleButton.classList.remove("toggled");
    this.outerContainer.classList.add("sidebarMoving");
    this.outerContainer.classList.remove("sidebarOpen");

    this._forceRendering();

    this._dispatchEvent();
  }

  toggle() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }

  _dispatchEvent() {
    this.eventBus.dispatch("sidebarviewchanged", {
      source: this,
      view: this.visibleView
    });
  }

  _forceRendering() {
    if (this.onToggled) {
      this.onToggled();
    } else {
      this.pdfViewer.forceRendering();
      this.pdfThumbnailViewer.forceRendering();
    }
  }

  _updateThumbnailViewer() {
    const {
      pdfViewer,
      pdfThumbnailViewer
    } = this;
    const pagesCount = pdfViewer.pagesCount;

    for (let pageIndex = 0; pageIndex < pagesCount; pageIndex++) {
      const pageView = pdfViewer.getPageView(pageIndex);

      if (pageView && pageView.renderingState === _pdf_rendering_queue.RenderingStates.FINISHED) {
        const thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex);
        thumbnailView.setImage(pageView);
      }
    }

    pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber);
  }

  _showUINotification(view) {
    if (this._disableNotification) {
      return;
    }

    this.l10n.get("toggle_sidebar_notification.title", null, "Toggle Sidebar (document contains outline/attachments)").then(msg => {
      this.toggleButton.title = msg;
    });

    if (!this.isOpen) {
      this.toggleButton.classList.add(UI_NOTIFICATION_CLASS);
    } else if (view === this.active) {
      return;
    }

    switch (view) {
      case SidebarView.OUTLINE:
        this.outlineButton.classList.add(UI_NOTIFICATION_CLASS);
        break;

      case SidebarView.ATTACHMENTS:
        this.attachmentsButton.classList.add(UI_NOTIFICATION_CLASS);
        break;
    }
  }

  _hideUINotification(view) {
    if (this._disableNotification) {
      return;
    }

    const removeNotification = sidebarView => {
      switch (sidebarView) {
        case SidebarView.OUTLINE:
          this.outlineButton.classList.remove(UI_NOTIFICATION_CLASS);
          break;

        case SidebarView.ATTACHMENTS:
          this.attachmentsButton.classList.remove(UI_NOTIFICATION_CLASS);
          break;
      }
    };

    if (!this.isOpen && view !== null) {
      return;
    }

    this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS);

    if (view !== null) {
      removeNotification(view);
      return;
    }

    for (view in SidebarView) {
      removeNotification(SidebarView[view]);
    }

    this.l10n.get("toggle_sidebar.title", null, "Toggle Sidebar").then(msg => {
      this.toggleButton.title = msg;
    });
  }

  _addEventListeners() {
    this.viewerContainer.addEventListener("transitionend", evt => {
      if (evt.target === this.viewerContainer) {
        this.outerContainer.classList.remove("sidebarMoving");
      }
    });
    this.toggleButton.addEventListener("click", () => {
      this.toggle();
    });
    this.thumbnailButton.addEventListener("click", () => {
      this.switchView(SidebarView.THUMBS);
    });
    this.outlineButton.addEventListener("click", () => {
      this.switchView(SidebarView.OUTLINE);
    });
    this.outlineButton.addEventListener("dblclick", () => {
      this.eventBus.dispatch("toggleoutlinetree", {
        source: this
      });
    });
    this.attachmentsButton.addEventListener("click", () => {
      this.switchView(SidebarView.ATTACHMENTS);
    });

    this.eventBus._on("outlineloaded", evt => {
      const outlineCount = evt.outlineCount;
      this.outlineButton.disabled = !outlineCount;

      if (outlineCount) {
        this._showUINotification(SidebarView.OUTLINE);
      } else if (this.active === SidebarView.OUTLINE) {
        this.switchView(SidebarView.THUMBS);
      }
    });

    this.eventBus._on("attachmentsloaded", evt => {
      if (evt.attachmentsCount) {
        this.attachmentsButton.disabled = false;

        this._showUINotification(SidebarView.ATTACHMENTS);

        return;
      }

      Promise.resolve().then(() => {
        if (this.attachmentsView.hasChildNodes()) {
          return;
        }

        this.attachmentsButton.disabled = true;

        if (this.active === SidebarView.ATTACHMENTS) {
          this.switchView(SidebarView.THUMBS);
        }
      });
    });

    this.eventBus._on("presentationmodechanged", evt => {
      if (!evt.active && !evt.switchInProgress && this.isThumbnailViewVisible) {
        this._updateThumbnailViewer();
      }
    });
  }

}

exports.PDFSidebar = PDFSidebar;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OverlayManager = void 0;

class OverlayManager {
  constructor() {
    this._overlays = {};
    this._active = null;
    this._keyDownBound = this._keyDown.bind(this);
  }

  get active() {
    return this._active;
  }

  async register(name, element, callerCloseMethod = null, canForceClose = false) {
    let container;

    if (!name || !element || !(container = element.parentNode)) {
      throw new Error("Not enough parameters.");
    } else if (this._overlays[name]) {
      throw new Error("The overlay is already registered.");
    }

    this._overlays[name] = {
      element,
      container,
      callerCloseMethod,
      canForceClose
    };
  }

  async unregister(name) {
    if (!this._overlays[name]) {
      throw new Error("The overlay does not exist.");
    } else if (this._active === name) {
      throw new Error("The overlay cannot be removed while it is active.");
    }

    delete this._overlays[name];
  }

  async open(name) {
    if (!this._overlays[name]) {
      throw new Error("The overlay does not exist.");
    } else if (this._active) {
      if (this._overlays[name].canForceClose) {
        this._closeThroughCaller();
      } else if (this._active === name) {
        throw new Error("The overlay is already active.");
      } else {
        throw new Error("Another overlay is currently active.");
      }
    }

    this._active = name;

    this._overlays[this._active].element.classList.remove("hidden");

    this._overlays[this._active].container.classList.remove("hidden");

    window.addEventListener("keydown", this._keyDownBound);
  }

  async close(name) {
    if (!this._overlays[name]) {
      throw new Error("The overlay does not exist.");
    } else if (!this._active) {
      throw new Error("The overlay is currently not active.");
    } else if (this._active !== name) {
      throw new Error("Another overlay is currently active.");
    }

    this._overlays[this._active].container.classList.add("hidden");

    this._overlays[this._active].element.classList.add("hidden");

    this._active = null;
    window.removeEventListener("keydown", this._keyDownBound);
  }

  _keyDown(evt) {
    if (this._active && evt.keyCode === 27) {
      this._closeThroughCaller();

      evt.preventDefault();
    }
  }

  _closeThroughCaller() {
    if (this._overlays[this._active].callerCloseMethod) {
      this._overlays[this._active].callerCloseMethod();
    }

    if (this._active) {
      this.close(this._active);
    }
  }

}

exports.OverlayManager = OverlayManager;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PasswordPrompt = void 0;

var _ui_utils = __webpack_require__(2);

var _pdfjsLib = __webpack_require__(5);

class PasswordPrompt {
  constructor(options, overlayManager, l10n = _ui_utils.NullL10n) {
    this.overlayName = options.overlayName;
    this.container = options.container;
    this.label = options.label;
    this.input = options.input;
    this.submitButton = options.submitButton;
    this.cancelButton = options.cancelButton;
    this.overlayManager = overlayManager;
    this.l10n = l10n;
    this.updateCallback = null;
    this.reason = null;
    this.submitButton.addEventListener("click", this.verify.bind(this));
    this.cancelButton.addEventListener("click", this.close.bind(this));
    this.input.addEventListener("keydown", e => {
      if (e.keyCode === 13) {
        this.verify();
      }
    });
    this.overlayManager.register(this.overlayName, this.container, this.close.bind(this), true);
  }

  open() {
    this.overlayManager.open(this.overlayName).then(() => {
      this.input.focus();
      let promptString;

      if (this.reason === _pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) {
        promptString = this.l10n.get("password_invalid", null, "Invalid password. Please try again.");
      } else {
        promptString = this.l10n.get("password_label", null, "Enter the password to open this PDF file.");
      }

      promptString.then(msg => {
        this.label.textContent = msg;
      });
    });
  }

  close() {
    this.overlayManager.close(this.overlayName).then(() => {
      this.input.value = "";
    });
  }

  verify() {
    const password = this.input.value;

    if (password && password.length > 0) {
      this.close();
      this.updateCallback(password);
    }
  }

  setUpdateCallback(updateCallback, reason) {
    this.updateCallback = updateCallback;
    this.reason = reason;
  }

}

exports.PasswordPrompt = PasswordPrompt;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFAttachmentViewer = void 0;

var _pdfjsLib = __webpack_require__(5);

class PDFAttachmentViewer {
  constructor({
    container,
    eventBus,
    downloadManager
  }) {
    this.container = container;
    this.eventBus = eventBus;
    this.downloadManager = downloadManager;
    this.reset();

    this.eventBus._on("fileattachmentannotation", this._appendAttachment.bind(this));
  }

  reset(keepRenderedCapability = false) {
    this.attachments = null;
    this.container.textContent = "";

    if (!keepRenderedCapability) {
      this._renderedCapability = (0, _pdfjsLib.createPromiseCapability)();
    }
  }

  _dispatchEvent(attachmentsCount) {
    this._renderedCapability.resolve();

    this.eventBus.dispatch("attachmentsloaded", {
      source: this,
      attachmentsCount
    });
  }

  _bindPdfLink(button, content, filename) {
    let blobUrl;

    button.onclick = () => {
      if (!blobUrl) {
        blobUrl = URL.createObjectURL(new Blob([content], {
          type: "application/pdf"
        }));
      }

      let viewerUrl;
      viewerUrl = "?file=" + encodeURIComponent(blobUrl + "#" + filename);

      try {
        window.open(viewerUrl);
      } catch (ex) {
        console.error(`_bindPdfLink: ${ex}`);
        URL.revokeObjectURL(blobUrl);
        blobUrl = null;
        this.downloadManager.downloadData(content, filename, "application/pdf");
      }

      return false;
    };
  }

  _bindLink(button, content, filename) {
    button.onclick = () => {
      this.downloadManager.downloadData(content, filename, "");
      return false;
    };
  }

  render({
    attachments,
    keepRenderedCapability = false
  }) {
    let attachmentsCount = 0;

    if (this.attachments) {
      this.reset(keepRenderedCapability === true);
    }

    this.attachments = attachments || null;

    if (!attachments) {
      this._dispatchEvent(attachmentsCount);

      return;
    }

    const names = Object.keys(attachments).sort(function (a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    });
    attachmentsCount = names.length;

    for (let i = 0; i < attachmentsCount; i++) {
      const item = attachments[names[i]];
      const filename = (0, _pdfjsLib.removeNullCharacters)((0, _pdfjsLib.getFilenameFromUrl)(item.filename));
      const div = document.createElement("div");
      div.className = "attachmentsItem";
      const button = document.createElement("button");
      button.textContent = filename;

      if (/\.pdf$/i.test(filename) && !this.downloadManager.disableCreateObjectURL) {
        this._bindPdfLink(button, item.content, filename);
      } else {
        this._bindLink(button, item.content, filename);
      }

      div.appendChild(button);
      this.container.appendChild(div);
    }

    this._dispatchEvent(attachmentsCount);
  }

  _appendAttachment({
    id,
    filename,
    content
  }) {
    this._renderedCapability.promise.then(() => {
      let attachments = this.attachments;

      if (!attachments) {
        attachments = Object.create(null);
      } else {
        for (const name in attachments) {
          if (id === name) {
            return;
          }
        }
      }

      attachments[id] = {
        filename,
        content
      };
      this.render({
        attachments,
        keepRenderedCapability: true
      });
    });
  }

}

exports.PDFAttachmentViewer = PDFAttachmentViewer;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFDocumentProperties = void 0;

var _pdfjsLib = __webpack_require__(5);

var _ui_utils = __webpack_require__(2);

const DEFAULT_FIELD_CONTENT = "-";
const NON_METRIC_LOCALES = ["en-us", "en-lr", "my"];
const US_PAGE_NAMES = {
  "8.5x11": "Letter",
  "8.5x14": "Legal"
};
const METRIC_PAGE_NAMES = {
  "297x420": "A3",
  "210x297": "A4"
};

function getPageName(size, isPortrait, pageNames) {
  const width = isPortrait ? size.width : size.height;
  const height = isPortrait ? size.height : size.width;
  return pageNames[`${width}x${height}`];
}

class PDFDocumentProperties {
  constructor({
    overlayName,
    fields,
    container,
    closeButton
  }, overlayManager, eventBus, l10n = _ui_utils.NullL10n) {
    this.overlayName = overlayName;
    this.fields = fields;
    this.container = container;
    this.overlayManager = overlayManager;
    this.l10n = l10n;

    this._reset();

    closeButton.addEventListener("click", this.close.bind(this));
    this.overlayManager.register(this.overlayName, this.container, this.close.bind(this));

    eventBus._on("pagechanging", evt => {
      this._currentPageNumber = evt.pageNumber;
    });

    eventBus._on("rotationchanging", evt => {
      this._pagesRotation = evt.pagesRotation;
    });

    this._isNonMetricLocale = true;
    l10n.getLanguage().then(locale => {
      this._isNonMetricLocale = NON_METRIC_LOCALES.includes(locale);
    });
  }

  open() {
    const freezeFieldData = data => {
      Object.defineProperty(this, "fieldData", {
        value: Object.freeze(data),
        writable: false,
        enumerable: true,
        configurable: true
      });
    };

    Promise.all([this.overlayManager.open(this.overlayName), this._dataAvailableCapability.promise]).then(() => {
      const currentPageNumber = this._currentPageNumber;
      const pagesRotation = this._pagesRotation;

      if (this.fieldData && currentPageNumber === this.fieldData._currentPageNumber && pagesRotation === this.fieldData._pagesRotation) {
        this._updateUI();

        return;
      }

      this.pdfDocument.getMetadata().then(({
        info,
        metadata,
        contentDispositionFilename
      }) => {
        return Promise.all([info, metadata, contentDispositionFilename || (0, _ui_utils.getPDFFileNameFromURL)(this.url), this._parseFileSize(this.maybeFileSize), this._parseDate(info.CreationDate), this._parseDate(info.ModDate), this.pdfDocument.getPage(currentPageNumber).then(pdfPage => {
          return this._parsePageSize((0, _ui_utils.getPageSizeInches)(pdfPage), pagesRotation);
        }), this._parseLinearization(info.IsLinearized)]);
      }).then(([info, metadata, fileName, fileSize, creationDate, modDate, pageSize, isLinearized]) => {
        freezeFieldData({
          fileName,
          fileSize,
          title: info.Title,
          author: info.Author,
          subject: info.Subject,
          keywords: info.Keywords,
          creationDate,
          modificationDate: modDate,
          creator: info.Creator,
          producer: info.Producer,
          version: info.PDFFormatVersion,
          pageCount: this.pdfDocument.numPages,
          pageSize,
          linearized: isLinearized,
          _currentPageNumber: currentPageNumber,
          _pagesRotation: pagesRotation
        });

        this._updateUI();

        return this.pdfDocument.getDownloadInfo();
      }).then(({
        length
      }) => {
        this.maybeFileSize = length;
        return this._parseFileSize(length);
      }).then(fileSize => {
        if (fileSize === this.fieldData.fileSize) {
          return;
        }

        const data = Object.assign(Object.create(null), this.fieldData);
        data.fileSize = fileSize;
        freezeFieldData(data);

        this._updateUI();
      });
    });
  }

  close() {
    this.overlayManager.close(this.overlayName);
  }

  setDocument(pdfDocument, url = null) {
    if (this.pdfDocument) {
      this._reset();

      this._updateUI(true);
    }

    if (!pdfDocument) {
      return;
    }

    this.pdfDocument = pdfDocument;
    this.url = url;

    this._dataAvailableCapability.resolve();
  }

  setFileSize(fileSize) {
    if (Number.isInteger(fileSize) && fileSize > 0) {
      this.maybeFileSize = fileSize;
    }
  }

  _reset() {
    this.pdfDocument = null;
    this.url = null;
    this.maybeFileSize = 0;
    delete this.fieldData;
    this._dataAvailableCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._currentPageNumber = 1;
    this._pagesRotation = 0;
  }

  _updateUI(reset = false) {
    if (reset || !this.fieldData) {
      for (const id in this.fields) {
        this.fields[id].textContent = DEFAULT_FIELD_CONTENT;
      }

      return;
    }

    if (this.overlayManager.active !== this.overlayName) {
      return;
    }

    for (const id in this.fields) {
      const content = this.fieldData[id];
      this.fields[id].textContent = content || content === 0 ? content : DEFAULT_FIELD_CONTENT;
    }
  }

  async _parseFileSize(fileSize = 0) {
    const kb = fileSize / 1024;

    if (!kb) {
      return undefined;
    } else if (kb < 1024) {
      return this.l10n.get("document_properties_kb", {
        size_kb: (+kb.toPrecision(3)).toLocaleString(),
        size_b: fileSize.toLocaleString()
      }, "{{size_kb}} KB ({{size_b}} bytes)");
    }

    return this.l10n.get("document_properties_mb", {
      size_mb: (+(kb / 1024).toPrecision(3)).toLocaleString(),
      size_b: fileSize.toLocaleString()
    }, "{{size_mb}} MB ({{size_b}} bytes)");
  }

  async _parsePageSize(pageSizeInches, pagesRotation) {
    if (!pageSizeInches) {
      return undefined;
    }

    if (pagesRotation % 180 !== 0) {
      pageSizeInches = {
        width: pageSizeInches.height,
        height: pageSizeInches.width
      };
    }

    const isPortrait = (0, _ui_utils.isPortraitOrientation)(pageSizeInches);
    let sizeInches = {
      width: Math.round(pageSizeInches.width * 100) / 100,
      height: Math.round(pageSizeInches.height * 100) / 100
    };
    let sizeMillimeters = {
      width: Math.round(pageSizeInches.width * 25.4 * 10) / 10,
      height: Math.round(pageSizeInches.height * 25.4 * 10) / 10
    };
    let pageName = null;
    let rawName = getPageName(sizeInches, isPortrait, US_PAGE_NAMES) || getPageName(sizeMillimeters, isPortrait, METRIC_PAGE_NAMES);

    if (!rawName && !(Number.isInteger(sizeMillimeters.width) && Number.isInteger(sizeMillimeters.height))) {
      const exactMillimeters = {
        width: pageSizeInches.width * 25.4,
        height: pageSizeInches.height * 25.4
      };
      const intMillimeters = {
        width: Math.round(sizeMillimeters.width),
        height: Math.round(sizeMillimeters.height)
      };

      if (Math.abs(exactMillimeters.width - intMillimeters.width) < 0.1 && Math.abs(exactMillimeters.height - intMillimeters.height) < 0.1) {
        rawName = getPageName(intMillimeters, isPortrait, METRIC_PAGE_NAMES);

        if (rawName) {
          sizeInches = {
            width: Math.round(intMillimeters.width / 25.4 * 100) / 100,
            height: Math.round(intMillimeters.height / 25.4 * 100) / 100
          };
          sizeMillimeters = intMillimeters;
        }
      }
    }

    if (rawName) {
      pageName = this.l10n.get("document_properties_page_size_name_" + rawName.toLowerCase(), null, rawName);
    }

    return Promise.all([this._isNonMetricLocale ? sizeInches : sizeMillimeters, this.l10n.get("document_properties_page_size_unit_" + (this._isNonMetricLocale ? "inches" : "millimeters"), null, this._isNonMetricLocale ? "in" : "mm"), pageName, this.l10n.get("document_properties_page_size_orientation_" + (isPortrait ? "portrait" : "landscape"), null, isPortrait ? "portrait" : "landscape")]).then(([{
      width,
      height
    }, unit, name, orientation]) => {
      return this.l10n.get("document_properties_page_size_dimension_" + (name ? "name_" : "") + "string", {
        width: width.toLocaleString(),
        height: height.toLocaleString(),
        unit,
        name,
        orientation
      }, "{{width}} × {{height}} {{unit}} (" + (name ? "{{name}}, " : "") + "{{orientation}})");
    });
  }

  async _parseDate(inputDate) {
    const dateObject = _pdfjsLib.PDFDateString.toDateObject(inputDate);

    if (!dateObject) {
      return undefined;
    }

    return this.l10n.get("document_properties_date_string", {
      date: dateObject.toLocaleDateString(),
      time: dateObject.toLocaleTimeString()
    }, "{{date}}, {{time}}");
  }

  _parseLinearization(isLinearized) {
    return this.l10n.get("document_properties_linearized_" + (isLinearized ? "yes" : "no"), null, isLinearized ? "Yes" : "No");
  }

}

exports.PDFDocumentProperties = PDFDocumentProperties;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFFindBar = void 0;

var _pdf_find_controller = __webpack_require__(15);

var _ui_utils = __webpack_require__(2);

const MATCHES_COUNT_LIMIT = 1000;

class PDFFindBar {
  constructor(options, eventBus, l10n = _ui_utils.NullL10n) {
    this.opened = false;
    this.bar = options.bar || null;
    this.toggleButton = options.toggleButton || null;
    this.findField = options.findField || null;
    this.highlightAll = options.highlightAllCheckbox || null;
    this.caseSensitive = options.caseSensitiveCheckbox || null;
    this.entireWord = options.entireWordCheckbox || null;
    this.findMsg = options.findMsg || null;
    this.findResultsCount = options.findResultsCount || null;
    this.findPreviousButton = options.findPreviousButton || null;
    this.findNextButton = options.findNextButton || null;
    this.eventBus = eventBus;
    this.l10n = l10n;
    this.toggleButton.addEventListener("click", () => {
      this.toggle();
    });
    this.findField.addEventListener("input", () => {
      this.dispatchEvent("");
    });
    this.bar.addEventListener("keydown", e => {
      switch (e.keyCode) {
        case 13:
          if (e.target === this.findField) {
            this.dispatchEvent("again", e.shiftKey);
          }

          break;

        case 27:
          this.close();
          break;
      }
    });
    this.findPreviousButton.addEventListener("click", () => {
      this.dispatchEvent("again", true);
    });
    this.findNextButton.addEventListener("click", () => {
      this.dispatchEvent("again", false);
    });
    this.highlightAll.addEventListener("click", () => {
      this.dispatchEvent("highlightallchange");
    });
    this.caseSensitive.addEventListener("click", () => {
      this.dispatchEvent("casesensitivitychange");
    });
    this.entireWord.addEventListener("click", () => {
      this.dispatchEvent("entirewordchange");
    });

    this.eventBus._on("resize", this._adjustWidth.bind(this));
  }

  reset() {
    this.updateUIState();
  }

  dispatchEvent(type, findPrev) {
    this.eventBus.dispatch("find", {
      source: this,
      type,
      query: this.findField.value,
      phraseSearch: true,
      caseSensitive: this.caseSensitive.checked,
      entireWord: this.entireWord.checked,
      highlightAll: this.highlightAll.checked,
      findPrevious: findPrev
    });
  }

  updateUIState(state, previous, matchesCount) {
    let notFound = false;
    let findMsg = "";
    let status = "";

    switch (state) {
      case _pdf_find_controller.FindState.FOUND:
        break;

      case _pdf_find_controller.FindState.PENDING:
        status = "pending";
        break;

      case _pdf_find_controller.FindState.NOT_FOUND:
        findMsg = this.l10n.get("find_not_found", null, "Phrase not found");
        notFound = true;
        break;

      case _pdf_find_controller.FindState.WRAPPED:
        if (previous) {
          findMsg = this.l10n.get("find_reached_top", null, "Reached top of document, continued from bottom");
        } else {
          findMsg = this.l10n.get("find_reached_bottom", null, "Reached end of document, continued from top");
        }

        break;
    }

    this.findField.classList.toggle("notFound", notFound);
    this.findField.setAttribute("data-status", status);
    Promise.resolve(findMsg).then(msg => {
      this.findMsg.textContent = msg;

      this._adjustWidth();
    });
    this.updateResultsCount(matchesCount);
  }

  updateResultsCount({
    current = 0,
    total = 0
  } = {}) {
    if (!this.findResultsCount) {
      return;
    }

    const limit = MATCHES_COUNT_LIMIT;
    let matchesCountMsg = "";

    if (total > 0) {
      if (total > limit) {
        matchesCountMsg = this.l10n.get("find_match_count_limit", {
          limit
        }, "More than {{limit}} match" + (limit !== 1 ? "es" : ""));
      } else {
        matchesCountMsg = this.l10n.get("find_match_count", {
          current,
          total
        }, "{{current}} of {{total}} match" + (total !== 1 ? "es" : ""));
      }
    }

    Promise.resolve(matchesCountMsg).then(msg => {
      this.findResultsCount.textContent = msg;
      this.findResultsCount.classList.toggle("hidden", !total);

      this._adjustWidth();
    });
  }

  open() {
    if (!this.opened) {
      this.opened = true;
      this.toggleButton.classList.add("toggled");
      this.bar.classList.remove("hidden");
    }

    this.findField.select();
    this.findField.focus();

    this._adjustWidth();
  }

  close() {
    if (!this.opened) {
      return;
    }

    this.opened = false;
    this.toggleButton.classList.remove("toggled");
    this.bar.classList.add("hidden");
    this.eventBus.dispatch("findbarclose", {
      source: this
    });
  }

  toggle() {
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }

  _adjustWidth() {
    if (!this.opened) {
      return;
    }

    this.bar.classList.remove("wrapContainers");
    const findbarHeight = this.bar.clientHeight;
    const inputContainerHeight = this.bar.firstElementChild.clientHeight;

    if (findbarHeight > inputContainerHeight) {
      this.bar.classList.add("wrapContainers");
    }
  }

}

exports.PDFFindBar = PDFFindBar;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFFindController = exports.FindState = void 0;

var _pdfjsLib = __webpack_require__(5);

var _pdf_find_utils = __webpack_require__(16);

var _ui_utils = __webpack_require__(2);

const FindState = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
};
exports.FindState = FindState;
const FIND_TIMEOUT = 250;
const MATCH_SCROLL_OFFSET_TOP = -50;
const MATCH_SCROLL_OFFSET_LEFT = -400;
const CHARACTERS_TO_NORMALIZE = {
  "\u2018": "'",
  "\u2019": "'",
  "\u201A": "'",
  "\u201B": "'",
  "\u201C": '"',
  "\u201D": '"',
  "\u201E": '"',
  "\u201F": '"',
  "\u00BC": "1/4",
  "\u00BD": "1/2",
  "\u00BE": "3/4"
};
let normalizationRegex = null;

function normalize(text) {
  if (!normalizationRegex) {
    const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
    normalizationRegex = new RegExp(`[${replace}]`, "g");
  }

  return text.replace(normalizationRegex, function (ch) {
    return CHARACTERS_TO_NORMALIZE[ch];
  });
}

class PDFFindController {
  constructor({
    linkService,
    eventBus
  }) {
    this._linkService = linkService;
    this._eventBus = eventBus;

    this._reset();

    eventBus._on("findbarclose", this._onFindBarClose.bind(this));
  }

  get highlightMatches() {
    return this._highlightMatches;
  }

  get pageMatches() {
    return this._pageMatches;
  }

  get pageMatchesLength() {
    return this._pageMatchesLength;
  }

  get selected() {
    return this._selected;
  }

  get state() {
    return this._state;
  }

  setDocument(pdfDocument) {
    if (this._pdfDocument) {
      this._reset();
    }

    if (!pdfDocument) {
      return;
    }

    this._pdfDocument = pdfDocument;

    this._firstPageCapability.resolve();
  }

  executeCommand(cmd, state) {
    if (!state) {
      return;
    }

    const pdfDocument = this._pdfDocument;

    if (this._state === null || this._shouldDirtyMatch(cmd, state)) {
      this._dirtyMatch = true;
    }

    this._state = state;

    if (cmd !== "findhighlightallchange") {
      this._updateUIState(FindState.PENDING);
    }

    this._firstPageCapability.promise.then(() => {
      if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
        return;
      }

      this._extractText();

      const findbarClosed = !this._highlightMatches;
      const pendingTimeout = !!this._findTimeout;

      if (this._findTimeout) {
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
      }

      if (cmd === "find") {
        this._findTimeout = setTimeout(() => {
          this._nextMatch();

          this._findTimeout = null;
        }, FIND_TIMEOUT);
      } else if (this._dirtyMatch) {
        this._nextMatch();
      } else if (cmd === "findagain") {
        this._nextMatch();

        if (findbarClosed && this._state.highlightAll) {
          this._updateAllPages();
        }
      } else if (cmd === "findhighlightallchange") {
        if (pendingTimeout) {
          this._nextMatch();
        } else {
          this._highlightMatches = true;
        }

        this._updateAllPages();
      } else {
        this._nextMatch();
      }
    });
  }

  scrollMatchIntoView({
    element = null,
    pageIndex = -1,
    matchIndex = -1
  }) {
    if (!this._scrollMatches || !element) {
      return;
    } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
      return;
    } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
      return;
    }

    this._scrollMatches = false;
    const spot = {
      top: MATCH_SCROLL_OFFSET_TOP,
      left: MATCH_SCROLL_OFFSET_LEFT
    };
    (0, _ui_utils.scrollIntoView)(element, spot, true);
  }

  _reset() {
    this._highlightMatches = false;
    this._scrollMatches = false;
    this._pdfDocument = null;
    this._pageMatches = [];
    this._pageMatchesLength = [];
    this._state = null;
    this._selected = {
      pageIdx: -1,
      matchIdx: -1
    };
    this._offset = {
      pageIdx: null,
      matchIdx: null,
      wrapped: false
    };
    this._extractTextPromises = [];
    this._pageContents = [];
    this._matchesCountTotal = 0;
    this._pagesToSearch = null;
    this._pendingFindMatches = Object.create(null);
    this._resumePageIdx = null;
    this._dirtyMatch = false;
    clearTimeout(this._findTimeout);
    this._findTimeout = null;
    this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
  }

  get _query() {
    if (this._state.query !== this._rawQuery) {
      this._rawQuery = this._state.query;
      this._normalizedQuery = normalize(this._state.query);
    }

    return this._normalizedQuery;
  }

  _shouldDirtyMatch(cmd, state) {
    if (state.query !== this._state.query) {
      return true;
    }

    switch (cmd) {
      case "findagain":
        const pageNumber = this._selected.pageIdx + 1;
        const linkService = this._linkService;

        if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
          return true;
        }

        return false;

      case "findhighlightallchange":
        return false;
    }

    return true;
  }

  _prepareMatches(matchesWithLength, matches, matchesLength) {
    function isSubTerm(currentIndex) {
      const currentElem = matchesWithLength[currentIndex];
      const nextElem = matchesWithLength[currentIndex + 1];

      if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {
        currentElem.skipped = true;
        return true;
      }

      for (let i = currentIndex - 1; i >= 0; i--) {
        const prevElem = matchesWithLength[i];

        if (prevElem.skipped) {
          continue;
        }

        if (prevElem.match + prevElem.matchLength < currentElem.match) {
          break;
        }

        if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {
          currentElem.skipped = true;
          return true;
        }
      }

      return false;
    }

    matchesWithLength.sort(function (a, b) {
      return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;
    });

    for (let i = 0, len = matchesWithLength.length; i < len; i++) {
      if (isSubTerm(i)) {
        continue;
      }

      matches.push(matchesWithLength[i].match);
      matchesLength.push(matchesWithLength[i].matchLength);
    }
  }

  _isEntireWord(content, startIdx, length) {
    if (startIdx > 0) {
      const first = content.charCodeAt(startIdx);
      const limit = content.charCodeAt(startIdx - 1);

      if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
        return false;
      }
    }

    const endIdx = startIdx + length - 1;

    if (endIdx < content.length - 1) {
      const last = content.charCodeAt(endIdx);
      const limit = content.charCodeAt(endIdx + 1);

      if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) {
        return false;
      }
    }

    return true;
  }

  _calculatePhraseMatch(query, pageIndex, pageContent, entireWord) {
    const matches = [];
    const queryLen = query.length;
    let matchIdx = -queryLen;

    while (true) {
      matchIdx = pageContent.indexOf(query, matchIdx + queryLen);

      if (matchIdx === -1) {
        break;
      }

      if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {
        continue;
      }

      matches.push(matchIdx);
    }

    this._pageMatches[pageIndex] = matches;
  }

  _calculateWordMatch(query, pageIndex, pageContent, entireWord) {
    const matchesWithLength = [];
    const queryArray = query.match(/\S+/g);

    for (let i = 0, len = queryArray.length; i < len; i++) {
      const subquery = queryArray[i];
      const subqueryLen = subquery.length;
      let matchIdx = -subqueryLen;

      while (true) {
        matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);

        if (matchIdx === -1) {
          break;
        }

        if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) {
          continue;
        }

        matchesWithLength.push({
          match: matchIdx,
          matchLength: subqueryLen,
          skipped: false
        });
      }
    }

    this._pageMatchesLength[pageIndex] = [];
    this._pageMatches[pageIndex] = [];

    this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]);
  }

  _calculateMatch(pageIndex) {
    let pageContent = this._pageContents[pageIndex];
    let query = this._query;
    const {
      caseSensitive,
      entireWord,
      phraseSearch
    } = this._state;

    if (query.length === 0) {
      return;
    }

    if (!caseSensitive) {
      pageContent = pageContent.toLowerCase();
      query = query.toLowerCase();
    }

    if (phraseSearch) {
      this._calculatePhraseMatch(query, pageIndex, pageContent, entireWord);
    } else {
      this._calculateWordMatch(query, pageIndex, pageContent, entireWord);
    }

    if (this._state.highlightAll) {
      this._updatePage(pageIndex);
    }

    if (this._resumePageIdx === pageIndex) {
      this._resumePageIdx = null;

      this._nextPageMatch();
    }

    const pageMatchesCount = this._pageMatches[pageIndex].length;

    if (pageMatchesCount > 0) {
      this._matchesCountTotal += pageMatchesCount;

      this._updateUIResultsCount();
    }
  }

  _extractText() {
    if (this._extractTextPromises.length > 0) {
      return;
    }

    let promise = Promise.resolve();

    for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
      const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
      this._extractTextPromises[i] = extractTextCapability.promise;
      promise = promise.then(() => {
        return this._pdfDocument.getPage(i + 1).then(pdfPage => {
          return pdfPage.getTextContent({
            normalizeWhitespace: true
          });
        }).then(textContent => {
          const textItems = textContent.items;
          const strBuf = [];

          for (let j = 0, jj = textItems.length; j < jj; j++) {
            strBuf.push(textItems[j].str);
          }

          this._pageContents[i] = normalize(strBuf.join(""));
          extractTextCapability.resolve(i);
        }, reason => {
          console.error(`Unable to get text content for page ${i + 1}`, reason);
          this._pageContents[i] = "";
          extractTextCapability.resolve(i);
        });
      });
    }
  }

  _updatePage(index) {
    if (this._scrollMatches && this._selected.pageIdx === index) {
      this._linkService.page = index + 1;
    }

    this._eventBus.dispatch("updatetextlayermatches", {
      source: this,
      pageIndex: index
    });
  }

  _updateAllPages() {
    this._eventBus.dispatch("updatetextlayermatches", {
      source: this,
      pageIndex: -1
    });
  }

  _nextMatch() {
    const previous = this._state.findPrevious;
    const currentPageIndex = this._linkService.page - 1;
    const numPages = this._linkService.pagesCount;
    this._highlightMatches = true;

    if (this._dirtyMatch) {
      this._dirtyMatch = false;
      this._selected.pageIdx = this._selected.matchIdx = -1;
      this._offset.pageIdx = currentPageIndex;
      this._offset.matchIdx = null;
      this._offset.wrapped = false;
      this._resumePageIdx = null;
      this._pageMatches.length = 0;
      this._pageMatchesLength.length = 0;
      this._matchesCountTotal = 0;

      this._updateAllPages();

      for (let i = 0; i < numPages; i++) {
        if (this._pendingFindMatches[i] === true) {
          continue;
        }

        this._pendingFindMatches[i] = true;

        this._extractTextPromises[i].then(pageIdx => {
          delete this._pendingFindMatches[pageIdx];

          this._calculateMatch(pageIdx);
        });
      }
    }

    if (this._query === "") {
      this._updateUIState(FindState.FOUND);

      return;
    }

    if (this._resumePageIdx) {
      return;
    }

    const offset = this._offset;
    this._pagesToSearch = numPages;

    if (offset.matchIdx !== null) {
      const numPageMatches = this._pageMatches[offset.pageIdx].length;

      if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
        offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;

        this._updateMatch(true);

        return;
      }

      this._advanceOffsetPage(previous);
    }

    this._nextPageMatch();
  }

  _matchesReady(matches) {
    const offset = this._offset;
    const numMatches = matches.length;
    const previous = this._state.findPrevious;

    if (numMatches) {
      offset.matchIdx = previous ? numMatches - 1 : 0;

      this._updateMatch(true);

      return true;
    }

    this._advanceOffsetPage(previous);

    if (offset.wrapped) {
      offset.matchIdx = null;

      if (this._pagesToSearch < 0) {
        this._updateMatch(false);

        return true;
      }
    }

    return false;
  }

  _nextPageMatch() {
    if (this._resumePageIdx !== null) {
      console.error("There can only be one pending page.");
    }

    let matches = null;

    do {
      const pageIdx = this._offset.pageIdx;
      matches = this._pageMatches[pageIdx];

      if (!matches) {
        this._resumePageIdx = pageIdx;
        break;
      }
    } while (!this._matchesReady(matches));
  }

  _advanceOffsetPage(previous) {
    const offset = this._offset;
    const numPages = this._linkService.pagesCount;
    offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
    offset.matchIdx = null;
    this._pagesToSearch--;

    if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
      offset.pageIdx = previous ? numPages - 1 : 0;
      offset.wrapped = true;
    }
  }

  _updateMatch(found = false) {
    let state = FindState.NOT_FOUND;
    const wrapped = this._offset.wrapped;
    this._offset.wrapped = false;

    if (found) {
      const previousPage = this._selected.pageIdx;
      this._selected.pageIdx = this._offset.pageIdx;
      this._selected.matchIdx = this._offset.matchIdx;
      state = wrapped ? FindState.WRAPPED : FindState.FOUND;

      if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
        this._updatePage(previousPage);
      }
    }

    this._updateUIState(state, this._state.findPrevious);

    if (this._selected.pageIdx !== -1) {
      this._scrollMatches = true;

      this._updatePage(this._selected.pageIdx);
    }
  }

  _onFindBarClose(evt) {
    const pdfDocument = this._pdfDocument;

    this._firstPageCapability.promise.then(() => {
      if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
        return;
      }

      if (this._findTimeout) {
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
      }

      if (this._resumePageIdx) {
        this._resumePageIdx = null;
        this._dirtyMatch = true;
      }

      this._updateUIState(FindState.FOUND);

      this._highlightMatches = false;

      this._updateAllPages();
    });
  }

  _requestMatchesCount() {
    const {
      pageIdx,
      matchIdx
    } = this._selected;
    let current = 0,
        total = this._matchesCountTotal;

    if (matchIdx !== -1) {
      for (let i = 0; i < pageIdx; i++) {
        current += this._pageMatches[i] && this._pageMatches[i].length || 0;
      }

      current += matchIdx + 1;
    }

    if (current < 1 || current > total) {
      current = total = 0;
    }

    return {
      current,
      total
    };
  }

  _updateUIResultsCount() {
    this._eventBus.dispatch("updatefindmatchescount", {
      source: this,
      matchesCount: this._requestMatchesCount()
    });
  }

  _updateUIState(state, previous) {
    this._eventBus.dispatch("updatefindcontrolstate", {
      source: this,
      state,
      previous,
      matchesCount: this._requestMatchesCount()
    });
  }

}

exports.PDFFindController = PDFFindController;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCharacterType = getCharacterType;
exports.CharacterType = void 0;
const CharacterType = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
exports.CharacterType = CharacterType;

function isAlphabeticalScript(charCode) {
  return charCode < 0x2e80;
}

function isAscii(charCode) {
  return (charCode & 0xff80) === 0;
}

function isAsciiAlpha(charCode) {
  return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;
}

function isAsciiDigit(charCode) {
  return charCode >= 0x30 && charCode <= 0x39;
}

function isAsciiSpace(charCode) {
  return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;
}

function isHan(charCode) {
  return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;
}

function isKatakana(charCode) {
  return charCode >= 0x30a0 && charCode <= 0x30ff;
}

function isHiragana(charCode) {
  return charCode >= 0x3040 && charCode <= 0x309f;
}

function isHalfwidthKatakana(charCode) {
  return charCode >= 0xff60 && charCode <= 0xff9f;
}

function isThai(charCode) {
  return (charCode & 0xff80) === 0x0e00;
}

function getCharacterType(charCode) {
  if (isAlphabeticalScript(charCode)) {
    if (isAscii(charCode)) {
      if (isAsciiSpace(charCode)) {
        return CharacterType.SPACE;
      } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {
        return CharacterType.ALPHA_LETTER;
      }

      return CharacterType.PUNCT;
    } else if (isThai(charCode)) {
      return CharacterType.THAI_LETTER;
    } else if (charCode === 0xa0) {
      return CharacterType.SPACE;
    }

    return CharacterType.ALPHA_LETTER;
  }

  if (isHan(charCode)) {
    return CharacterType.HAN_LETTER;
  } else if (isKatakana(charCode)) {
    return CharacterType.KATAKANA_LETTER;
  } else if (isHiragana(charCode)) {
    return CharacterType.HIRAGANA_LETTER;
  } else if (isHalfwidthKatakana(charCode)) {
    return CharacterType.HALFWIDTH_KATAKANA_LETTER;
  }

  return CharacterType.ALPHA_LETTER;
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDestHashesEqual = isDestHashesEqual;
exports.isDestArraysEqual = isDestArraysEqual;
exports.PDFHistory = void 0;

var _ui_utils = __webpack_require__(2);

const HASH_CHANGE_TIMEOUT = 1000;
const POSITION_UPDATED_THRESHOLD = 50;
const UPDATE_VIEWAREA_TIMEOUT = 1000;

function getCurrentHash() {
  return document.location.hash;
}

class PDFHistory {
  constructor({
    linkService,
    eventBus
  }) {
    this.linkService = linkService;
    this.eventBus = eventBus;
    this._initialized = false;
    this._fingerprint = "";
    this.reset();
    this._boundEvents = null;
    this._isViewerInPresentationMode = false;

    this.eventBus._on("presentationmodechanged", evt => {
      this._isViewerInPresentationMode = evt.active || evt.switchInProgress;
    });

    this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = false;

      const onPagesLoaded = evt => {
        this.eventBus._off("pagesloaded", onPagesLoaded);

        this._isPagesLoaded = !!evt.pagesCount;
      };

      this.eventBus._on("pagesloaded", onPagesLoaded);
    });
  }

  initialize({
    fingerprint,
    resetHistory = false,
    updateUrl = false
  }) {
    if (!fingerprint || typeof fingerprint !== "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }

    if (this._initialized) {
      this.reset();
    }

    const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
    this._fingerprint = fingerprint;
    this._updateUrl = updateUrl === true;
    this._initialized = true;

    this._bindEvents();

    const state = window.history.state;
    this._popStateInProgress = false;
    this._blockHashChange = 0;
    this._currentHash = getCurrentHash();
    this._numPositionUpdates = 0;
    this._uid = this._maxUid = 0;
    this._destination = null;
    this._position = null;

    if (!this._isValidState(state, true) || resetHistory) {
      const {
        hash,
        page,
        rotation
      } = this._parseCurrentHash(true);

      if (!hash || reInitialized || resetHistory) {
        this._pushOrReplaceState(null, true);

        return;
      }

      this._pushOrReplaceState({
        hash,
        page,
        rotation
      }, true);

      return;
    }

    const destination = state.destination;

    this._updateInternalState(destination, state.uid, true);

    if (this._uid > this._maxUid) {
      this._maxUid = this._uid;
    }

    if (destination.rotation !== undefined) {
      this._initialRotation = destination.rotation;
    }

    if (destination.dest) {
      this._initialBookmark = JSON.stringify(destination.dest);
      this._destination.page = null;
    } else if (destination.hash) {
      this._initialBookmark = destination.hash;
    } else if (destination.page) {
      this._initialBookmark = `page=${destination.page}`;
    }
  }

  reset() {
    if (this._initialized) {
      this._pageHide();

      this._initialized = false;

      this._unbindEvents();
    }

    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }

    this._initialBookmark = null;
    this._initialRotation = null;
  }

  push({
    namedDest = null,
    explicitDest,
    pageNumber
  }) {
    if (!this._initialized) {
      return;
    }

    if (namedDest && typeof namedDest !== "string") {
      console.error("PDFHistory.push: " + `"${namedDest}" is not a valid namedDest parameter.`);
      return;
    } else if (!Array.isArray(explicitDest)) {
      console.error("PDFHistory.push: " + `"${explicitDest}" is not a valid explicitDest parameter.`);
      return;
    } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) {
      if (pageNumber !== null || this._destination) {
        console.error("PDFHistory.push: " + `"${pageNumber}" is not a valid pageNumber parameter.`);
        return;
      }
    }

    const hash = namedDest || JSON.stringify(explicitDest);

    if (!hash) {
      return;
    }

    let forceReplace = false;

    if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
      if (this._destination.page) {
        return;
      }

      forceReplace = true;
    }

    if (this._popStateInProgress && !forceReplace) {
      return;
    }

    this._pushOrReplaceState({
      dest: explicitDest,
      hash,
      page: pageNumber,
      rotation: this.linkService.rotation
    }, forceReplace);

    if (!this._popStateInProgress) {
      this._popStateInProgress = true;
      Promise.resolve().then(() => {
        this._popStateInProgress = false;
      });
    }
  }

  pushCurrentPosition() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }

    this._tryPushCurrentPosition();
  }

  back() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }

    const state = window.history.state;

    if (this._isValidState(state) && state.uid > 0) {
      window.history.back();
    }
  }

  forward() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }

    const state = window.history.state;

    if (this._isValidState(state) && state.uid < this._maxUid) {
      window.history.forward();
    }
  }

  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }

  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }

  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }

  _pushOrReplaceState(destination, forceReplace = false) {
    const shouldReplace = forceReplace || !this._destination;
    const newState = {
      fingerprint: this._fingerprint,
      uid: shouldReplace ? this._uid : this._uid + 1,
      destination
    };

    this._updateInternalState(destination, newState.uid);

    let newUrl;

    if (this._updateUrl && destination && destination.hash) {
      const baseUrl = document.location.href.split("#")[0];

      if (!baseUrl.startsWith("file://")) {
        newUrl = `${baseUrl}#${destination.hash}`;
      }
    }

    if (shouldReplace) {
      window.history.replaceState(newState, "", newUrl);
    } else {
      this._maxUid = this._uid;
      window.history.pushState(newState, "", newUrl);
    }
  }

  _tryPushCurrentPosition(temporary = false) {
    if (!this._position) {
      return;
    }

    let position = this._position;

    if (temporary) {
      position = Object.assign(Object.create(null), this._position);
      position.temporary = true;
    }

    if (!this._destination) {
      this._pushOrReplaceState(position);

      return;
    }

    if (this._destination.temporary) {
      this._pushOrReplaceState(position, true);

      return;
    }

    if (this._destination.hash === position.hash) {
      return;
    }

    if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
      return;
    }

    let forceReplace = false;

    if (this._destination.page >= position.first && this._destination.page <= position.page) {
      if (this._destination.dest || !this._destination.first) {
        return;
      }

      forceReplace = true;
    }

    this._pushOrReplaceState(position, forceReplace);
  }

  _isValidState(state, checkReload = false) {
    if (!state) {
      return false;
    }

    if (state.fingerprint !== this._fingerprint) {
      if (checkReload) {
        if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
          return false;
        }

        const [perfEntry] = performance.getEntriesByType("navigation");

        if (!perfEntry || perfEntry.type !== "reload") {
          return false;
        }
      } else {
        return false;
      }
    }

    if (!Number.isInteger(state.uid) || state.uid < 0) {
      return false;
    }

    if (state.destination === null || typeof state.destination !== "object") {
      return false;
    }

    return true;
  }

  _updateInternalState(destination, uid, removeTemporary = false) {
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }

    if (removeTemporary && destination && destination.temporary) {
      delete destination.temporary;
    }

    this._destination = destination;
    this._uid = uid;
    this._numPositionUpdates = 0;
  }

  _parseCurrentHash(checkNameddest = false) {
    const hash = unescape(getCurrentHash()).substring(1);
    const params = (0, _ui_utils.parseQueryString)(hash);
    const nameddest = params.nameddest || "";
    let page = params.page | 0;

    if (!(Number.isInteger(page) && page > 0 && page <= this.linkService.pagesCount) || checkNameddest && nameddest.length > 0) {
      page = null;
    }

    return {
      hash,
      page,
      rotation: this.linkService.rotation
    };
  }

  _updateViewarea({
    location
  }) {
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }

    this._position = {
      hash: this._isViewerInPresentationMode ? `page=${location.pageNumber}` : location.pdfOpenParams.substring(1),
      page: this.linkService.page,
      first: location.pageNumber,
      rotation: location.rotation
    };

    if (this._popStateInProgress) {
      return;
    }

    if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
      this._numPositionUpdates++;
    }

    if (UPDATE_VIEWAREA_TIMEOUT > 0) {
      this._updateViewareaTimeout = setTimeout(() => {
        if (!this._popStateInProgress) {
          this._tryPushCurrentPosition(true);
        }

        this._updateViewareaTimeout = null;
      }, UPDATE_VIEWAREA_TIMEOUT);
    }
  }

  _popState({
    state
  }) {
    const newHash = getCurrentHash(),
          hashChanged = this._currentHash !== newHash;
    this._currentHash = newHash;

    if (!state) {
      this._uid++;

      const {
        hash,
        page,
        rotation
      } = this._parseCurrentHash();

      this._pushOrReplaceState({
        hash,
        page,
        rotation
      }, true);

      return;
    }

    if (!this._isValidState(state)) {
      return;
    }

    this._popStateInProgress = true;

    if (hashChanged) {
      this._blockHashChange++;
      (0, _ui_utils.waitOnEventOrTimeout)({
        target: window,
        name: "hashchange",
        delay: HASH_CHANGE_TIMEOUT
      }).then(() => {
        this._blockHashChange--;
      });
    }

    const destination = state.destination;

    this._updateInternalState(destination, state.uid, true);

    if (this._uid > this._maxUid) {
      this._maxUid = this._uid;
    }

    if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
      this.linkService.rotation = destination.rotation;
    }

    if (destination.dest) {
      this.linkService.navigateTo(destination.dest);
    } else if (destination.hash) {
      this.linkService.setHash(destination.hash);
    } else if (destination.page) {
      this.linkService.page = destination.page;
    }

    Promise.resolve().then(() => {
      this._popStateInProgress = false;
    });
  }

  _pageHide() {
    if (!this._destination || this._destination.temporary) {
      this._tryPushCurrentPosition();
    }
  }

  _bindEvents() {
    if (this._boundEvents) {
      return;
    }

    this._boundEvents = {
      updateViewarea: this._updateViewarea.bind(this),
      popState: this._popState.bind(this),
      pageHide: this._pageHide.bind(this)
    };

    this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);

    window.addEventListener("popstate", this._boundEvents.popState);
    window.addEventListener("pagehide", this._boundEvents.pageHide);
  }

  _unbindEvents() {
    if (!this._boundEvents) {
      return;
    }

    this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);

    window.removeEventListener("popstate", this._boundEvents.popState);
    window.removeEventListener("pagehide", this._boundEvents.pageHide);
    this._boundEvents = null;
  }

}

exports.PDFHistory = PDFHistory;

function isDestHashesEqual(destHash, pushHash) {
  if (typeof destHash !== "string" || typeof pushHash !== "string") {
    return false;
  }

  if (destHash === pushHash) {
    return true;
  }

  const {
    nameddest
  } = (0, _ui_utils.parseQueryString)(destHash);

  if (nameddest === pushHash) {
    return true;
  }

  return false;
}

function isDestArraysEqual(firstDest, secondDest) {
  function isEntryEqual(first, second) {
    if (typeof first !== typeof second) {
      return false;
    }

    if (Array.isArray(first) || Array.isArray(second)) {
      return false;
    }

    if (first !== null && typeof first === "object" && second !== null) {
      if (Object.keys(first).length !== Object.keys(second).length) {
        return false;
      }

      for (const key in first) {
        if (!isEntryEqual(first[key], second[key])) {
          return false;
        }
      }

      return true;
    }

    return first === second || Number.isNaN(first) && Number.isNaN(second);
  }

  if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
    return false;
  }

  if (firstDest.length !== secondDest.length) {
    return false;
  }

  for (let i = 0, ii = firstDest.length; i < ii; i++) {
    if (!isEntryEqual(firstDest[i], secondDest[i])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleLinkService = exports.PDFLinkService = void 0;

var _ui_utils = __webpack_require__(2);

class PDFLinkService {
  constructor({
    eventBus,
    externalLinkTarget = null,
    externalLinkRel = null,
    externalLinkEnabled = true,
    ignoreDestinationZoom = false
  } = {}) {
    this.eventBus = eventBus;
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this.externalLinkEnabled = externalLinkEnabled;
    this._ignoreDestinationZoom = ignoreDestinationZoom;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
    this._pagesRefCache = null;
  }

  setDocument(pdfDocument, baseUrl = null) {
    this.baseUrl = baseUrl;
    this.pdfDocument = pdfDocument;
    this._pagesRefCache = Object.create(null);
  }

  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }

  setHistory(pdfHistory) {
    this.pdfHistory = pdfHistory;
  }

  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }

  get page() {
    return this.pdfViewer.currentPageNumber;
  }

  set page(value) {
    this.pdfViewer.currentPageNumber = value;
  }

  get rotation() {
    return this.pdfViewer.pagesRotation;
  }

  set rotation(value) {
    this.pdfViewer.pagesRotation = value;
  }

  navigateTo(dest) {
    const goToDestination = ({
      namedDest,
      explicitDest
    }) => {
      const destRef = explicitDest[0];
      let pageNumber;

      if (destRef instanceof Object) {
        pageNumber = this._cachedPageNumber(destRef);

        if (pageNumber === null) {
          this.pdfDocument.getPageIndex(destRef).then(pageIndex => {
            this.cachePageRef(pageIndex + 1, destRef);
            goToDestination({
              namedDest,
              explicitDest
            });
          }).catch(() => {
            console.error(`PDFLinkService.navigateTo: "${destRef}" is not ` + `a valid page reference, for dest="${dest}".`);
          });
          return;
        }
      } else if (Number.isInteger(destRef)) {
        pageNumber = destRef + 1;
      } else {
        console.error(`PDFLinkService.navigateTo: "${destRef}" is not ` + `a valid destination reference, for dest="${dest}".`);
        return;
      }

      if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
        console.error(`PDFLinkService.navigateTo: "${pageNumber}" is not ` + `a valid page number, for dest="${dest}".`);
        return;
      }

      if (this.pdfHistory) {
        this.pdfHistory.pushCurrentPosition();
        this.pdfHistory.push({
          namedDest,
          explicitDest,
          pageNumber
        });
      }

      this.pdfViewer.scrollPageIntoView({
        pageNumber,
        destArray: explicitDest,
        ignoreDestinationZoom: this._ignoreDestinationZoom
      });
    };

    new Promise((resolve, reject) => {
      if (typeof dest === "string") {
        this.pdfDocument.getDestination(dest).then(destArray => {
          resolve({
            namedDest: dest,
            explicitDest: destArray
          });
        });
        return;
      }

      resolve({
        namedDest: "",
        explicitDest: dest
      });
    }).then(data => {
      if (!Array.isArray(data.explicitDest)) {
        console.error(`PDFLinkService.navigateTo: "${data.explicitDest}" is` + ` not a valid destination array, for dest="${dest}".`);
        return;
      }

      goToDestination(data);
    });
  }

  getDestinationHash(dest) {
    if (typeof dest === "string") {
      return this.getAnchorUrl("#" + escape(dest));
    }

    if (Array.isArray(dest)) {
      const str = JSON.stringify(dest);
      return this.getAnchorUrl("#" + escape(str));
    }

    return this.getAnchorUrl("");
  }

  getAnchorUrl(anchor) {
    return (this.baseUrl || "") + anchor;
  }

  setHash(hash) {
    let pageNumber, dest;

    if (hash.includes("=")) {
      const params = (0, _ui_utils.parseQueryString)(hash);

      if ("search" in params) {
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: params.search.replace(/"/g, ""),
          phraseSearch: params.phrase === "true"
        });
      }

      if ("page" in params) {
        pageNumber = params.page | 0 || 1;
      }

      if ("zoom" in params) {
        const zoomArgs = params.zoom.split(",");
        const zoomArg = zoomArgs[0];
        const zoomArgNumber = parseFloat(zoomArg);

        if (!zoomArg.includes("Fit")) {
          dest = [null, {
            name: "XYZ"
          }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
        } else {
          if (zoomArg === "Fit" || zoomArg === "FitB") {
            dest = [null, {
              name: zoomArg
            }];
          } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
            dest = [null, {
              name: zoomArg
            }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
          } else if (zoomArg === "FitR") {
            if (zoomArgs.length !== 5) {
              console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
            } else {
              dest = [null, {
                name: zoomArg
              }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
            }
          } else {
            console.error(`PDFLinkService.setHash: "${zoomArg}" is not ` + "a valid zoom value.");
          }
        }
      }

      if (dest) {
        this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber || this.page,
          destArray: dest,
          allowNegativeOffset: true
        });
      } else if (pageNumber) {
        this.page = pageNumber;
      }

      if ("pagemode" in params) {
        this.eventBus.dispatch("pagemode", {
          source: this,
          mode: params.pagemode
        });
      }

      if ("nameddest" in params) {
        this.navigateTo(params.nameddest);
      }
    } else {
      dest = unescape(hash);

      try {
        dest = JSON.parse(dest);

        if (!Array.isArray(dest)) {
          dest = dest.toString();
        }
      } catch (ex) {}

      if (typeof dest === "string" || isValidExplicitDestination(dest)) {
        this.navigateTo(dest);
        return;
      }

      console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not ` + "a valid destination.");
    }
  }

  executeNamedAction(action) {
    switch (action) {
      case "GoBack":
        if (this.pdfHistory) {
          this.pdfHistory.back();
        }

        break;

      case "GoForward":
        if (this.pdfHistory) {
          this.pdfHistory.forward();
        }

        break;

      case "NextPage":
        if (this.page < this.pagesCount) {
          this.page++;
        }

        break;

      case "PrevPage":
        if (this.page > 1) {
          this.page--;
        }

        break;

      case "LastPage":
        this.page = this.pagesCount;
        break;

      case "FirstPage":
        this.page = 1;
        break;

      default:
        break;
    }

    this.eventBus.dispatch("namedaction", {
      source: this,
      action
    });
  }

  cachePageRef(pageNum, pageRef) {
    if (!pageRef) {
      return;
    }

    const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
    this._pagesRefCache[refStr] = pageNum;
  }

  _cachedPageNumber(pageRef) {
    const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
    return this._pagesRefCache && this._pagesRefCache[refStr] || null;
  }

  isPageVisible(pageNumber) {
    return this.pdfViewer.isPageVisible(pageNumber);
  }

}

exports.PDFLinkService = PDFLinkService;

function isValidExplicitDestination(dest) {
  if (!Array.isArray(dest)) {
    return false;
  }

  const destLength = dest.length;

  if (destLength < 2) {
    return false;
  }

  const page = dest[0];

  if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
    return false;
  }

  const zoom = dest[1];

  if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
    return false;
  }

  let allowNull = true;

  switch (zoom.name) {
    case "XYZ":
      if (destLength !== 5) {
        return false;
      }

      break;

    case "Fit":
    case "FitB":
      return destLength === 2;

    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (destLength !== 3) {
        return false;
      }

      break;

    case "FitR":
      if (destLength !== 6) {
        return false;
      }

      allowNull = false;
      break;

    default:
      return false;
  }

  for (let i = 2; i < destLength; i++) {
    const param = dest[i];

    if (!(typeof param === "number" || allowNull && param === null)) {
      return false;
    }
  }

  return true;
}

class SimpleLinkService {
  constructor() {
    this.externalLinkTarget = null;
    this.externalLinkRel = null;
    this.externalLinkEnabled = true;
    this._ignoreDestinationZoom = false;
  }

  get pagesCount() {
    return 0;
  }

  get page() {
    return 0;
  }

  set page(value) {}

  get rotation() {
    return 0;
  }

  set rotation(value) {}

  navigateTo(dest) {}

  getDestinationHash(dest) {
    return "#";
  }

  getAnchorUrl(hash) {
    return "#";
  }

  setHash(hash) {}

  executeNamedAction(action) {}

  cachePageRef(pageNum, pageRef) {}

  isPageVisible(pageNumber) {
    return true;
  }

}

exports.SimpleLinkService = SimpleLinkService;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFOutlineViewer = void 0;

var _pdfjsLib = __webpack_require__(5);

const DEFAULT_TITLE = "\u2013";

class PDFOutlineViewer {
  constructor({
    container,
    linkService,
    eventBus
  }) {
    this.container = container;
    this.linkService = linkService;
    this.eventBus = eventBus;
    this.reset();

    eventBus._on("toggleoutlinetree", this.toggleOutlineTree.bind(this));
  }

  reset() {
    this.outline = null;
    this.lastToggleIsShow = true;
    this.container.textContent = "";
    this.container.classList.remove("outlineWithDeepNesting");
  }

  _dispatchEvent(outlineCount) {
    this.eventBus.dispatch("outlineloaded", {
      source: this,
      outlineCount
    });
  }

  _bindLink(element, {
    url,
    newWindow,
    dest
  }) {
    const {
      linkService
    } = this;

    if (url) {
      (0, _pdfjsLib.addLinkAttributes)(element, {
        url,
        target: newWindow ? _pdfjsLib.LinkTarget.BLANK : linkService.externalLinkTarget,
        rel: linkService.externalLinkRel,
        enabled: linkService.externalLinkEnabled
      });
      return;
    }

    element.href = linkService.getDestinationHash(dest);

    element.onclick = () => {
      if (dest) {
        linkService.navigateTo(dest);
      }

      return false;
    };
  }

  _setStyles(element, {
    bold,
    italic
  }) {
    if (bold) {
      element.style.fontWeight = "bold";
    }

    if (italic) {
      element.style.fontStyle = "italic";
    }
  }

  _addToggleButton(div, {
    count,
    items
  }) {
    const toggler = document.createElement("div");
    toggler.className = "outlineItemToggler";

    if (count < 0 && Math.abs(count) === items.length) {
      toggler.classList.add("outlineItemsHidden");
    }

    toggler.onclick = evt => {
      evt.stopPropagation();
      toggler.classList.toggle("outlineItemsHidden");

      if (evt.shiftKey) {
        const shouldShowAll = !toggler.classList.contains("outlineItemsHidden");

        this._toggleOutlineItem(div, shouldShowAll);
      }
    };

    div.insertBefore(toggler, div.firstChild);
  }

  _toggleOutlineItem(root, show = false) {
    this.lastToggleIsShow = show;

    for (const toggler of root.querySelectorAll(".outlineItemToggler")) {
      toggler.classList.toggle("outlineItemsHidden", !show);
    }
  }

  toggleOutlineTree() {
    if (!this.outline) {
      return;
    }

    this._toggleOutlineItem(this.container, !this.lastToggleIsShow);
  }

  render({
    outline
  }) {
    let outlineCount = 0;

    if (this.outline) {
      this.reset();
    }

    this.outline = outline || null;

    if (!outline) {
      this._dispatchEvent(outlineCount);

      return;
    }

    const fragment = document.createDocumentFragment();
    const queue = [{
      parent: fragment,
      items: this.outline
    }];
    let hasAnyNesting = false;

    while (queue.length > 0) {
      const levelData = queue.shift();

      for (const item of levelData.items) {
        const div = document.createElement("div");
        div.className = "outlineItem";
        const element = document.createElement("a");

        this._bindLink(element, item);

        this._setStyles(element, item);

        element.textContent = (0, _pdfjsLib.removeNullCharacters)(item.title) || DEFAULT_TITLE;
        div.appendChild(element);

        if (item.items.length > 0) {
          hasAnyNesting = true;

          this._addToggleButton(div, item);

          const itemsDiv = document.createElement("div");
          itemsDiv.className = "outlineItems";
          div.appendChild(itemsDiv);
          queue.push({
            parent: itemsDiv,
            items: item.items
          });
        }

        levelData.parent.appendChild(div);
        outlineCount++;
      }
    }

    if (hasAnyNesting) {
      this.container.classList.add("outlineWithDeepNesting");
      this.lastToggleIsShow = fragment.querySelectorAll(".outlineItemsHidden").length === 0;
    }

    this.container.appendChild(fragment);

    this._dispatchEvent(outlineCount);
  }

}

exports.PDFOutlineViewer = PDFOutlineViewer;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFPresentationMode = void 0;

var _ui_utils = __webpack_require__(2);

const DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500;
const DELAY_BEFORE_HIDING_CONTROLS = 3000;
const ACTIVE_SELECTOR = "pdfPresentationMode";
const CONTROLS_SELECTOR = "pdfPresentationModeControls";
const MOUSE_SCROLL_COOLDOWN_TIME = 50;
const PAGE_SWITCH_THRESHOLD = 0.1;
const SWIPE_MIN_DISTANCE_THRESHOLD = 50;
const SWIPE_ANGLE_THRESHOLD = Math.PI / 6;

class PDFPresentationMode {
  constructor({
    container,
    pdfViewer,
    eventBus,
    contextMenuItems = null
  }) {
    this.container = container;
    this.pdfViewer = pdfViewer;
    this.eventBus = eventBus;
    this.active = false;
    this.args = null;
    this.contextMenuOpen = false;
    this.mouseScrollTimeStamp = 0;
    this.mouseScrollDelta = 0;
    this.touchSwipeState = null;

    if (contextMenuItems) {
      contextMenuItems.contextFirstPage.addEventListener("click", () => {
        this.contextMenuOpen = false;
        this.eventBus.dispatch("firstpage", {
          source: this
        });
      });
      contextMenuItems.contextLastPage.addEventListener("click", () => {
        this.contextMenuOpen = false;
        this.eventBus.dispatch("lastpage", {
          source: this
        });
      });
      contextMenuItems.contextPageRotateCw.addEventListener("click", () => {
        this.contextMenuOpen = false;
        this.eventBus.dispatch("rotatecw", {
          source: this
        });
      });
      contextMenuItems.contextPageRotateCcw.addEventListener("click", () => {
        this.contextMenuOpen = false;
        this.eventBus.dispatch("rotateccw", {
          source: this
        });
      });
    }
  }

  request() {
    if (this.switchInProgress || this.active || !this.pdfViewer.pagesCount) {
      return false;
    }

    this._addFullscreenChangeListeners();

    this._setSwitchInProgress();

    this._notifyStateChange();

    if (this.container.requestFullscreen) {
      this.container.requestFullscreen();
    } else if (this.container.mozRequestFullScreen) {
      this.container.mozRequestFullScreen();
    } else if (this.container.webkitRequestFullscreen) {
      this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    } else if (this.container.msRequestFullscreen) {
      this.container.msRequestFullscreen();
    } else {
      return false;
    }

    this.args = {
      page: this.pdfViewer.currentPageNumber,
      previousScale: this.pdfViewer.currentScaleValue
    };
    return true;
  }

  _mouseWheel(evt) {
    if (!this.active) {
      return;
    }

    evt.preventDefault();
    const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
    const currentTime = new Date().getTime();
    const storedTime = this.mouseScrollTimeStamp;

    if (currentTime > storedTime && currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME) {
      return;
    }

    if (this.mouseScrollDelta > 0 && delta < 0 || this.mouseScrollDelta < 0 && delta > 0) {
      this._resetMouseScrollState();
    }

    this.mouseScrollDelta += delta;

    if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) {
      const totalDelta = this.mouseScrollDelta;

      this._resetMouseScrollState();

      const success = totalDelta > 0 ? this._goToPreviousPage() : this._goToNextPage();

      if (success) {
        this.mouseScrollTimeStamp = currentTime;
      }
    }
  }

  get isFullscreen() {
    return !!(document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement);
  }

  _goToPreviousPage() {
    const page = this.pdfViewer.currentPageNumber;

    if (page <= 1) {
      return false;
    }

    this.pdfViewer.currentPageNumber = page - 1;
    return true;
  }

  _goToNextPage() {
    const page = this.pdfViewer.currentPageNumber;

    if (page >= this.pdfViewer.pagesCount) {
      return false;
    }

    this.pdfViewer.currentPageNumber = page + 1;
    return true;
  }

  _notifyStateChange() {
    this.eventBus.dispatch("presentationmodechanged", {
      source: this,
      active: this.active,
      switchInProgress: !!this.switchInProgress
    });
  }

  _setSwitchInProgress() {
    if (this.switchInProgress) {
      clearTimeout(this.switchInProgress);
    }

    this.switchInProgress = setTimeout(() => {
      this._removeFullscreenChangeListeners();

      delete this.switchInProgress;

      this._notifyStateChange();
    }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);
  }

  _resetSwitchInProgress() {
    if (this.switchInProgress) {
      clearTimeout(this.switchInProgress);
      delete this.switchInProgress;
    }
  }

  _enter() {
    this.active = true;

    this._resetSwitchInProgress();

    this._notifyStateChange();

    this.container.classList.add(ACTIVE_SELECTOR);
    setTimeout(() => {
      this.pdfViewer.currentPageNumber = this.args.page;
      this.pdfViewer.currentScaleValue = "page-fit";
    }, 0);

    this._addWindowListeners();

    this._showControls();

    this.contextMenuOpen = false;
    this.container.setAttribute("contextmenu", "viewerContextMenu");
    window.getSelection().removeAllRanges();
  }

  _exit() {
    const page = this.pdfViewer.currentPageNumber;
    this.container.classList.remove(ACTIVE_SELECTOR);
    setTimeout(() => {
      this.active = false;

      this._removeFullscreenChangeListeners();

      this._notifyStateChange();

      this.pdfViewer.currentScaleValue = this.args.previousScale;
      this.pdfViewer.currentPageNumber = page;
      this.args = null;
    }, 0);

    this._removeWindowListeners();

    this._hideControls();

    this._resetMouseScrollState();

    this.container.removeAttribute("contextmenu");
    this.contextMenuOpen = false;
  }

  _mouseDown(evt) {
    if (this.contextMenuOpen) {
      this.contextMenuOpen = false;
      evt.preventDefault();
      return;
    }

    if (evt.button === 0) {
      const isInternalLink = evt.target.href && evt.target.classList.contains("internalLink");

      if (!isInternalLink) {
        evt.preventDefault();

        if (evt.shiftKey) {
          this._goToPreviousPage();
        } else {
          this._goToNextPage();
        }
      }
    }
  }

  _contextMenu() {
    this.contextMenuOpen = true;
  }

  _showControls() {
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
    } else {
      this.container.classList.add(CONTROLS_SELECTOR);
    }

    this.controlsTimeout = setTimeout(() => {
      this.container.classList.remove(CONTROLS_SELECTOR);
      delete this.controlsTimeout;
    }, DELAY_BEFORE_HIDING_CONTROLS);
  }

  _hideControls() {
    if (!this.controlsTimeout) {
      return;
    }

    clearTimeout(this.controlsTimeout);
    this.container.classList.remove(CONTROLS_SELECTOR);
    delete this.controlsTimeout;
  }

  _resetMouseScrollState() {
    this.mouseScrollTimeStamp = 0;
    this.mouseScrollDelta = 0;
  }

  _touchSwipe(evt) {
    if (!this.active) {
      return;
    }

    if (evt.touches.length > 1) {
      this.touchSwipeState = null;
      return;
    }

    switch (evt.type) {
      case "touchstart":
        this.touchSwipeState = {
          startX: evt.touches[0].pageX,
          startY: evt.touches[0].pageY,
          endX: evt.touches[0].pageX,
          endY: evt.touches[0].pageY
        };
        break;

      case "touchmove":
        if (this.touchSwipeState === null) {
          return;
        }

        this.touchSwipeState.endX = evt.touches[0].pageX;
        this.touchSwipeState.endY = evt.touches[0].pageY;
        evt.preventDefault();
        break;

      case "touchend":
        if (this.touchSwipeState === null) {
          return;
        }

        let delta = 0;
        const dx = this.touchSwipeState.endX - this.touchSwipeState.startX;
        const dy = this.touchSwipeState.endY - this.touchSwipeState.startY;
        const absAngle = Math.abs(Math.atan2(dy, dx));

        if (Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD && (absAngle <= SWIPE_ANGLE_THRESHOLD || absAngle >= Math.PI - SWIPE_ANGLE_THRESHOLD)) {
          delta = dx;
        } else if (Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD && Math.abs(absAngle - Math.PI / 2) <= SWIPE_ANGLE_THRESHOLD) {
          delta = dy;
        }

        if (delta > 0) {
          this._goToPreviousPage();
        } else if (delta < 0) {
          this._goToNextPage();
        }

        break;
    }
  }

  _addWindowListeners() {
    this.showControlsBind = this._showControls.bind(this);
    this.mouseDownBind = this._mouseDown.bind(this);
    this.mouseWheelBind = this._mouseWheel.bind(this);
    this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this);
    this.contextMenuBind = this._contextMenu.bind(this);
    this.touchSwipeBind = this._touchSwipe.bind(this);
    window.addEventListener("mousemove", this.showControlsBind);
    window.addEventListener("mousedown", this.mouseDownBind);
    window.addEventListener("wheel", this.mouseWheelBind, {
      passive: false
    });
    window.addEventListener("keydown", this.resetMouseScrollStateBind);
    window.addEventListener("contextmenu", this.contextMenuBind);
    window.addEventListener("touchstart", this.touchSwipeBind);
    window.addEventListener("touchmove", this.touchSwipeBind);
    window.addEventListener("touchend", this.touchSwipeBind);
  }

  _removeWindowListeners() {
    window.removeEventListener("mousemove", this.showControlsBind);
    window.removeEventListener("mousedown", this.mouseDownBind);
    window.removeEventListener("wheel", this.mouseWheelBind, {
      passive: false
    });
    window.removeEventListener("keydown", this.resetMouseScrollStateBind);
    window.removeEventListener("contextmenu", this.contextMenuBind);
    window.removeEventListener("touchstart", this.touchSwipeBind);
    window.removeEventListener("touchmove", this.touchSwipeBind);
    window.removeEventListener("touchend", this.touchSwipeBind);
    delete this.showControlsBind;
    delete this.mouseDownBind;
    delete this.mouseWheelBind;
    delete this.resetMouseScrollStateBind;
    delete this.contextMenuBind;
    delete this.touchSwipeBind;
  }

  _fullscreenChange() {
    if (this.isFullscreen) {
      this._enter();
    } else {
      this._exit();
    }
  }

  _addFullscreenChangeListeners() {
    this.fullscreenChangeBind = this._fullscreenChange.bind(this);
    window.addEventListener("fullscreenchange", this.fullscreenChangeBind);
    window.addEventListener("mozfullscreenchange", this.fullscreenChangeBind);
    window.addEventListener("webkitfullscreenchange", this.fullscreenChangeBind);
    window.addEventListener("MSFullscreenChange", this.fullscreenChangeBind);
  }

  _removeFullscreenChangeListeners() {
    window.removeEventListener("fullscreenchange", this.fullscreenChangeBind);
    window.removeEventListener("mozfullscreenchange", this.fullscreenChangeBind);
    window.removeEventListener("webkitfullscreenchange", this.fullscreenChangeBind);
    window.removeEventListener("MSFullscreenChange", this.fullscreenChangeBind);
    delete this.fullscreenChangeBind;
  }

}

exports.PDFPresentationMode = PDFPresentationMode;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFSidebarResizer = void 0;

var _ui_utils = __webpack_require__(2);

const SIDEBAR_WIDTH_VAR = "--sidebar-width";
const SIDEBAR_MIN_WIDTH = 200;
const SIDEBAR_RESIZING_CLASS = "sidebarResizing";

class PDFSidebarResizer {
  constructor(options, eventBus, l10n = _ui_utils.NullL10n) {
    this.enabled = false;
    this.isRTL = false;
    this.sidebarOpen = false;
    this.doc = document.documentElement;
    this._width = null;
    this._outerContainerWidth = null;
    this._boundEvents = Object.create(null);
    this.outerContainer = options.outerContainer;
    this.resizer = options.resizer;
    this.eventBus = eventBus;
    this.l10n = l10n;

    if (typeof CSS === "undefined" || typeof CSS.supports !== "function" || !CSS.supports(SIDEBAR_WIDTH_VAR, `calc(-1 * ${SIDEBAR_MIN_WIDTH}px)`)) {
      console.warn("PDFSidebarResizer: " + "The browser does not support resizing of the sidebar.");
      return;
    }

    this.enabled = true;
    this.resizer.classList.remove("hidden");
    this.l10n.getDirection().then(dir => {
      this.isRTL = dir === "rtl";
    });

    this._addEventListeners();
  }

  get outerContainerWidth() {
    if (!this._outerContainerWidth) {
      this._outerContainerWidth = this.outerContainer.clientWidth;
    }

    return this._outerContainerWidth;
  }

  _updateWidth(width = 0) {
    if (!this.enabled) {
      return false;
    }

    const newWidth = (0, _ui_utils.clamp)(width, SIDEBAR_MIN_WIDTH, Math.floor(this.outerContainerWidth / 2));

    if (newWidth === this._width) {
      return false;
    }

    this._width = newWidth;
    this.doc.style.setProperty(SIDEBAR_WIDTH_VAR, `${newWidth}px`);
    return true;
  }

  _mouseMove(evt) {
    let width = evt.clientX;

    if (this.isRTL) {
      width = this.outerContainerWidth - width;
    }

    this._updateWidth(width);
  }

  _mouseUp(evt) {
    this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);
    this.eventBus.dispatch("resize", {
      source: this
    });
    const _boundEvents = this._boundEvents;
    window.removeEventListener("mousemove", _boundEvents.mouseMove);
    window.removeEventListener("mouseup", _boundEvents.mouseUp);
  }

  _addEventListeners() {
    if (!this.enabled) {
      return;
    }

    const _boundEvents = this._boundEvents;
    _boundEvents.mouseMove = this._mouseMove.bind(this);
    _boundEvents.mouseUp = this._mouseUp.bind(this);
    this.resizer.addEventListener("mousedown", evt => {
      if (evt.button !== 0) {
        return;
      }

      this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);
      window.addEventListener("mousemove", _boundEvents.mouseMove);
      window.addEventListener("mouseup", _boundEvents.mouseUp);
    });

    this.eventBus._on("sidebarviewchanged", evt => {
      this.sidebarOpen = !!(evt && evt.view);
    });

    this.eventBus._on("resize", evt => {
      if (!evt || evt.source !== window) {
        return;
      }

      this._outerContainerWidth = null;

      if (!this._width) {
        return;
      }

      if (!this.sidebarOpen) {
        this._updateWidth(this._width);

        return;
      }

      this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);

      const updated = this._updateWidth(this._width);

      Promise.resolve().then(() => {
        this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);

        if (updated) {
          this.eventBus.dispatch("resize", {
            source: this
          });
        }
      });
    });
  }

}

exports.PDFSidebarResizer = PDFSidebarResizer;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFThumbnailViewer = void 0;

var _ui_utils = __webpack_require__(2);

var _pdf_thumbnail_view = __webpack_require__(23);

const THUMBNAIL_SCROLL_MARGIN = -19;
const THUMBNAIL_SELECTED_CLASS = "selected";

class PDFThumbnailViewer {
  constructor({
    container,
    linkService,
    renderingQueue,
    l10n = _ui_utils.NullL10n
  }) {
    this.container = container;
    this.linkService = linkService;
    this.renderingQueue = renderingQueue;
    this.l10n = l10n;
    this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdated.bind(this));

    this._resetView();
  }

  _scrollUpdated() {
    this.renderingQueue.renderHighestPriority();
  }

  getThumbnail(index) {
    return this._thumbnails[index];
  }

  _getVisibleThumbs() {
    return (0, _ui_utils.getVisibleElements)(this.container, this._thumbnails);
  }

  scrollThumbnailIntoView(pageNumber) {
    if (!this.pdfDocument) {
      return;
    }

    const thumbnailView = this._thumbnails[pageNumber - 1];

    if (!thumbnailView) {
      console.error('scrollThumbnailIntoView: Invalid "pageNumber" parameter.');
      return;
    }

    if (pageNumber !== this._currentPageNumber) {
      const prevThumbnailView = this._thumbnails[this._currentPageNumber - 1];
      prevThumbnailView.div.classList.remove(THUMBNAIL_SELECTED_CLASS);
      thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);
    }

    const visibleThumbs = this._getVisibleThumbs();

    const numVisibleThumbs = visibleThumbs.views.length;

    if (numVisibleThumbs > 0) {
      const first = visibleThumbs.first.id;
      const last = numVisibleThumbs > 1 ? visibleThumbs.last.id : first;
      let shouldScroll = false;

      if (pageNumber <= first || pageNumber >= last) {
        shouldScroll = true;
      } else {
        visibleThumbs.views.some(function (view) {
          if (view.id !== pageNumber) {
            return false;
          }

          shouldScroll = view.percent < 100;
          return true;
        });
      }

      if (shouldScroll) {
        (0, _ui_utils.scrollIntoView)(thumbnailView.div, {
          top: THUMBNAIL_SCROLL_MARGIN
        });
      }
    }

    this._currentPageNumber = pageNumber;
  }

  get pagesRotation() {
    return this._pagesRotation;
  }

  set pagesRotation(rotation) {
    if (!(0, _ui_utils.isValidRotation)(rotation)) {
      throw new Error("Invalid thumbnails rotation angle.");
    }

    if (!this.pdfDocument) {
      return;
    }

    if (this._pagesRotation === rotation) {
      return;
    }

    this._pagesRotation = rotation;

    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      this._thumbnails[i].update(rotation);
    }
  }

  cleanup() {
    _pdf_thumbnail_view.PDFThumbnailView.cleanup();
  }

  _resetView() {
    this._thumbnails = [];
    this._currentPageNumber = 1;
    this._pageLabels = null;
    this._pagesRotation = 0;
    this._pagesRequests = new WeakMap();
    this.container.textContent = "";
  }

  setDocument(pdfDocument) {
    if (this.pdfDocument) {
      this._cancelRendering();

      this._resetView();
    }

    this.pdfDocument = pdfDocument;

    if (!pdfDocument) {
      return;
    }

    pdfDocument.getPage(1).then(firstPdfPage => {
      const pagesCount = pdfDocument.numPages;
      const viewport = firstPdfPage.getViewport({
        scale: 1
      });

      for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
        const thumbnail = new _pdf_thumbnail_view.PDFThumbnailView({
          container: this.container,
          id: pageNum,
          defaultViewport: viewport.clone(),
          linkService: this.linkService,
          renderingQueue: this.renderingQueue,
          disableCanvasToImageConversion: false,
          l10n: this.l10n
        });

        this._thumbnails.push(thumbnail);
      }

      const firstThumbnailView = this._thumbnails[0];

      if (firstThumbnailView) {
        firstThumbnailView.setPdfPage(firstPdfPage);
      }

      const thumbnailView = this._thumbnails[this._currentPageNumber - 1];
      thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);
    }).catch(reason => {
      console.error("Unable to initialize thumbnail viewer", reason);
    });
  }

  _cancelRendering() {
    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      if (this._thumbnails[i]) {
        this._thumbnails[i].cancelRendering();
      }
    }
  }

  setPageLabels(labels) {
    if (!this.pdfDocument) {
      return;
    }

    if (!labels) {
      this._pageLabels = null;
    } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
      this._pageLabels = null;
      console.error("PDFThumbnailViewer_setPageLabels: Invalid page labels.");
    } else {
      this._pageLabels = labels;
    }

    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      const label = this._pageLabels && this._pageLabels[i];

      this._thumbnails[i].setPageLabel(label);
    }
  }

  _ensurePdfPageLoaded(thumbView) {
    if (thumbView.pdfPage) {
      return Promise.resolve(thumbView.pdfPage);
    }

    if (this._pagesRequests.has(thumbView)) {
      return this._pagesRequests.get(thumbView);
    }

    const promise = this.pdfDocument.getPage(thumbView.id).then(pdfPage => {
      if (!thumbView.pdfPage) {
        thumbView.setPdfPage(pdfPage);
      }

      this._pagesRequests.delete(thumbView);

      return pdfPage;
    }).catch(reason => {
      console.error("Unable to get page for thumb view", reason);

      this._pagesRequests.delete(thumbView);
    });

    this._pagesRequests.set(thumbView, promise);

    return promise;
  }

  forceRendering() {
    const visibleThumbs = this._getVisibleThumbs();

    const thumbView = this.renderingQueue.getHighestPriority(visibleThumbs, this._thumbnails, this.scroll.down);

    if (thumbView) {
      this._ensurePdfPageLoaded(thumbView).then(() => {
        this.renderingQueue.renderView(thumbView);
      });

      return true;
    }

    return false;
  }

}

exports.PDFThumbnailViewer = PDFThumbnailViewer;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFThumbnailView = void 0;

var _pdfjsLib = __webpack_require__(5);

var _ui_utils = __webpack_require__(2);

var _pdf_rendering_queue = __webpack_require__(8);

const MAX_NUM_SCALING_STEPS = 3;
const THUMBNAIL_CANVAS_BORDER_WIDTH = 1;
const THUMBNAIL_WIDTH = 98;

const TempImageFactory = function TempImageFactoryClosure() {
  let tempCanvasCache = null;
  return {
    getCanvas(width, height) {
      let tempCanvas = tempCanvasCache;

      if (!tempCanvas) {
        tempCanvas = document.createElement("canvas");
        tempCanvasCache = tempCanvas;
      }

      tempCanvas.width = width;
      tempCanvas.height = height;
      tempCanvas.mozOpaque = true;
      const ctx = tempCanvas.getContext("2d", {
        alpha: false
      });
      ctx.save();
      ctx.fillStyle = "rgb(255, 255, 255)";
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
      return tempCanvas;
    },

    destroyCanvas() {
      const tempCanvas = tempCanvasCache;

      if (tempCanvas) {
        tempCanvas.width = 0;
        tempCanvas.height = 0;
      }

      tempCanvasCache = null;
    }

  };
}();

class PDFThumbnailView {
  constructor({
    container,
    id,
    defaultViewport,
    linkService,
    renderingQueue,
    disableCanvasToImageConversion = false,
    l10n = _ui_utils.NullL10n
  }) {
    this.id = id;
    this.renderingId = "thumbnail" + id;
    this.pageLabel = null;
    this.pdfPage = null;
    this.rotation = 0;
    this.viewport = defaultViewport;
    this.pdfPageRotate = defaultViewport.rotation;
    this.linkService = linkService;
    this.renderingQueue = renderingQueue;
    this.renderTask = null;
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    this.resume = null;
    this.disableCanvasToImageConversion = disableCanvasToImageConversion;
    this.pageWidth = this.viewport.width;
    this.pageHeight = this.viewport.height;
    this.pageRatio = this.pageWidth / this.pageHeight;
    this.canvasWidth = THUMBNAIL_WIDTH;
    this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
    this.scale = this.canvasWidth / this.pageWidth;
    this.l10n = l10n;
    const anchor = document.createElement("a");
    anchor.href = linkService.getAnchorUrl("#page=" + id);

    this._thumbPageTitle.then(msg => {
      anchor.title = msg;
    });

    anchor.onclick = function () {
      linkService.page = id;
      return false;
    };

    this.anchor = anchor;
    const div = document.createElement("div");
    div.className = "thumbnail";
    div.setAttribute("data-page-number", this.id);
    this.div = div;
    const ring = document.createElement("div");
    ring.className = "thumbnailSelectionRing";
    const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
    ring.style.width = this.canvasWidth + borderAdjustment + "px";
    ring.style.height = this.canvasHeight + borderAdjustment + "px";
    this.ring = ring;
    div.appendChild(ring);
    anchor.appendChild(div);
    container.appendChild(anchor);
  }

  setPdfPage(pdfPage) {
    this.pdfPage = pdfPage;
    this.pdfPageRotate = pdfPage.rotate;
    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = pdfPage.getViewport({
      scale: 1,
      rotation: totalRotation
    });
    this.reset();
  }

  reset() {
    this.cancelRendering();
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    this.pageWidth = this.viewport.width;
    this.pageHeight = this.viewport.height;
    this.pageRatio = this.pageWidth / this.pageHeight;
    this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
    this.scale = this.canvasWidth / this.pageWidth;
    this.div.removeAttribute("data-loaded");
    const ring = this.ring;
    const childNodes = ring.childNodes;

    for (let i = childNodes.length - 1; i >= 0; i--) {
      ring.removeChild(childNodes[i]);
    }

    const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
    ring.style.width = this.canvasWidth + borderAdjustment + "px";
    ring.style.height = this.canvasHeight + borderAdjustment + "px";

    if (this.canvas) {
      this.canvas.width = 0;
      this.canvas.height = 0;
      delete this.canvas;
    }

    if (this.image) {
      this.image.removeAttribute("src");
      delete this.image;
    }
  }

  update(rotation) {
    if (typeof rotation !== "undefined") {
      this.rotation = rotation;
    }

    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = this.viewport.clone({
      scale: 1,
      rotation: totalRotation
    });
    this.reset();
  }

  cancelRendering() {
    if (this.renderTask) {
      this.renderTask.cancel();
      this.renderTask = null;
    }

    this.resume = null;
  }

  _getPageDrawContext(noCtxScale = false) {
    const canvas = document.createElement("canvas");
    this.canvas = canvas;
    canvas.mozOpaque = true;
    const ctx = canvas.getContext("2d", {
      alpha: false
    });
    const outputScale = (0, _ui_utils.getOutputScale)(ctx);
    canvas.width = this.canvasWidth * outputScale.sx | 0;
    canvas.height = this.canvasHeight * outputScale.sy | 0;
    canvas.style.width = this.canvasWidth + "px";
    canvas.style.height = this.canvasHeight + "px";

    if (!noCtxScale && outputScale.scaled) {
      ctx.scale(outputScale.sx, outputScale.sy);
    }

    return ctx;
  }

  _convertCanvasToImage() {
    if (!this.canvas) {
      return;
    }

    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
      return;
    }

    const className = "thumbnailImage";

    if (this.disableCanvasToImageConversion) {
      this.canvas.className = className;

      this._thumbPageCanvas.then(msg => {
        this.canvas.setAttribute("aria-label", msg);
      });

      this.div.setAttribute("data-loaded", true);
      this.ring.appendChild(this.canvas);
      return;
    }

    const image = document.createElement("img");
    image.className = className;

    this._thumbPageCanvas.then(msg => {
      image.setAttribute("aria-label", msg);
    });

    image.style.width = this.canvasWidth + "px";
    image.style.height = this.canvasHeight + "px";
    image.src = this.canvas.toDataURL();
    this.image = image;
    this.div.setAttribute("data-loaded", true);
    this.ring.appendChild(image);
    this.canvas.width = 0;
    this.canvas.height = 0;
    delete this.canvas;
  }

  draw() {
    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
      console.error("Must be in new state before drawing");
      return Promise.resolve(undefined);
    }

    const {
      pdfPage
    } = this;

    if (!pdfPage) {
      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
      return Promise.reject(new Error("pdfPage is not loaded"));
    }

    this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
    const renderCapability = (0, _pdfjsLib.createPromiseCapability)();

    const finishRenderTask = error => {
      if (renderTask === this.renderTask) {
        this.renderTask = null;
      }

      if (error instanceof _pdfjsLib.RenderingCancelledException) {
        renderCapability.resolve(undefined);
        return;
      }

      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

      this._convertCanvasToImage();

      if (!error) {
        renderCapability.resolve(undefined);
      } else {
        renderCapability.reject(error);
      }
    };

    const ctx = this._getPageDrawContext();

    const drawViewport = this.viewport.clone({
      scale: this.scale
    });

    const renderContinueCallback = cont => {
      if (!this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;

        this.resume = () => {
          this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
          cont();
        };

        return;
      }

      cont();
    };

    const renderContext = {
      canvasContext: ctx,
      viewport: drawViewport
    };
    const renderTask = this.renderTask = pdfPage.render(renderContext);
    renderTask.onContinue = renderContinueCallback;
    renderTask.promise.then(function () {
      finishRenderTask(null);
    }, function (error) {
      finishRenderTask(error);
    });
    return renderCapability.promise;
  }

  setImage(pageView) {
    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
      return;
    }

    const img = pageView.canvas;

    if (!img) {
      return;
    }

    if (!this.pdfPage) {
      this.setPdfPage(pageView.pdfPage);
    }

    this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

    const ctx = this._getPageDrawContext(true);

    const canvas = ctx.canvas;

    if (img.width <= 2 * canvas.width) {
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);

      this._convertCanvasToImage();

      return;
    }

    let reducedWidth = canvas.width << MAX_NUM_SCALING_STEPS;
    let reducedHeight = canvas.height << MAX_NUM_SCALING_STEPS;
    const reducedImage = TempImageFactory.getCanvas(reducedWidth, reducedHeight);
    const reducedImageCtx = reducedImage.getContext("2d");

    while (reducedWidth > img.width || reducedHeight > img.height) {
      reducedWidth >>= 1;
      reducedHeight >>= 1;
    }

    reducedImageCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, reducedWidth, reducedHeight);

    while (reducedWidth > 2 * canvas.width) {
      reducedImageCtx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, reducedWidth >> 1, reducedHeight >> 1);
      reducedWidth >>= 1;
      reducedHeight >>= 1;
    }

    ctx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, canvas.width, canvas.height);

    this._convertCanvasToImage();
  }

  get _thumbPageTitle() {
    return this.l10n.get("thumb_page_title", {
      page: this.pageLabel !== null ? this.pageLabel : this.id
    }, "Page {{page}}");
  }

  get _thumbPageCanvas() {
    return this.l10n.get("thumb_page_canvas", {
      page: this.pageLabel !== null ? this.pageLabel : this.id
    }, "Thumbnail of Page {{page}}");
  }

  setPageLabel(label) {
    this.pageLabel = typeof label === "string" ? label : null;

    this._thumbPageTitle.then(msg => {
      this.anchor.title = msg;
    });

    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
      return;
    }

    this._thumbPageCanvas.then(msg => {
      if (this.image) {
        this.image.setAttribute("aria-label", msg);
      } else if (this.disableCanvasToImageConversion && this.canvas) {
        this.canvas.setAttribute("aria-label", msg);
      }
    });
  }

  static cleanup() {
    TempImageFactory.destroyCanvas();
  }

}

exports.PDFThumbnailView = PDFThumbnailView;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFViewer = void 0;

var _base_viewer = __webpack_require__(25);

var _pdfjsLib = __webpack_require__(5);

class PDFViewer extends _base_viewer.BaseViewer {
  get _viewerElement() {
    return (0, _pdfjsLib.shadow)(this, "_viewerElement", this.viewer);
  }

  _scrollIntoView({
    pageDiv,
    pageSpot = null,
    pageNumber = null
  }) {
    if (!pageSpot && !this.isInPresentationMode) {
      const left = pageDiv.offsetLeft + pageDiv.clientLeft;
      const right = left + pageDiv.clientWidth;
      const {
        scrollLeft,
        clientWidth
      } = this.container;

      if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) {
        pageSpot = {
          left: 0,
          top: 0
        };
      }
    }

    super._scrollIntoView({
      pageDiv,
      pageSpot,
      pageNumber
    });
  }

  _getVisiblePages() {
    if (this.isInPresentationMode) {
      return this._getCurrentVisiblePage();
    }

    return super._getVisiblePages();
  }

  _updateHelper(visiblePages) {
    if (this.isInPresentationMode) {
      return;
    }

    let currentId = this._currentPageNumber;
    let stillFullyVisible = false;

    for (const page of visiblePages) {
      if (page.percent < 100) {
        break;
      }

      if (page.id === currentId) {
        stillFullyVisible = true;
        break;
      }
    }

    if (!stillFullyVisible) {
      currentId = visiblePages[0].id;
    }

    this._setCurrentPageNumber(currentId);
  }

}

exports.PDFViewer = PDFViewer;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseViewer = void 0;

var _ui_utils = __webpack_require__(2);

var _pdf_rendering_queue = __webpack_require__(8);

var _annotation_layer_builder = __webpack_require__(26);

var _pdfjsLib = __webpack_require__(5);

var _pdf_page_view = __webpack_require__(27);

var _pdf_link_service = __webpack_require__(18);

var _text_layer_builder = __webpack_require__(28);

const DEFAULT_CACHE_SIZE = 10;

function PDFPageViewBuffer(size) {
  const data = [];

  this.push = function (view) {
    const i = data.indexOf(view);

    if (i >= 0) {
      data.splice(i, 1);
    }

    data.push(view);

    if (data.length > size) {
      data.shift().destroy();
    }
  };

  this.resize = function (newSize, pagesToKeep) {
    size = newSize;

    if (pagesToKeep) {
      const pageIdsToKeep = new Set();

      for (let i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {
        pageIdsToKeep.add(pagesToKeep[i].id);
      }

      (0, _ui_utils.moveToEndOfArray)(data, function (page) {
        return pageIdsToKeep.has(page.id);
      });
    }

    while (data.length > size) {
      data.shift().destroy();
    }
  };
}

function isSameScale(oldScale, newScale) {
  if (newScale === oldScale) {
    return true;
  }

  if (Math.abs(newScale - oldScale) < 1e-15) {
    return true;
  }

  return false;
}

class BaseViewer {
  constructor(options) {
    if (this.constructor === BaseViewer) {
      throw new Error("Cannot initialize BaseViewer.");
    }

    this._name = this.constructor.name;
    this.container = options.container;
    this.viewer = options.viewer || options.container.firstElementChild;
    this.eventBus = options.eventBus;
    this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
    this.downloadManager = options.downloadManager || null;
    this.findController = options.findController || null;
    this.removePageBorders = options.removePageBorders || false;
    this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
    this.imageResourcesPath = options.imageResourcesPath || "";
    this.renderInteractiveForms = options.renderInteractiveForms || false;
    this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
    this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
    this.enableWebGL = options.enableWebGL || false;
    this.useOnlyCssZoom = options.useOnlyCssZoom || false;
    this.maxCanvasPixels = options.maxCanvasPixels;
    this.l10n = options.l10n || _ui_utils.NullL10n;
    this.defaultRenderingQueue = !options.renderingQueue;

    if (this.defaultRenderingQueue) {
      this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
      this.renderingQueue.setViewer(this);
    } else {
      this.renderingQueue = options.renderingQueue;
    }

    this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
    this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
    this._onBeforeDraw = this._onAfterDraw = null;

    this._resetView();

    if (this.removePageBorders) {
      this.viewer.classList.add("removePageBorders");
    }

    Promise.resolve().then(() => {
      this.eventBus.dispatch("baseviewerinit", {
        source: this
      });
    });
  }

  get pagesCount() {
    return this._pages.length;
  }

  getPageView(index) {
    return this._pages[index];
  }

  get pageViewsReady() {
    if (!this._pagesCapability.settled) {
      return false;
    }

    return this._pages.every(function (pageView) {
      return pageView && pageView.pdfPage;
    });
  }

  get currentPageNumber() {
    return this._currentPageNumber;
  }

  set currentPageNumber(val) {
    if (!Number.isInteger(val)) {
      throw new Error("Invalid page number.");
    }

    if (!this.pdfDocument) {
      return;
    }

    if (!this._setCurrentPageNumber(val, true)) {
      console.error(`${this._name}.currentPageNumber: "${val}" is not a valid page.`);
    }
  }

  _setCurrentPageNumber(val, resetCurrentPageView = false) {
    if (this._currentPageNumber === val) {
      if (resetCurrentPageView) {
        this._resetCurrentPageView();
      }

      return true;
    }

    if (!(0 < val && val <= this.pagesCount)) {
      return false;
    }

    this._currentPageNumber = val;
    this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: val,
      pageLabel: this._pageLabels && this._pageLabels[val - 1]
    });

    if (resetCurrentPageView) {
      this._resetCurrentPageView();
    }

    return true;
  }

  get currentPageLabel() {
    return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];
  }

  set currentPageLabel(val) {
    if (!this.pdfDocument) {
      return;
    }

    let page = val | 0;

    if (this._pageLabels) {
      const i = this._pageLabels.indexOf(val);

      if (i >= 0) {
        page = i + 1;
      }
    }

    if (!this._setCurrentPageNumber(page, true)) {
      console.error(`${this._name}.currentPageLabel: "${val}" is not a valid page.`);
    }
  }

  get currentScale() {
    return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
  }

  set currentScale(val) {
    if (isNaN(val)) {
      throw new Error("Invalid numeric scale.");
    }

    if (!this.pdfDocument) {
      return;
    }

    this._setScale(val, false);
  }

  get currentScaleValue() {
    return this._currentScaleValue;
  }

  set currentScaleValue(val) {
    if (!this.pdfDocument) {
      return;
    }

    this._setScale(val, false);
  }

  get pagesRotation() {
    return this._pagesRotation;
  }

  set pagesRotation(rotation) {
    if (!(0, _ui_utils.isValidRotation)(rotation)) {
      throw new Error("Invalid pages rotation angle.");
    }

    if (!this.pdfDocument) {
      return;
    }

    if (this._pagesRotation === rotation) {
      return;
    }

    this._pagesRotation = rotation;
    const pageNumber = this._currentPageNumber;

    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      const pageView = this._pages[i];
      pageView.update(pageView.scale, rotation);
    }

    if (this._currentScaleValue) {
      this._setScale(this._currentScaleValue, true);
    }

    this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: rotation,
      pageNumber
    });

    if (this.defaultRenderingQueue) {
      this.update();
    }
  }

  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }

  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }

  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }

  get _viewerElement() {
    throw new Error("Not implemented: _viewerElement");
  }

  _onePageRenderedOrForceFetch() {
    if (!this.container.offsetParent || this._getVisiblePages().views.length === 0) {
      return Promise.resolve();
    }

    return this._onePageRenderedCapability.promise;
  }

  setDocument(pdfDocument) {
    if (this.pdfDocument) {
      this._cancelRendering();

      this._resetView();

      if (this.findController) {
        this.findController.setDocument(null);
      }
    }

    this.pdfDocument = pdfDocument;

    if (!pdfDocument) {
      return;
    }

    const pagesCount = pdfDocument.numPages;
    const firstPagePromise = pdfDocument.getPage(1);

    this._pagesCapability.promise.then(() => {
      this.eventBus.dispatch("pagesloaded", {
        source: this,
        pagesCount
      });
    });

    this._onBeforeDraw = evt => {
      const pageView = this._pages[evt.pageNumber - 1];

      if (!pageView) {
        return;
      }

      this._buffer.push(pageView);
    };

    this.eventBus._on("pagerender", this._onBeforeDraw);

    this._onAfterDraw = evt => {
      if (evt.cssTransform || this._onePageRenderedCapability.settled) {
        return;
      }

      this._onePageRenderedCapability.resolve();

      this.eventBus._off("pagerendered", this._onAfterDraw);

      this._onAfterDraw = null;
    };

    this.eventBus._on("pagerendered", this._onAfterDraw);

    firstPagePromise.then(firstPdfPage => {
      this._firstPageCapability.resolve(firstPdfPage);

      const scale = this.currentScale;
      const viewport = firstPdfPage.getViewport({
        scale: scale * _ui_utils.CSS_UNITS
      });
      const textLayerFactory = this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? this : null;

      for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
        const pageView = new _pdf_page_view.PDFPageView({
          container: this._viewerElement,
          eventBus: this.eventBus,
          id: pageNum,
          scale,
          defaultViewport: viewport.clone(),
          renderingQueue: this.renderingQueue,
          textLayerFactory,
          textLayerMode: this.textLayerMode,
          annotationLayerFactory: this,
          imageResourcesPath: this.imageResourcesPath,
          renderInteractiveForms: this.renderInteractiveForms,
          renderer: this.renderer,
          enableWebGL: this.enableWebGL,
          useOnlyCssZoom: this.useOnlyCssZoom,
          maxCanvasPixels: this.maxCanvasPixels,
          l10n: this.l10n
        });

        this._pages.push(pageView);
      }

      const firstPageView = this._pages[0];

      if (firstPageView) {
        firstPageView.setPdfPage(firstPdfPage);
        this.linkService.cachePageRef(1, firstPdfPage.ref);
      }

      if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
        this._updateSpreadMode();
      }

      this._onePageRenderedOrForceFetch().then(() => {
        if (this.findController) {
          this.findController.setDocument(pdfDocument);
        }

        if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) {
          this._pagesCapability.resolve();

          return;
        }

        let getPagesLeft = pagesCount - 1;

        if (getPagesLeft <= 0) {
          this._pagesCapability.resolve();

          return;
        }

        for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
          pdfDocument.getPage(pageNum).then(pdfPage => {
            const pageView = this._pages[pageNum - 1];

            if (!pageView.pdfPage) {
              pageView.setPdfPage(pdfPage);
            }

            this.linkService.cachePageRef(pageNum, pdfPage.ref);

            if (--getPagesLeft === 0) {
              this._pagesCapability.resolve();
            }
          }, reason => {
            console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);

            if (--getPagesLeft === 0) {
              this._pagesCapability.resolve();
            }
          });
        }
      });

      this.eventBus.dispatch("pagesinit", {
        source: this
      });

      if (this.defaultRenderingQueue) {
        this.update();
      }
    }).catch(reason => {
      console.error("Unable to initialize viewer", reason);
    });
  }

  setPageLabels(labels) {
    if (!this.pdfDocument) {
      return;
    }

    if (!labels) {
      this._pageLabels = null;
    } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
      this._pageLabels = null;
      console.error(`${this._name}.setPageLabels: Invalid page labels.`);
    } else {
      this._pageLabels = labels;
    }

    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      const pageView = this._pages[i];
      const label = this._pageLabels && this._pageLabels[i];
      pageView.setPageLabel(label);
    }
  }

  _resetView() {
    this._pages = [];
    this._currentPageNumber = 1;
    this._currentScale = _ui_utils.UNKNOWN_SCALE;
    this._currentScaleValue = null;
    this._pageLabels = null;
    this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
    this._location = null;
    this._pagesRotation = 0;
    this._pagesRequests = new WeakMap();
    this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
    this._spreadMode = _ui_utils.SpreadMode.NONE;

    if (this._onBeforeDraw) {
      this.eventBus._off("pagerender", this._onBeforeDraw);

      this._onBeforeDraw = null;
    }

    if (this._onAfterDraw) {
      this.eventBus._off("pagerendered", this._onAfterDraw);

      this._onAfterDraw = null;
    }

    this.viewer.textContent = "";

    this._updateScrollMode();
  }

  _scrollUpdate() {
    if (this.pagesCount === 0) {
      return;
    }

    this.update();
  }

  _scrollIntoView({
    pageDiv,
    pageSpot = null,
    pageNumber = null
  }) {
    (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);
  }

  _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {
    this._currentScaleValue = newValue.toString();

    if (isSameScale(this._currentScale, newScale)) {
      if (preset) {
        this.eventBus.dispatch("scalechanging", {
          source: this,
          scale: newScale,
          presetValue: newValue
        });
      }

      return;
    }

    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      this._pages[i].update(newScale);
    }

    this._currentScale = newScale;

    if (!noScroll) {
      let page = this._currentPageNumber,
          dest;

      if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
        page = this._location.pageNumber;
        dest = [null, {
          name: "XYZ"
        }, this._location.left, this._location.top, null];
      }

      this.scrollPageIntoView({
        pageNumber: page,
        destArray: dest,
        allowNegativeOffset: true
      });
    }

    this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: newScale,
      presetValue: preset ? newValue : undefined
    });

    if (this.defaultRenderingQueue) {
      this.update();
    }
  }

  _setScale(value, noScroll = false) {
    let scale = parseFloat(value);

    if (scale > 0) {
      this._setScaleUpdatePages(scale, value, noScroll, false);
    } else {
      const currentPage = this._pages[this._currentPageNumber - 1];

      if (!currentPage) {
        return;
      }

      const noPadding = this.isInPresentationMode || this.removePageBorders;
      let hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING;
      let vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING;

      if (!noPadding && this._isScrollModeHorizontal) {
        [hPadding, vPadding] = [vPadding, hPadding];
      }

      const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale;
      const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;

      switch (value) {
        case "page-actual":
          scale = 1;
          break;

        case "page-width":
          scale = pageWidthScale;
          break;

        case "page-height":
          scale = pageHeightScale;
          break;

        case "page-fit":
          scale = Math.min(pageWidthScale, pageHeightScale);
          break;

        case "auto":
          const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
          scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
          break;

        default:
          console.error(`${this._name}._setScale: "${value}" is an unknown zoom value.`);
          return;
      }

      this._setScaleUpdatePages(scale, value, noScroll, true);
    }
  }

  _resetCurrentPageView() {
    if (this.isInPresentationMode) {
      this._setScale(this._currentScaleValue, true);
    }

    const pageView = this._pages[this._currentPageNumber - 1];

    this._scrollIntoView({
      pageDiv: pageView.div
    });
  }

  scrollPageIntoView({
    pageNumber,
    destArray = null,
    allowNegativeOffset = false,
    ignoreDestinationZoom = false
  }) {
    if (!this.pdfDocument) {
      return;
    }

    const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];

    if (!pageView) {
      console.error(`${this._name}.scrollPageIntoView: ` + `"${pageNumber}" is not a valid pageNumber parameter.`);
      return;
    }

    if (this.isInPresentationMode || !destArray) {
      this._setCurrentPageNumber(pageNumber, true);

      return;
    }

    let x = 0,
        y = 0;
    let width = 0,
        height = 0,
        widthScale,
        heightScale;
    const changeOrientation = pageView.rotation % 180 !== 0;
    const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS;
    const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS;
    let scale = 0;

    switch (destArray[1].name) {
      case "XYZ":
        x = destArray[2];
        y = destArray[3];
        scale = destArray[4];
        x = x !== null ? x : 0;
        y = y !== null ? y : pageHeight;
        break;

      case "Fit":
      case "FitB":
        scale = "page-fit";
        break;

      case "FitH":
      case "FitBH":
        y = destArray[2];
        scale = "page-width";

        if (y === null && this._location) {
          x = this._location.left;
          y = this._location.top;
        }

        break;

      case "FitV":
      case "FitBV":
        x = destArray[2];
        width = pageWidth;
        height = pageHeight;
        scale = "page-height";
        break;

      case "FitR":
        x = destArray[2];
        y = destArray[3];
        width = destArray[4] - x;
        height = destArray[5] - y;
        const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
        const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
        widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS;
        heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS;
        scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
        break;

      default:
        console.error(`${this._name}.scrollPageIntoView: ` + `"${destArray[1].name}" is not a valid destination type.`);
        return;
    }

    if (!ignoreDestinationZoom) {
      if (scale && scale !== this._currentScale) {
        this.currentScaleValue = scale;
      } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
        this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
      }
    }

    if (scale === "page-fit" && !destArray[4]) {
      this._scrollIntoView({
        pageDiv: pageView.div,
        pageNumber
      });

      return;
    }

    const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
    let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
    let top = Math.min(boundingRect[0][1], boundingRect[1][1]);

    if (!allowNegativeOffset) {
      left = Math.max(left, 0);
      top = Math.max(top, 0);
    }

    this._scrollIntoView({
      pageDiv: pageView.div,
      pageSpot: {
        left,
        top
      },
      pageNumber
    });
  }

  _updateLocation(firstPage) {
    const currentScale = this._currentScale;
    const currentScaleValue = this._currentScaleValue;
    const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
    const pageNumber = firstPage.id;
    let pdfOpenParams = "#page=" + pageNumber;
    pdfOpenParams += "&zoom=" + normalizedScaleValue;
    const currentPageView = this._pages[pageNumber - 1];
    const container = this.container;
    const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
    const intLeft = Math.round(topLeft[0]);
    const intTop = Math.round(topLeft[1]);
    pdfOpenParams += "," + intLeft + "," + intTop;
    this._location = {
      pageNumber,
      scale: normalizedScaleValue,
      top: intTop,
      left: intLeft,
      rotation: this._pagesRotation,
      pdfOpenParams
    };
  }

  _updateHelper(visiblePages) {
    throw new Error("Not implemented: _updateHelper");
  }

  update() {
    const visible = this._getVisiblePages();

    const visiblePages = visible.views,
          numVisiblePages = visiblePages.length;

    if (numVisiblePages === 0) {
      return;
    }

    const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);

    this._buffer.resize(newCacheSize, visiblePages);

    this.renderingQueue.renderHighestPriority(visible);

    this._updateHelper(visiblePages);

    this._updateLocation(visible.first);

    this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }

  containsElement(element) {
    return this.container.contains(element);
  }

  focus() {
    this.container.focus();
  }

  get _isScrollModeHorizontal() {
    return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL;
  }

  get isInPresentationMode() {
    return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
  }

  get isChangingPresentationMode() {
    return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
  }

  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
  }

  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
  }

  _getCurrentVisiblePage() {
    if (!this.pagesCount) {
      return {
        views: []
      };
    }

    const pageView = this._pages[this._currentPageNumber - 1];
    const element = pageView.div;
    const view = {
      id: pageView.id,
      x: element.offsetLeft + element.clientLeft,
      y: element.offsetTop + element.clientTop,
      view: pageView
    };
    return {
      first: view,
      last: view,
      views: [view]
    };
  }

  _getVisiblePages() {
    return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true, this._isScrollModeHorizontal);
  }

  isPageVisible(pageNumber) {
    if (!this.pdfDocument) {
      return false;
    }

    if (pageNumber < 1 || pageNumber > this.pagesCount) {
      console.error(`${this._name}.isPageVisible: "${pageNumber}" is out of bounds.`);
      return false;
    }

    return this._getVisiblePages().views.some(function (view) {
      return view.id === pageNumber;
    });
  }

  cleanup() {
    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
        this._pages[i].reset();
      }
    }
  }

  _cancelRendering() {
    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      if (this._pages[i]) {
        this._pages[i].cancelRendering();
      }
    }
  }

  _ensurePdfPageLoaded(pageView) {
    if (pageView.pdfPage) {
      return Promise.resolve(pageView.pdfPage);
    }

    if (this._pagesRequests.has(pageView)) {
      return this._pagesRequests.get(pageView);
    }

    const promise = this.pdfDocument.getPage(pageView.id).then(pdfPage => {
      if (!pageView.pdfPage) {
        pageView.setPdfPage(pdfPage);
      }

      this._pagesRequests.delete(pageView);

      return pdfPage;
    }).catch(reason => {
      console.error("Unable to get page for page view", reason);

      this._pagesRequests.delete(pageView);
    });

    this._pagesRequests.set(pageView, promise);

    return promise;
  }

  forceRendering(currentlyVisiblePages) {
    const visiblePages = currentlyVisiblePages || this._getVisiblePages();

    const scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down;
    const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead);

    if (pageView) {
      this._ensurePdfPageLoaded(pageView).then(() => {
        this.renderingQueue.renderView(pageView);
      });

      return true;
    }

    return false;
  }

  createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) {
    return new _text_layer_builder.TextLayerBuilder({
      textLayerDiv,
      eventBus,
      pageIndex,
      viewport,
      findController: this.isInPresentationMode ? null : this.findController,
      enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection
    });
  }

  createAnnotationLayerBuilder(pageDiv, pdfPage, imageResourcesPath = "", renderInteractiveForms = false, l10n = _ui_utils.NullL10n) {
    return new _annotation_layer_builder.AnnotationLayerBuilder({
      pageDiv,
      pdfPage,
      imageResourcesPath,
      renderInteractiveForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      l10n
    });
  }

  get hasEqualPageSizes() {
    const firstPageView = this._pages[0];

    for (let i = 1, ii = this._pages.length; i < ii; ++i) {
      const pageView = this._pages[i];

      if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
        return false;
      }
    }

    return true;
  }

  getPagesOverview() {
    const pagesOverview = this._pages.map(function (pageView) {
      const viewport = pageView.pdfPage.getViewport({
        scale: 1
      });
      return {
        width: viewport.width,
        height: viewport.height,
        rotation: viewport.rotation
      };
    });

    if (!this.enablePrintAutoRotate) {
      return pagesOverview;
    }

    const isFirstPagePortrait = (0, _ui_utils.isPortraitOrientation)(pagesOverview[0]);
    return pagesOverview.map(function (size) {
      if (isFirstPagePortrait === (0, _ui_utils.isPortraitOrientation)(size)) {
        return size;
      }

      return {
        width: size.height,
        height: size.width,
        rotation: (size.rotation + 90) % 360
      };
    });
  }

  get scrollMode() {
    return this._scrollMode;
  }

  set scrollMode(mode) {
    if (this._scrollMode === mode) {
      return;
    }

    if (!(0, _ui_utils.isValidScrollMode)(mode)) {
      throw new Error(`Invalid scroll mode: ${mode}`);
    }

    this._scrollMode = mode;
    this.eventBus.dispatch("scrollmodechanged", {
      source: this,
      mode
    });

    this._updateScrollMode(this._currentPageNumber);
  }

  _updateScrollMode(pageNumber = null) {
    const scrollMode = this._scrollMode,
          viewer = this.viewer;
    viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
    viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);

    if (!this.pdfDocument || !pageNumber) {
      return;
    }

    if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
      this._setScale(this._currentScaleValue, true);
    }

    this._setCurrentPageNumber(pageNumber, true);

    this.update();
  }

  get spreadMode() {
    return this._spreadMode;
  }

  set spreadMode(mode) {
    if (this._spreadMode === mode) {
      return;
    }

    if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
      throw new Error(`Invalid spread mode: ${mode}`);
    }

    this._spreadMode = mode;
    this.eventBus.dispatch("spreadmodechanged", {
      source: this,
      mode
    });

    this._updateSpreadMode(this._currentPageNumber);
  }

  _updateSpreadMode(pageNumber = null) {
    if (!this.pdfDocument) {
      return;
    }

    const viewer = this.viewer,
          pages = this._pages;
    viewer.textContent = "";

    if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
      for (let i = 0, iMax = pages.length; i < iMax; ++i) {
        viewer.appendChild(pages[i].div);
      }
    } else {
      const parity = this._spreadMode - 1;
      let spread = null;

      for (let i = 0, iMax = pages.length; i < iMax; ++i) {
        if (spread === null) {
          spread = document.createElement("div");
          spread.className = "spread";
          viewer.appendChild(spread);
        } else if (i % 2 === parity) {
          spread = spread.cloneNode(false);
          viewer.appendChild(spread);
        }

        spread.appendChild(pages[i].div);
      }
    }

    if (!pageNumber) {
      return;
    }

    this._setCurrentPageNumber(pageNumber, true);

    this.update();
  }

}

exports.BaseViewer = BaseViewer;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0;

var _pdfjsLib = __webpack_require__(5);

var _ui_utils = __webpack_require__(2);

var _pdf_link_service = __webpack_require__(18);

class AnnotationLayerBuilder {
  constructor({
    pageDiv,
    pdfPage,
    linkService,
    downloadManager,
    imageResourcesPath = "",
    renderInteractiveForms = false,
    l10n = _ui_utils.NullL10n
  }) {
    this.pageDiv = pageDiv;
    this.pdfPage = pdfPage;
    this.linkService = linkService;
    this.downloadManager = downloadManager;
    this.imageResourcesPath = imageResourcesPath;
    this.renderInteractiveForms = renderInteractiveForms;
    this.l10n = l10n;
    this.div = null;
    this._cancelled = false;
  }

  render(viewport, intent = "display") {
    this.pdfPage.getAnnotations({
      intent
    }).then(annotations => {
      if (this._cancelled) {
        return;
      }

      const parameters = {
        viewport: viewport.clone({
          dontFlip: true
        }),
        div: this.div,
        annotations,
        page: this.pdfPage,
        imageResourcesPath: this.imageResourcesPath,
        renderInteractiveForms: this.renderInteractiveForms,
        linkService: this.linkService,
        downloadManager: this.downloadManager
      };

      if (this.div) {
        _pdfjsLib.AnnotationLayer.update(parameters);
      } else {
        if (annotations.length === 0) {
          return;
        }

        this.div = document.createElement("div");
        this.div.className = "annotationLayer";
        this.pageDiv.appendChild(this.div);
        parameters.div = this.div;

        _pdfjsLib.AnnotationLayer.render(parameters);

        this.l10n.translate(this.div);
      }
    });
  }

  cancel() {
    this._cancelled = true;
  }

  hide() {
    if (!this.div) {
      return;
    }

    this.div.setAttribute("hidden", "true");
  }

}

exports.AnnotationLayerBuilder = AnnotationLayerBuilder;

class DefaultAnnotationLayerFactory {
  createAnnotationLayerBuilder(pageDiv, pdfPage, imageResourcesPath = "", renderInteractiveForms = false, l10n = _ui_utils.NullL10n) {
    return new AnnotationLayerBuilder({
      pageDiv,
      pdfPage,
      imageResourcesPath,
      renderInteractiveForms,
      linkService: new _pdf_link_service.SimpleLinkService(),
      l10n
    });
  }

}

exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFPageView = void 0;

var _ui_utils = __webpack_require__(2);

var _pdfjsLib = __webpack_require__(5);

var _pdf_rendering_queue = __webpack_require__(8);

var _viewer_compatibility = __webpack_require__(4);

const MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216;

class PDFPageView {
  constructor(options) {
    const container = options.container;
    const defaultViewport = options.defaultViewport;
    this.id = options.id;
    this.renderingId = "page" + this.id;
    this.pdfPage = null;
    this.pageLabel = null;
    this.rotation = 0;
    this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
    this.viewport = defaultViewport;
    this.pdfPageRotate = defaultViewport.rotation;
    this.hasRestrictedScaling = false;
    this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
    this.imageResourcesPath = options.imageResourcesPath || "";
    this.renderInteractiveForms = options.renderInteractiveForms || false;
    this.useOnlyCssZoom = options.useOnlyCssZoom || false;
    this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
    this.eventBus = options.eventBus;
    this.renderingQueue = options.renderingQueue;
    this.textLayerFactory = options.textLayerFactory;
    this.annotationLayerFactory = options.annotationLayerFactory;
    this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
    this.enableWebGL = options.enableWebGL || false;
    this.l10n = options.l10n || _ui_utils.NullL10n;
    this.paintTask = null;
    this.paintedViewportMap = new WeakMap();
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    this.resume = null;
    this.error = null;
    this.annotationLayer = null;
    this.textLayer = null;
    this.zoomLayer = null;
    const div = document.createElement("div");
    div.className = "page";
    div.style.width = Math.floor(this.viewport.width) + "px";
    div.style.height = Math.floor(this.viewport.height) + "px";
    div.setAttribute("data-page-number", this.id);
    this.div = div;
    container.appendChild(div);
  }

  setPdfPage(pdfPage) {
    this.pdfPage = pdfPage;
    this.pdfPageRotate = pdfPage.rotate;
    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = pdfPage.getViewport({
      scale: this.scale * _ui_utils.CSS_UNITS,
      rotation: totalRotation
    });
    this.stats = pdfPage.stats;
    this.reset();
  }

  destroy() {
    this.reset();

    if (this.pdfPage) {
      this.pdfPage.cleanup();
    }
  }

  _resetZoomLayer(removeFromDOM = false) {
    if (!this.zoomLayer) {
      return;
    }

    const zoomLayerCanvas = this.zoomLayer.firstChild;
    this.paintedViewportMap.delete(zoomLayerCanvas);
    zoomLayerCanvas.width = 0;
    zoomLayerCanvas.height = 0;

    if (removeFromDOM) {
      this.zoomLayer.remove();
    }

    this.zoomLayer = null;
  }

  reset(keepZoomLayer = false, keepAnnotations = false) {
    this.cancelRendering(keepAnnotations);
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    const div = this.div;
    div.style.width = Math.floor(this.viewport.width) + "px";
    div.style.height = Math.floor(this.viewport.height) + "px";
    const childNodes = div.childNodes;
    const currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;
    const currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null;

    for (let i = childNodes.length - 1; i >= 0; i--) {
      const node = childNodes[i];

      if (currentZoomLayerNode === node || currentAnnotationNode === node) {
        continue;
      }

      div.removeChild(node);
    }

    div.removeAttribute("data-loaded");

    if (currentAnnotationNode) {
      this.annotationLayer.hide();
    } else if (this.annotationLayer) {
      this.annotationLayer.cancel();
      this.annotationLayer = null;
    }

    if (!currentZoomLayerNode) {
      if (this.canvas) {
        this.paintedViewportMap.delete(this.canvas);
        this.canvas.width = 0;
        this.canvas.height = 0;
        delete this.canvas;
      }

      this._resetZoomLayer();
    }

    if (this.svg) {
      this.paintedViewportMap.delete(this.svg);
      delete this.svg;
    }

    this.loadingIconDiv = document.createElement("div");
    this.loadingIconDiv.className = "loadingIcon";
    div.appendChild(this.loadingIconDiv);
  }

  update(scale, rotation) {
    this.scale = scale || this.scale;

    if (typeof rotation !== "undefined") {
      this.rotation = rotation;
    }

    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = this.viewport.clone({
      scale: this.scale * _ui_utils.CSS_UNITS,
      rotation: totalRotation
    });

    if (this.svg) {
      this.cssTransform(this.svg, true);
      this.eventBus.dispatch("pagerendered", {
        source: this,
        pageNumber: this.id,
        cssTransform: true,
        timestamp: performance.now()
      });
      return;
    }

    let isScalingRestricted = false;

    if (this.canvas && this.maxCanvasPixels > 0) {
      const outputScale = this.outputScale;

      if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
        isScalingRestricted = true;
      }
    }

    if (this.canvas) {
      if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
        this.cssTransform(this.canvas, true);
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: true,
          timestamp: performance.now()
        });
        return;
      }

      if (!this.zoomLayer && !this.canvas.hasAttribute("hidden")) {
        this.zoomLayer = this.canvas.parentNode;
        this.zoomLayer.style.position = "absolute";
      }
    }

    if (this.zoomLayer) {
      this.cssTransform(this.zoomLayer.firstChild);
    }

    this.reset(true, true);
  }

  cancelRendering(keepAnnotations = false) {
    if (this.paintTask) {
      this.paintTask.cancel();
      this.paintTask = null;
    }

    this.resume = null;

    if (this.textLayer) {
      this.textLayer.cancel();
      this.textLayer = null;
    }

    if (!keepAnnotations && this.annotationLayer) {
      this.annotationLayer.cancel();
      this.annotationLayer = null;
    }
  }

  cssTransform(target, redrawAnnotations = false) {
    const width = this.viewport.width;
    const height = this.viewport.height;
    const div = this.div;
    target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
    target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
    const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
    const absRotation = Math.abs(relativeRotation);
    let scaleX = 1,
        scaleY = 1;

    if (absRotation === 90 || absRotation === 270) {
      scaleX = height / width;
      scaleY = width / height;
    }

    const cssTransform = "rotate(" + relativeRotation + "deg) " + "scale(" + scaleX + "," + scaleY + ")";
    target.style.transform = cssTransform;

    if (this.textLayer) {
      const textLayerViewport = this.textLayer.viewport;
      const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
      const textAbsRotation = Math.abs(textRelativeRotation);
      let scale = width / textLayerViewport.width;

      if (textAbsRotation === 90 || textAbsRotation === 270) {
        scale = width / textLayerViewport.height;
      }

      const textLayerDiv = this.textLayer.textLayerDiv;
      let transX, transY;

      switch (textAbsRotation) {
        case 0:
          transX = transY = 0;
          break;

        case 90:
          transX = 0;
          transY = "-" + textLayerDiv.style.height;
          break;

        case 180:
          transX = "-" + textLayerDiv.style.width;
          transY = "-" + textLayerDiv.style.height;
          break;

        case 270:
          transX = "-" + textLayerDiv.style.width;
          transY = 0;
          break;

        default:
          console.error("Bad rotation value.");
          break;
      }

      textLayerDiv.style.transform = "rotate(" + textAbsRotation + "deg) " + "scale(" + scale + ", " + scale + ") " + "translate(" + transX + ", " + transY + ")";
      textLayerDiv.style.transformOrigin = "0% 0%";
    }

    if (redrawAnnotations && this.annotationLayer) {
      this.annotationLayer.render(this.viewport, "display");
    }
  }

  get width() {
    return this.viewport.width;
  }

  get height() {
    return this.viewport.height;
  }

  getPagePoint(x, y) {
    return this.viewport.convertToPdfPoint(x, y);
  }

  draw() {
    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
      console.error("Must be in new state before drawing");
      this.reset();
    }

    const {
      div,
      pdfPage
    } = this;

    if (!pdfPage) {
      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

      if (this.loadingIconDiv) {
        div.removeChild(this.loadingIconDiv);
        delete this.loadingIconDiv;
      }

      return Promise.reject(new Error("pdfPage is not loaded"));
    }

    this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
    const canvasWrapper = document.createElement("div");
    canvasWrapper.style.width = div.style.width;
    canvasWrapper.style.height = div.style.height;
    canvasWrapper.classList.add("canvasWrapper");

    if (this.annotationLayer && this.annotationLayer.div) {
      div.insertBefore(canvasWrapper, this.annotationLayer.div);
    } else {
      div.appendChild(canvasWrapper);
    }

    let textLayer = null;

    if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
      const textLayerDiv = document.createElement("div");
      textLayerDiv.className = "textLayer";
      textLayerDiv.style.width = canvasWrapper.style.width;
      textLayerDiv.style.height = canvasWrapper.style.height;

      if (this.annotationLayer && this.annotationLayer.div) {
        div.insertBefore(textLayerDiv, this.annotationLayer.div);
      } else {
        div.appendChild(textLayerDiv);
      }

      textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus);
    }

    this.textLayer = textLayer;
    let renderContinueCallback = null;

    if (this.renderingQueue) {
      renderContinueCallback = cont => {
        if (!this.renderingQueue.isHighestPriority(this)) {
          this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;

          this.resume = () => {
            this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
            cont();
          };

          return;
        }

        cont();
      };
    }

    const finishPaintTask = async error => {
      if (paintTask === this.paintTask) {
        this.paintTask = null;
      }

      if (error instanceof _pdfjsLib.RenderingCancelledException) {
        this.error = null;
        return;
      }

      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

      if (this.loadingIconDiv) {
        div.removeChild(this.loadingIconDiv);
        delete this.loadingIconDiv;
      }

      this._resetZoomLayer(true);

      this.error = error;
      this.stats = pdfPage.stats;
      this.eventBus.dispatch("pagerendered", {
        source: this,
        pageNumber: this.id,
        cssTransform: false,
        timestamp: performance.now()
      });

      if (error) {
        throw error;
      }
    };

    const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
    paintTask.onRenderContinue = renderContinueCallback;
    this.paintTask = paintTask;
    const resultPromise = paintTask.promise.then(function () {
      return finishPaintTask(null).then(function () {
        if (textLayer) {
          const readableStream = pdfPage.streamTextContent({
            normalizeWhitespace: true
          });
          textLayer.setTextContentStream(readableStream);
          textLayer.render();
        }
      });
    }, function (reason) {
      return finishPaintTask(reason);
    });

    if (this.annotationLayerFactory) {
      if (!this.annotationLayer) {
        this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this.imageResourcesPath, this.renderInteractiveForms, this.l10n);
      }

      this.annotationLayer.render(this.viewport, "display");
    }

    div.setAttribute("data-loaded", true);
    this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    });
    return resultPromise;
  }

  paintOnCanvas(canvasWrapper) {
    const renderCapability = (0, _pdfjsLib.createPromiseCapability)();
    const result = {
      promise: renderCapability.promise,

      onRenderContinue(cont) {
        cont();
      },

      cancel() {
        renderTask.cancel();
      }

    };
    const viewport = this.viewport;
    const canvas = document.createElement("canvas");
    this.l10n.get("page_canvas", {
      page: this.id
    }, "Page {{page}}").then(msg => {
      canvas.setAttribute("aria-label", msg);
    });
    canvas.setAttribute("hidden", "hidden");
    let isCanvasHidden = true;

    const showCanvas = function () {
      if (isCanvasHidden) {
        canvas.removeAttribute("hidden");
        isCanvasHidden = false;
      }
    };

    canvasWrapper.appendChild(canvas);
    this.canvas = canvas;
    canvas.mozOpaque = true;
    const ctx = canvas.getContext("2d", {
      alpha: false
    });
    const outputScale = (0, _ui_utils.getOutputScale)(ctx);
    this.outputScale = outputScale;

    if (this.useOnlyCssZoom) {
      const actualSizeViewport = viewport.clone({
        scale: _ui_utils.CSS_UNITS
      });
      outputScale.sx *= actualSizeViewport.width / viewport.width;
      outputScale.sy *= actualSizeViewport.height / viewport.height;
      outputScale.scaled = true;
    }

    if (this.maxCanvasPixels > 0) {
      const pixelsInViewport = viewport.width * viewport.height;
      const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);

      if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
        outputScale.sx = maxScale;
        outputScale.sy = maxScale;
        outputScale.scaled = true;
        this.hasRestrictedScaling = true;
      } else {
        this.hasRestrictedScaling = false;
      }
    }

    const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
    const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
    canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
    canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
    canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
    canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
    this.paintedViewportMap.set(canvas, viewport);
    const transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
    const renderContext = {
      canvasContext: ctx,
      transform,
      viewport: this.viewport,
      enableWebGL: this.enableWebGL,
      renderInteractiveForms: this.renderInteractiveForms
    };
    const renderTask = this.pdfPage.render(renderContext);

    renderTask.onContinue = function (cont) {
      showCanvas();

      if (result.onRenderContinue) {
        result.onRenderContinue(cont);
      } else {
        cont();
      }
    };

    renderTask.promise.then(function () {
      showCanvas();
      renderCapability.resolve(undefined);
    }, function (error) {
      showCanvas();
      renderCapability.reject(error);
    });
    return result;
  }

  paintOnSvg(wrapper) {
    let cancelled = false;

    const ensureNotCancelled = () => {
      if (cancelled) {
        throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, "svg");
      }
    };

    const pdfPage = this.pdfPage;
    const actualSizeViewport = this.viewport.clone({
      scale: _ui_utils.CSS_UNITS
    });
    const promise = pdfPage.getOperatorList().then(opList => {
      ensureNotCancelled();
      const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
      return svgGfx.getSVG(opList, actualSizeViewport).then(svg => {
        ensureNotCancelled();
        this.svg = svg;
        this.paintedViewportMap.set(svg, actualSizeViewport);
        svg.style.width = wrapper.style.width;
        svg.style.height = wrapper.style.height;
        this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
        wrapper.appendChild(svg);
      });
    });
    return {
      promise,

      onRenderContinue(cont) {
        cont();
      },

      cancel() {
        cancelled = true;
      }

    };
  }

  setPageLabel(label) {
    this.pageLabel = typeof label === "string" ? label : null;

    if (this.pageLabel !== null) {
      this.div.setAttribute("data-page-label", this.pageLabel);
    } else {
      this.div.removeAttribute("data-page-label");
    }
  }

}

exports.PDFPageView = PDFPageView;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultTextLayerFactory = exports.TextLayerBuilder = void 0;

var _pdfjsLib = __webpack_require__(5);

const EXPAND_DIVS_TIMEOUT = 300;

class TextLayerBuilder {
  constructor({
    textLayerDiv,
    eventBus,
    pageIndex,
    viewport,
    findController = null,
    enhanceTextSelection = false
  }) {
    this.textLayerDiv = textLayerDiv;
    this.eventBus = eventBus;
    this.textContent = null;
    this.textContentItemsStr = [];
    this.textContentStream = null;
    this.renderingDone = false;
    this.pageIdx = pageIndex;
    this.pageNumber = this.pageIdx + 1;
    this.matches = [];
    this.viewport = viewport;
    this.textDivs = [];
    this.findController = findController;
    this.textLayerRenderTask = null;
    this.enhanceTextSelection = enhanceTextSelection;
    this._onUpdateTextLayerMatches = null;

    this._bindMouse();
  }

  _finishRendering() {
    this.renderingDone = true;

    if (!this.enhanceTextSelection) {
      const endOfContent = document.createElement("div");
      endOfContent.className = "endOfContent";
      this.textLayerDiv.appendChild(endOfContent);
    }

    this.eventBus.dispatch("textlayerrendered", {
      source: this,
      pageNumber: this.pageNumber,
      numTextDivs: this.textDivs.length
    });
  }

  render(timeout = 0) {
    if (!(this.textContent || this.textContentStream) || this.renderingDone) {
      return;
    }

    this.cancel();
    this.textDivs = [];
    const textLayerFrag = document.createDocumentFragment();
    this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
      textContent: this.textContent,
      textContentStream: this.textContentStream,
      container: textLayerFrag,
      viewport: this.viewport,
      textDivs: this.textDivs,
      textContentItemsStr: this.textContentItemsStr,
      timeout,
      enhanceTextSelection: this.enhanceTextSelection
    });
    this.textLayerRenderTask.promise.then(() => {
      this.textLayerDiv.appendChild(textLayerFrag);

      this._finishRendering();

      this._updateMatches();
    }, function (reason) {});

    if (!this._onUpdateTextLayerMatches) {
      this._onUpdateTextLayerMatches = evt => {
        if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
          this._updateMatches();
        }
      };

      this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
    }
  }

  cancel() {
    if (this.textLayerRenderTask) {
      this.textLayerRenderTask.cancel();
      this.textLayerRenderTask = null;
    }

    if (this._onUpdateTextLayerMatches) {
      this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);

      this._onUpdateTextLayerMatches = null;
    }
  }

  setTextContentStream(readableStream) {
    this.cancel();
    this.textContentStream = readableStream;
  }

  setTextContent(textContent) {
    this.cancel();
    this.textContent = textContent;
  }

  _convertMatches(matches, matchesLength) {
    if (!matches) {
      return [];
    }

    const {
      findController,
      textContentItemsStr
    } = this;
    let i = 0,
        iIndex = 0;
    const end = textContentItemsStr.length - 1;
    const queryLen = findController.state.query.length;
    const result = [];

    for (let m = 0, mm = matches.length; m < mm; m++) {
      let matchIdx = matches[m];

      while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
        iIndex += textContentItemsStr[i].length;
        i++;
      }

      if (i === textContentItemsStr.length) {
        console.error("Could not find a matching mapping");
      }

      const match = {
        begin: {
          divIdx: i,
          offset: matchIdx - iIndex
        }
      };

      if (matchesLength) {
        matchIdx += matchesLength[m];
      } else {
        matchIdx += queryLen;
      }

      while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
        iIndex += textContentItemsStr[i].length;
        i++;
      }

      match.end = {
        divIdx: i,
        offset: matchIdx - iIndex
      };
      result.push(match);
    }

    return result;
  }

  _renderMatches(matches) {
    if (matches.length === 0) {
      return;
    }

    const {
      findController,
      pageIdx,
      textContentItemsStr,
      textDivs
    } = this;
    const isSelectedPage = pageIdx === findController.selected.pageIdx;
    const selectedMatchIdx = findController.selected.matchIdx;
    const highlightAll = findController.state.highlightAll;
    let prevEnd = null;
    const infinity = {
      divIdx: -1,
      offset: undefined
    };

    function beginText(begin, className) {
      const divIdx = begin.divIdx;
      textDivs[divIdx].textContent = "";
      appendTextToDiv(divIdx, 0, begin.offset, className);
    }

    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
      const div = textDivs[divIdx];
      const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
      const node = document.createTextNode(content);

      if (className) {
        const span = document.createElement("span");
        span.className = className;
        span.appendChild(node);
        div.appendChild(span);
        return;
      }

      div.appendChild(node);
    }

    let i0 = selectedMatchIdx,
        i1 = i0 + 1;

    if (highlightAll) {
      i0 = 0;
      i1 = matches.length;
    } else if (!isSelectedPage) {
      return;
    }

    for (let i = i0; i < i1; i++) {
      const match = matches[i];
      const begin = match.begin;
      const end = match.end;
      const isSelected = isSelectedPage && i === selectedMatchIdx;
      const highlightSuffix = isSelected ? " selected" : "";

      if (isSelected) {
        findController.scrollMatchIntoView({
          element: textDivs[begin.divIdx],
          pageIndex: pageIdx,
          matchIndex: selectedMatchIdx
        });
      }

      if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
        if (prevEnd !== null) {
          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
        }

        beginText(begin);
      } else {
        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
      }

      if (begin.divIdx === end.divIdx) {
        appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
      } else {
        appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);

        for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
          textDivs[n0].className = "highlight middle" + highlightSuffix;
        }

        beginText(end, "highlight end" + highlightSuffix);
      }

      prevEnd = end;
    }

    if (prevEnd) {
      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
    }
  }

  _updateMatches() {
    if (!this.renderingDone) {
      return;
    }

    const {
      findController,
      matches,
      pageIdx,
      textContentItemsStr,
      textDivs
    } = this;
    let clearedUntilDivIdx = -1;

    for (let i = 0, ii = matches.length; i < ii; i++) {
      const match = matches[i];
      const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);

      for (let n = begin, end = match.end.divIdx; n <= end; n++) {
        const div = textDivs[n];
        div.textContent = textContentItemsStr[n];
        div.className = "";
      }

      clearedUntilDivIdx = match.end.divIdx + 1;
    }

    if (!findController || !findController.highlightMatches) {
      return;
    }

    const pageMatches = findController.pageMatches[pageIdx] || null;
    const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
    this.matches = this._convertMatches(pageMatches, pageMatchesLength);

    this._renderMatches(this.matches);
  }

  _bindMouse() {
    const div = this.textLayerDiv;
    let expandDivsTimer = null;
    div.addEventListener("mousedown", evt => {
      if (this.enhanceTextSelection && this.textLayerRenderTask) {
        this.textLayerRenderTask.expandTextDivs(true);

        if (expandDivsTimer) {
          clearTimeout(expandDivsTimer);
          expandDivsTimer = null;
        }

        return;
      }

      const end = div.querySelector(".endOfContent");

      if (!end) {
        return;
      }

      let adjustTop = evt.target !== div;
      adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";

      if (adjustTop) {
        const divBounds = div.getBoundingClientRect();
        const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
        end.style.top = (r * 100).toFixed(2) + "%";
      }

      end.classList.add("active");
    });
    div.addEventListener("mouseup", () => {
      if (this.enhanceTextSelection && this.textLayerRenderTask) {
        expandDivsTimer = setTimeout(() => {
          if (this.textLayerRenderTask) {
            this.textLayerRenderTask.expandTextDivs(false);
          }

          expandDivsTimer = null;
        }, EXPAND_DIVS_TIMEOUT);
        return;
      }

      const end = div.querySelector(".endOfContent");

      if (!end) {
        return;
      }

      end.style.top = "";
      end.classList.remove("active");
    });
  }

}

exports.TextLayerBuilder = TextLayerBuilder;

class DefaultTextLayerFactory {
  createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) {
    return new TextLayerBuilder({
      textLayerDiv,
      pageIndex,
      viewport,
      enhanceTextSelection,
      eventBus
    });
  }

}

exports.DefaultTextLayerFactory = DefaultTextLayerFactory;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SecondaryToolbar = void 0;

var _ui_utils = __webpack_require__(2);

var _pdf_cursor_tools = __webpack_require__(6);

var _pdf_single_page_viewer = __webpack_require__(30);

class SecondaryToolbar {
  constructor(options, mainContainer, eventBus) {
    this.toolbar = options.toolbar;
    this.toggleButton = options.toggleButton;
    this.toolbarButtonContainer = options.toolbarButtonContainer;
    this.buttons = [{
      element: options.presentationModeButton,
      eventName: "presentationmode",
      close: true
    }, {
      element: options.openFileButton,
      eventName: "openfile",
      close: true
    }, {
      element: options.printButton,
      eventName: "print",
      close: true
    }, {
      element: options.downloadButton,
      eventName: "download",
      close: true
    }, {
      element: options.viewBookmarkButton,
      eventName: null,
      close: true
    }, {
      element: options.firstPageButton,
      eventName: "firstpage",
      close: true
    }, {
      element: options.lastPageButton,
      eventName: "lastpage",
      close: true
    }, {
      element: options.pageRotateCwButton,
      eventName: "rotatecw",
      close: false
    }, {
      element: options.pageRotateCcwButton,
      eventName: "rotateccw",
      close: false
    }, {
      element: options.cursorSelectToolButton,
      eventName: "switchcursortool",
      eventDetails: {
        tool: _pdf_cursor_tools.CursorTool.SELECT
      },
      close: true
    }, {
      element: options.cursorHandToolButton,
      eventName: "switchcursortool",
      eventDetails: {
        tool: _pdf_cursor_tools.CursorTool.HAND
      },
      close: true
    }, {
      element: options.scrollVerticalButton,
      eventName: "switchscrollmode",
      eventDetails: {
        mode: _ui_utils.ScrollMode.VERTICAL
      },
      close: true
    }, {
      element: options.scrollHorizontalButton,
      eventName: "switchscrollmode",
      eventDetails: {
        mode: _ui_utils.ScrollMode.HORIZONTAL
      },
      close: true
    }, {
      element: options.scrollWrappedButton,
      eventName: "switchscrollmode",
      eventDetails: {
        mode: _ui_utils.ScrollMode.WRAPPED
      },
      close: true
    }, {
      element: options.spreadNoneButton,
      eventName: "switchspreadmode",
      eventDetails: {
        mode: _ui_utils.SpreadMode.NONE
      },
      close: true
    }, {
      element: options.spreadOddButton,
      eventName: "switchspreadmode",
      eventDetails: {
        mode: _ui_utils.SpreadMode.ODD
      },
      close: true
    }, {
      element: options.spreadEvenButton,
      eventName: "switchspreadmode",
      eventDetails: {
        mode: _ui_utils.SpreadMode.EVEN
      },
      close: true
    }, {
      element: options.documentPropertiesButton,
      eventName: "documentproperties",
      close: true
    }];
    this.items = {
      firstPage: options.firstPageButton,
      lastPage: options.lastPageButton,
      pageRotateCw: options.pageRotateCwButton,
      pageRotateCcw: options.pageRotateCcwButton
    };
    this.mainContainer = mainContainer;
    this.eventBus = eventBus;
    this.opened = false;
    this.containerHeight = null;
    this.previousContainerHeight = null;
    this.reset();

    this._bindClickListeners();

    this._bindCursorToolsListener(options);

    this._bindScrollModeListener(options);

    this._bindSpreadModeListener(options);

    this.eventBus._on("resize", this._setMaxHeight.bind(this));

    this.eventBus._on("baseviewerinit", evt => {
      if (evt.source instanceof _pdf_single_page_viewer.PDFSinglePageViewer) {
        this.toolbarButtonContainer.classList.add("hiddenScrollModeButtons", "hiddenSpreadModeButtons");
      } else {
        this.toolbarButtonContainer.classList.remove("hiddenScrollModeButtons", "hiddenSpreadModeButtons");
      }
    });
  }

  get isOpen() {
    return this.opened;
  }

  setPageNumber(pageNumber) {
    this.pageNumber = pageNumber;

    this._updateUIState();
  }

  setPagesCount(pagesCount) {
    this.pagesCount = pagesCount;

    this._updateUIState();
  }

  reset() {
    this.pageNumber = 0;
    this.pagesCount = 0;

    this._updateUIState();

    this.eventBus.dispatch("secondarytoolbarreset", {
      source: this
    });
  }

  _updateUIState() {
    this.items.firstPage.disabled = this.pageNumber <= 1;
    this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;
    this.items.pageRotateCw.disabled = this.pagesCount === 0;
    this.items.pageRotateCcw.disabled = this.pagesCount === 0;
  }

  _bindClickListeners() {
    this.toggleButton.addEventListener("click", this.toggle.bind(this));

    for (const {
      element,
      eventName,
      close,
      eventDetails
    } of this.buttons) {
      element.addEventListener("click", evt => {
        if (eventName !== null) {
          const details = {
            source: this
          };

          for (const property in eventDetails) {
            details[property] = eventDetails[property];
          }

          this.eventBus.dispatch(eventName, details);
        }

        if (close) {
          this.close();
        }
      });
    }
  }

  _bindCursorToolsListener(buttons) {
    this.eventBus._on("cursortoolchanged", function ({
      tool
    }) {
      buttons.cursorSelectToolButton.classList.toggle("toggled", tool === _pdf_cursor_tools.CursorTool.SELECT);
      buttons.cursorHandToolButton.classList.toggle("toggled", tool === _pdf_cursor_tools.CursorTool.HAND);
    });
  }

  _bindScrollModeListener(buttons) {
    function scrollModeChanged({
      mode
    }) {
      buttons.scrollVerticalButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.VERTICAL);
      buttons.scrollHorizontalButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.HORIZONTAL);
      buttons.scrollWrappedButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.WRAPPED);
      const isScrollModeHorizontal = mode === _ui_utils.ScrollMode.HORIZONTAL;
      buttons.spreadNoneButton.disabled = isScrollModeHorizontal;
      buttons.spreadOddButton.disabled = isScrollModeHorizontal;
      buttons.spreadEvenButton.disabled = isScrollModeHorizontal;
    }

    this.eventBus._on("scrollmodechanged", scrollModeChanged);

    this.eventBus._on("secondarytoolbarreset", evt => {
      if (evt.source === this) {
        scrollModeChanged({
          mode: _ui_utils.ScrollMode.VERTICAL
        });
      }
    });
  }

  _bindSpreadModeListener(buttons) {
    function spreadModeChanged({
      mode
    }) {
      buttons.spreadNoneButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.NONE);
      buttons.spreadOddButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.ODD);
      buttons.spreadEvenButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.EVEN);
    }

    this.eventBus._on("spreadmodechanged", spreadModeChanged);

    this.eventBus._on("secondarytoolbarreset", evt => {
      if (evt.source === this) {
        spreadModeChanged({
          mode: _ui_utils.SpreadMode.NONE
        });
      }
    });
  }

  open() {
    if (this.opened) {
      return;
    }

    this.opened = true;

    this._setMaxHeight();

    this.toggleButton.classList.add("toggled");
    this.toolbar.classList.remove("hidden");
  }

  close() {
    if (!this.opened) {
      return;
    }

    this.opened = false;
    this.toolbar.classList.add("hidden");
    this.toggleButton.classList.remove("toggled");
  }

  toggle() {
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }

  _setMaxHeight() {
    if (!this.opened) {
      return;
    }

    this.containerHeight = this.mainContainer.clientHeight;

    if (this.containerHeight === this.previousContainerHeight) {
      return;
    }

    this.toolbarButtonContainer.style.maxHeight = `${this.containerHeight - _ui_utils.SCROLLBAR_PADDING}px`;
    this.previousContainerHeight = this.containerHeight;
  }

}

exports.SecondaryToolbar = SecondaryToolbar;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFSinglePageViewer = void 0;

var _base_viewer = __webpack_require__(25);

var _pdfjsLib = __webpack_require__(5);

class PDFSinglePageViewer extends _base_viewer.BaseViewer {
  constructor(options) {
    super(options);

    this.eventBus._on("pagesinit", evt => {
      this._ensurePageViewVisible();
    });
  }

  get _viewerElement() {
    return (0, _pdfjsLib.shadow)(this, "_viewerElement", this._shadowViewer);
  }

  _resetView() {
    super._resetView();

    this._previousPageNumber = 1;
    this._shadowViewer = document.createDocumentFragment();
    this._updateScrollDown = null;
  }

  _ensurePageViewVisible() {
    const pageView = this._pages[this._currentPageNumber - 1];
    const previousPageView = this._pages[this._previousPageNumber - 1];
    const viewerNodes = this.viewer.childNodes;

    switch (viewerNodes.length) {
      case 0:
        this.viewer.appendChild(pageView.div);
        break;

      case 1:
        if (viewerNodes[0] !== previousPageView.div) {
          throw new Error("_ensurePageViewVisible: Unexpected previously visible page.");
        }

        if (pageView === previousPageView) {
          break;
        }

        this._shadowViewer.appendChild(previousPageView.div);

        this.viewer.appendChild(pageView.div);
        this.container.scrollTop = 0;
        break;

      default:
        throw new Error("_ensurePageViewVisible: Only one page should be visible at a time.");
    }

    this._previousPageNumber = this._currentPageNumber;
  }

  _scrollUpdate() {
    if (this._updateScrollDown) {
      this._updateScrollDown();
    }

    super._scrollUpdate();
  }

  _scrollIntoView({
    pageDiv,
    pageSpot = null,
    pageNumber = null
  }) {
    if (pageNumber) {
      this._setCurrentPageNumber(pageNumber);
    }

    const scrolledDown = this._currentPageNumber >= this._previousPageNumber;

    this._ensurePageViewVisible();

    this.update();

    super._scrollIntoView({
      pageDiv,
      pageSpot,
      pageNumber
    });

    this._updateScrollDown = () => {
      this.scroll.down = scrolledDown;
      this._updateScrollDown = null;
    };
  }

  _getVisiblePages() {
    return this._getCurrentVisiblePage();
  }

  _updateHelper(visiblePages) {}

  get _isScrollModeHorizontal() {
    return (0, _pdfjsLib.shadow)(this, "_isScrollModeHorizontal", false);
  }

  _updateScrollMode() {}

  _updateSpreadMode() {}

}

exports.PDFSinglePageViewer = PDFSinglePageViewer;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Toolbar = void 0;

var _ui_utils = __webpack_require__(2);

const PAGE_NUMBER_LOADING_INDICATOR = "visiblePageIsLoading";
const SCALE_SELECT_CONTAINER_WIDTH = 140;
const SCALE_SELECT_WIDTH = 162;

class Toolbar {
  constructor(options, eventBus, l10n = _ui_utils.NullL10n) {
    this.toolbar = options.container;
    this.eventBus = eventBus;
    this.l10n = l10n;
    this.buttons = [{
      element: options.previous,
      eventName: "previouspage"
    }, {
      element: options.next,
      eventName: "nextpage"
    }, {
      element: options.zoomIn,
      eventName: "zoomin"
    }, {
      element: options.zoomOut,
      eventName: "zoomout"
    }, {
      element: options.openFile,
      eventName: "openfile"
    }, {
      element: options.print,
      eventName: "print"
    }, {
      element: options.presentationModeButton,
      eventName: "presentationmode"
    }, {
      element: options.download,
      eventName: "download"
    }, {
      element: options.viewBookmark,
      eventName: null
    }];
    this.items = {
      numPages: options.numPages,
      pageNumber: options.pageNumber,
      scaleSelectContainer: options.scaleSelectContainer,
      scaleSelect: options.scaleSelect,
      customScaleOption: options.customScaleOption,
      previous: options.previous,
      next: options.next,
      zoomIn: options.zoomIn,
      zoomOut: options.zoomOut
    };
    this._wasLocalized = false;
    this.reset();

    this._bindListeners();
  }

  setPageNumber(pageNumber, pageLabel) {
    this.pageNumber = pageNumber;
    this.pageLabel = pageLabel;

    this._updateUIState(false);
  }

  setPagesCount(pagesCount, hasPageLabels) {
    this.pagesCount = pagesCount;
    this.hasPageLabels = hasPageLabels;

    this._updateUIState(true);
  }

  setPageScale(pageScaleValue, pageScale) {
    this.pageScaleValue = (pageScaleValue || pageScale).toString();
    this.pageScale = pageScale;

    this._updateUIState(false);
  }

  reset() {
    this.pageNumber = 0;
    this.pageLabel = null;
    this.hasPageLabels = false;
    this.pagesCount = 0;
    this.pageScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
    this.pageScale = _ui_utils.DEFAULT_SCALE;

    this._updateUIState(true);

    this.updateLoadingIndicatorState();
  }

  _bindListeners() {
    const {
      pageNumber,
      scaleSelect
    } = this.items;
    const self = this;

    for (const {
      element,
      eventName
    } of this.buttons) {
      element.addEventListener("click", evt => {
        if (eventName !== null) {
          this.eventBus.dispatch(eventName, {
            source: this
          });
        }
      });
    }

    pageNumber.addEventListener("click", function () {
      this.select();
    });
    pageNumber.addEventListener("change", function () {
      self.eventBus.dispatch("pagenumberchanged", {
        source: self,
        value: this.value
      });
    });
    scaleSelect.addEventListener("change", function () {
      if (this.value === "custom") {
        return;
      }

      self.eventBus.dispatch("scalechanged", {
        source: self,
        value: this.value
      });
    });
    scaleSelect.oncontextmenu = _ui_utils.noContextMenuHandler;

    this.eventBus._on("localized", () => {
      this._wasLocalized = true;

      this._adjustScaleWidth();

      this._updateUIState(true);
    });
  }

  _updateUIState(resetNumPages = false) {
    if (!this._wasLocalized) {
      return;
    }

    const {
      pageNumber,
      pagesCount,
      pageScaleValue,
      pageScale,
      items
    } = this;

    if (resetNumPages) {
      if (this.hasPageLabels) {
        items.pageNumber.type = "text";
      } else {
        items.pageNumber.type = "number";
        this.l10n.get("of_pages", {
          pagesCount
        }, "of {{pagesCount}}").then(msg => {
          items.numPages.textContent = msg;
        });
      }

      items.pageNumber.max = pagesCount;
    }

    if (this.hasPageLabels) {
      items.pageNumber.value = this.pageLabel;
      this.l10n.get("page_of_pages", {
        pageNumber,
        pagesCount
      }, "({{pageNumber}} of {{pagesCount}})").then(msg => {
        items.numPages.textContent = msg;
      });
    } else {
      items.pageNumber.value = pageNumber;
    }

    items.previous.disabled = pageNumber <= 1;
    items.next.disabled = pageNumber >= pagesCount;
    items.zoomOut.disabled = pageScale <= _ui_utils.MIN_SCALE;
    items.zoomIn.disabled = pageScale >= _ui_utils.MAX_SCALE;
    const customScale = Math.round(pageScale * 10000) / 100;
    this.l10n.get("page_scale_percent", {
      scale: customScale
    }, "{{scale}}%").then(msg => {
      let predefinedValueFound = false;

      for (const option of items.scaleSelect.options) {
        if (option.value !== pageScaleValue) {
          option.selected = false;
          continue;
        }

        option.selected = true;
        predefinedValueFound = true;
      }

      if (!predefinedValueFound) {
        items.customScaleOption.textContent = msg;
        items.customScaleOption.selected = true;
      }
    });
  }

  updateLoadingIndicatorState(loading = false) {
    const pageNumberInput = this.items.pageNumber;
    pageNumberInput.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading);
  }

  async _adjustScaleWidth() {
    const {
      items,
      l10n
    } = this;
    const predefinedValuesPromise = Promise.all([l10n.get("page_scale_auto", null, "Automatic Zoom"), l10n.get("page_scale_actual", null, "Actual Size"), l10n.get("page_scale_fit", null, "Page Fit"), l10n.get("page_scale_width", null, "Page Width")]);
    let canvas = document.createElement("canvas");
    canvas.mozOpaque = true;
    let ctx = canvas.getContext("2d", {
      alpha: false
    });
    await _ui_utils.animationStarted;
    const {
      fontSize,
      fontFamily
    } = getComputedStyle(items.scaleSelect);
    ctx.font = `${fontSize} ${fontFamily}`;
    let maxWidth = 0;

    for (const predefinedValue of await predefinedValuesPromise) {
      const {
        width
      } = ctx.measureText(predefinedValue);

      if (width > maxWidth) {
        maxWidth = width;
      }
    }

    const overflow = SCALE_SELECT_WIDTH - SCALE_SELECT_CONTAINER_WIDTH;
    maxWidth += 1.5 * overflow;

    if (maxWidth > SCALE_SELECT_CONTAINER_WIDTH) {
      items.scaleSelect.style.width = `${maxWidth + overflow}px`;
      items.scaleSelectContainer.style.width = `${maxWidth}px`;
    }

    canvas.width = 0;
    canvas.height = 0;
    canvas = ctx = null;
  }

}

exports.Toolbar = Toolbar;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewHistory = void 0;
const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;

class ViewHistory {
  constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) {
    this.fingerprint = fingerprint;
    this.cacheSize = cacheSize;
    this._initializedPromise = this._readFromStorage().then(databaseStr => {
      const database = JSON.parse(databaseStr || "{}");
      let index = -1;

      if (!Array.isArray(database.files)) {
        database.files = [];
      } else {
        while (database.files.length >= this.cacheSize) {
          database.files.shift();
        }

        for (let i = 0, ii = database.files.length; i < ii; i++) {
          const branch = database.files[i];

          if (branch.fingerprint === this.fingerprint) {
            index = i;
            break;
          }
        }
      }

      if (index === -1) {
        index = database.files.push({
          fingerprint: this.fingerprint
        }) - 1;
      }

      this.file = database.files[index];
      this.database = database;
    });
  }

  async _writeToStorage() {
    const databaseStr = JSON.stringify(this.database);
    localStorage.setItem("pdfjs.history", databaseStr);
  }

  async _readFromStorage() {
    return localStorage.getItem("pdfjs.history");
  }

  async set(name, val) {
    await this._initializedPromise;
    this.file[name] = val;
    return this._writeToStorage();
  }

  async setMultiple(properties) {
    await this._initializedPromise;

    for (const name in properties) {
      this.file[name] = properties[name];
    }

    return this._writeToStorage();
  }

  async get(name, defaultValue) {
    await this._initializedPromise;
    const val = this.file[name];
    return val !== undefined ? val : defaultValue;
  }

  async getMultiple(properties) {
    await this._initializedPromise;
    const values = Object.create(null);

    for (const name in properties) {
      const val = this.file[name];
      values[name] = val !== undefined ? val : properties[name];
    }

    return values;
  }

}

exports.ViewHistory = ViewHistory;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericCom = void 0;

var _app = __webpack_require__(1);

var _preferences = __webpack_require__(34);

var _download_manager = __webpack_require__(35);

var _genericl10n = __webpack_require__(36);

;
const GenericCom = {};
exports.GenericCom = GenericCom;

class GenericPreferences extends _preferences.BasePreferences {
  async _writeToStorage(prefObj) {
    localStorage.setItem("pdfjs.preferences", JSON.stringify(prefObj));
  }

  async _readFromStorage(prefObj) {
    return JSON.parse(localStorage.getItem("pdfjs.preferences"));
  }

}

class GenericExternalServices extends _app.DefaultExternalServices {
  static createDownloadManager(options) {
    return new _download_manager.DownloadManager(options);
  }

  static createPreferences() {
    return new GenericPreferences();
  }

  static createL10n({
    locale = "en-US"
  }) {
    return new _genericl10n.GenericL10n(locale);
  }

}

_app.PDFViewerApplication.externalServices = GenericExternalServices;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BasePreferences = void 0;

var _app_options = __webpack_require__(3);

let defaultPreferences = null;

function getDefaultPreferences() {
  if (!defaultPreferences) {
    defaultPreferences = Promise.resolve({
      "cursorToolOnLoad": 0,
      "defaultZoomValue": "",
      "disablePageLabels": false,
      "enablePermissions": false,
      "enablePrintAutoRotate": false,
      "enableWebGL": false,
      "externalLinkTarget": 0,
      "historyUpdateUrl": false,
      "ignoreDestinationZoom": false,
      "pdfBugEnabled": false,
      "renderer": "canvas",
      "renderInteractiveForms": false,
      "sidebarViewOnLoad": -1,
      "scrollModeOnLoad": -1,
      "spreadModeOnLoad": -1,
      "textLayerMode": 1,
      "useOnlyCssZoom": false,
      "viewOnLoad": 0,
      "disableAutoFetch": false,
      "disableFontFace": false,
      "disableRange": false,
      "disableStream": false
    });
  }

  return defaultPreferences;
}

class BasePreferences {
  constructor() {
    if (this.constructor === BasePreferences) {
      throw new Error("Cannot initialize BasePreferences.");
    }

    this.prefs = null;
    this._initializedPromise = getDefaultPreferences().then(defaults => {
      Object.defineProperty(this, "defaults", {
        value: Object.freeze(defaults),
        writable: false,
        enumerable: true,
        configurable: false
      });
      this.prefs = Object.assign(Object.create(null), defaults);
      return this._readFromStorage(defaults);
    }).then(prefs => {
      if (!prefs) {
        return;
      }

      for (const name in prefs) {
        const defaultValue = this.defaults[name],
              prefValue = prefs[name];

        if (defaultValue === undefined || typeof prefValue !== typeof defaultValue) {
          continue;
        }

        this.prefs[name] = prefValue;
      }
    });
  }

  async _writeToStorage(prefObj) {
    throw new Error("Not implemented: _writeToStorage");
  }

  async _readFromStorage(prefObj) {
    throw new Error("Not implemented: _readFromStorage");
  }

  async reset() {
    await this._initializedPromise;
    this.prefs = Object.assign(Object.create(null), this.defaults);
    return this._writeToStorage(this.defaults);
  }

  async set(name, value) {
    await this._initializedPromise;
    const defaultValue = this.defaults[name];

    if (defaultValue === undefined) {
      throw new Error(`Set preference: "${name}" is undefined.`);
    } else if (value === undefined) {
      throw new Error("Set preference: no value is specified.");
    }

    const valueType = typeof value;
    const defaultType = typeof defaultValue;

    if (valueType !== defaultType) {
      if (valueType === "number" && defaultType === "string") {
        value = value.toString();
      } else {
        throw new Error(`Set preference: "${value}" is a ${valueType}, ` + `expected a ${defaultType}.`);
      }
    } else {
      if (valueType === "number" && !Number.isInteger(value)) {
        throw new Error(`Set preference: "${value}" must be an integer.`);
      }
    }

    this.prefs[name] = value;
    return this._writeToStorage(this.prefs);
  }

  async get(name) {
    await this._initializedPromise;
    const defaultValue = this.defaults[name];

    if (defaultValue === undefined) {
      throw new Error(`Get preference: "${name}" is undefined.`);
    } else {
      const prefValue = this.prefs[name];

      if (prefValue !== undefined) {
        return prefValue;
      }
    }

    return defaultValue;
  }

  async getAll() {
    await this._initializedPromise;
    return Object.assign(Object.create(null), this.defaults, this.prefs);
  }

}

exports.BasePreferences = BasePreferences;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DownloadManager = void 0;

var _pdfjsLib = __webpack_require__(5);

var _viewer_compatibility = __webpack_require__(4);

;
const DISABLE_CREATE_OBJECT_URL = _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL || false;

function download(blobUrl, filename) {
  const a = document.createElement("a");

  if (!a.click) {
    throw new Error('DownloadManager: "a.click()" is not supported.');
  }

  a.href = blobUrl;
  a.target = "_parent";

  if ("download" in a) {
    a.download = filename;
  }

  (document.body || document.documentElement).appendChild(a);
  a.click();
  a.remove();
  TrackEvent(CLICK_DOWNLOAD_PDF);
}

class DownloadManager {
  constructor({
    disableCreateObjectURL = DISABLE_CREATE_OBJECT_URL
  }) {
    this.disableCreateObjectURL = disableCreateObjectURL;
  }

  downloadUrl(url, filename) {
    if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
      return;
    }

    download(url + "#pdfjs.action=download", filename);
  }

  downloadData(data, filename, contentType) {
    if (navigator.msSaveBlob) {
      if (navigator.msSaveBlob(new Blob([data], {
        type: contentType
      }), filename)) {
        TrackEvent(CLICK_DOWNLOAD_PDF);
      }
      return;
    }

    const blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, this.disableCreateObjectURL);
    download(blobUrl, filename);
  }

  download(blob, url, filename) {
    if (navigator.msSaveBlob) {
      if (!navigator.msSaveBlob(blob, filename)) {
        this.downloadUrl(url, filename);
      } else {
        TrackEvent(CLICK_DOWNLOAD_PDF);
      }
      return;
    }

    if (this.disableCreateObjectURL) {
      this.downloadUrl(url, filename);
      return;
    }

    const blobUrl = URL.createObjectURL(blob);
    download(blobUrl, filename);
  }

}

exports.DownloadManager = DownloadManager;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericL10n = void 0;

__webpack_require__(37);

const webL10n = document.webL10n;

class GenericL10n {
  constructor(lang) {
    this._lang = lang;
    this._ready = new Promise((resolve, reject) => {
      webL10n.setLanguage(lang, () => {
        resolve(webL10n);
      });
    });
  }

  async getLanguage() {
    const l10n = await this._ready;
    return l10n.getLanguage();
  }

  async getDirection() {
    const l10n = await this._ready;
    return l10n.getDirection();
  }

  async get(property, args, fallback) {
    const l10n = await this._ready;
    return l10n.get(property, args, fallback);
  }

  async translate(element) {
    const l10n = await this._ready;
    return l10n.translate(element);
  }

}

exports.GenericL10n = GenericL10n;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


document.webL10n = function (window, document, undefined) {
  var gL10nData = {};
  var gTextData = '';
  var gTextProp = 'textContent';
  var gLanguage = '';
  var gMacros = {};
  var gReadyState = 'loading';
  var gAsyncResourceLoading = true;

  function getL10nResourceLinks() {
    return document.querySelectorAll('link[type="application/l10n"]');
  }

  function getL10nDictionary() {
    var script = document.querySelector('script[type="application/l10n"]');
    return script ? JSON.parse(script.innerHTML) : null;
  }

  function getTranslatableChildren(element) {
    return element ? element.querySelectorAll('*[data-l10n-id]') : [];
  }

  function getL10nAttributes(element) {
    if (!element) return {};
    var l10nId = element.getAttribute('data-l10n-id');
    var l10nArgs = element.getAttribute('data-l10n-args');
    var args = {};

    if (l10nArgs) {
      try {
        args = JSON.parse(l10nArgs);
      } catch (e) {
        console.warn('could not parse arguments for #' + l10nId);
      }
    }

    return {
      id: l10nId,
      args: args
    };
  }

  function xhrLoadText(url, onSuccess, onFailure) {
    onSuccess = onSuccess || function _onSuccess(data) {};

    onFailure = onFailure || function _onFailure() {};

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, gAsyncResourceLoading);

    if (xhr.overrideMimeType) {
      xhr.overrideMimeType('text/plain; charset=utf-8');
    }

    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        if (xhr.status == 200 || xhr.status === 0) {
          onSuccess(xhr.responseText);
        } else {
          onFailure();
        }
      }
    };

    xhr.onerror = onFailure;
    xhr.ontimeout = onFailure;

    try {
      xhr.send(null);
    } catch (e) {
      onFailure();
    }
  }

  function parseResource(href, lang, successCallback, failureCallback) {
    var baseURL = href.replace(/[^\/]*$/, '') || './';

    function evalString(text) {
      if (text.lastIndexOf('\\') < 0) return text;
      return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
    }

    function parseProperties(text, parsedPropertiesCallback) {
      var dictionary = {};
      var reBlank = /^\s*|\s*$/;
      var reComment = /^\s*#|^\s*$/;
      var reSection = /^\s*\[(.*)\]\s*$/;
      var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
      var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;

      function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
        var entries = rawText.replace(reBlank, '').split(/[\r\n]+/);
        var currentLang = '*';
        var genericLang = lang.split('-', 1)[0];
        var skipLang = false;
        var match = '';

        function nextEntry() {
          while (true) {
            if (!entries.length) {
              parsedRawLinesCallback();
              return;
            }

            var line = entries.shift();
            if (reComment.test(line)) continue;

            if (extendedSyntax) {
              match = reSection.exec(line);

              if (match) {
                currentLang = match[1].toLowerCase();
                skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;
                continue;
              } else if (skipLang) {
                continue;
              }

              match = reImport.exec(line);

              if (match) {
                loadImport(baseURL + match[1], nextEntry);
                return;
              }
            }

            var tmp = line.match(reSplit);

            if (tmp && tmp.length == 3) {
              dictionary[tmp[1]] = evalString(tmp[2]);
            }
          }
        }

        nextEntry();
      }

      function loadImport(url, callback) {
        xhrLoadText(url, function (content) {
          parseRawLines(content, false, callback);
        }, function () {
          console.warn(url + ' not found.');
          callback();
        });
      }

      parseRawLines(text, true, function () {
        parsedPropertiesCallback(dictionary);
      });
    }

    xhrLoadText(href, function (response) {
      gTextData += response;
      parseProperties(response, function (data) {
        for (var key in data) {
          var id,
              prop,
              index = key.lastIndexOf('.');

          if (index > 0) {
            id = key.substring(0, index);
            prop = key.substring(index + 1);
          } else {
            id = key;
            prop = gTextProp;
          }

          if (!gL10nData[id]) {
            gL10nData[id] = {};
          }

          gL10nData[id][prop] = data[key];
        }

        if (successCallback) {
          successCallback();
        }
      });
    }, failureCallback);
  }

  function loadLocale(lang, callback) {
    if (lang) {
      lang = lang.toLowerCase();
    }

    callback = callback || function _callback() {};

    clear();
    gLanguage = lang;
    var langLinks = getL10nResourceLinks();
    var langCount = langLinks.length;

    if (langCount === 0) {
      var dict = getL10nDictionary();

      if (dict && dict.locales && dict.default_locale) {
        console.log('using the embedded JSON directory, early way out');
        gL10nData = dict.locales[lang];

        if (!gL10nData) {
          var defaultLocale = dict.default_locale.toLowerCase();

          for (var anyCaseLang in dict.locales) {
            anyCaseLang = anyCaseLang.toLowerCase();

            if (anyCaseLang === lang) {
              gL10nData = dict.locales[lang];
              break;
            } else if (anyCaseLang === defaultLocale) {
              gL10nData = dict.locales[defaultLocale];
            }
          }
        }

        callback();
      } else {
        console.log('no resource to load, early way out');
      }

      gReadyState = 'complete';
      return;
    }

    var onResourceLoaded = null;
    var gResourceCount = 0;

    onResourceLoaded = function () {
      gResourceCount++;

      if (gResourceCount >= langCount) {
        callback();
        gReadyState = 'complete';
      }
    };

    function L10nResourceLink(link) {
      var href = link.href;

      this.load = function (lang, callback) {
        parseResource(href, lang, callback, function () {
          console.warn(href + ' not found.');
          console.warn('"' + lang + '" resource not found');
          gLanguage = '';
          callback();
        });
      };
    }

    for (var i = 0; i < langCount; i++) {
      var resource = new L10nResourceLink(langLinks[i]);
      resource.load(lang, onResourceLoaded);
    }
  }

  function clear() {
    gL10nData = {};
    gTextData = '';
    gLanguage = '';
  }

  function getPluralRules(lang) {
    var locales2rules = {
      'af': 3,
      'ak': 4,
      'am': 4,
      'ar': 1,
      'asa': 3,
      'az': 0,
      'be': 11,
      'bem': 3,
      'bez': 3,
      'bg': 3,
      'bh': 4,
      'bm': 0,
      'bn': 3,
      'bo': 0,
      'br': 20,
      'brx': 3,
      'bs': 11,
      'ca': 3,
      'cgg': 3,
      'chr': 3,
      'cs': 12,
      'cy': 17,
      'da': 3,
      'de': 3,
      'dv': 3,
      'dz': 0,
      'ee': 3,
      'el': 3,
      'en': 3,
      'eo': 3,
      'es': 3,
      'et': 3,
      'eu': 3,
      'fa': 0,
      'ff': 5,
      'fi': 3,
      'fil': 4,
      'fo': 3,
      'fr': 5,
      'fur': 3,
      'fy': 3,
      'ga': 8,
      'gd': 24,
      'gl': 3,
      'gsw': 3,
      'gu': 3,
      'guw': 4,
      'gv': 23,
      'ha': 3,
      'haw': 3,
      'he': 2,
      'hi': 4,
      'hr': 11,
      'hu': 0,
      'id': 0,
      'ig': 0,
      'ii': 0,
      'is': 3,
      'it': 3,
      'iu': 7,
      'ja': 0,
      'jmc': 3,
      'jv': 0,
      'ka': 0,
      'kab': 5,
      'kaj': 3,
      'kcg': 3,
      'kde': 0,
      'kea': 0,
      'kk': 3,
      'kl': 3,
      'km': 0,
      'kn': 0,
      'ko': 0,
      'ksb': 3,
      'ksh': 21,
      'ku': 3,
      'kw': 7,
      'lag': 18,
      'lb': 3,
      'lg': 3,
      'ln': 4,
      'lo': 0,
      'lt': 10,
      'lv': 6,
      'mas': 3,
      'mg': 4,
      'mk': 16,
      'ml': 3,
      'mn': 3,
      'mo': 9,
      'mr': 3,
      'ms': 0,
      'mt': 15,
      'my': 0,
      'nah': 3,
      'naq': 7,
      'nb': 3,
      'nd': 3,
      'ne': 3,
      'nl': 3,
      'nn': 3,
      'no': 3,
      'nr': 3,
      'nso': 4,
      'ny': 3,
      'nyn': 3,
      'om': 3,
      'or': 3,
      'pa': 3,
      'pap': 3,
      'pl': 13,
      'ps': 3,
      'pt': 3,
      'rm': 3,
      'ro': 9,
      'rof': 3,
      'ru': 11,
      'rwk': 3,
      'sah': 0,
      'saq': 3,
      'se': 7,
      'seh': 3,
      'ses': 0,
      'sg': 0,
      'sh': 11,
      'shi': 19,
      'sk': 12,
      'sl': 14,
      'sma': 7,
      'smi': 7,
      'smj': 7,
      'smn': 7,
      'sms': 7,
      'sn': 3,
      'so': 3,
      'sq': 3,
      'sr': 11,
      'ss': 3,
      'ssy': 3,
      'st': 3,
      'sv': 3,
      'sw': 3,
      'syr': 3,
      'ta': 3,
      'te': 3,
      'teo': 3,
      'th': 0,
      'ti': 4,
      'tig': 3,
      'tk': 3,
      'tl': 4,
      'tn': 3,
      'to': 0,
      'tr': 0,
      'ts': 3,
      'tzm': 22,
      'uk': 11,
      'ur': 3,
      've': 3,
      'vi': 0,
      'vun': 3,
      'wa': 4,
      'wae': 3,
      'wo': 0,
      'xh': 3,
      'xog': 3,
      'yo': 0,
      'zh': 0,
      'zu': 3
    };

    function isIn(n, list) {
      return list.indexOf(n) !== -1;
    }

    function isBetween(n, start, end) {
      return start <= n && n <= end;
    }

    var pluralRules = {
      '0': function (n) {
        return 'other';
      },
      '1': function (n) {
        if (isBetween(n % 100, 3, 10)) return 'few';
        if (n === 0) return 'zero';
        if (isBetween(n % 100, 11, 99)) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '2': function (n) {
        if (n !== 0 && n % 10 === 0) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '3': function (n) {
        if (n == 1) return 'one';
        return 'other';
      },
      '4': function (n) {
        if (isBetween(n, 0, 1)) return 'one';
        return 'other';
      },
      '5': function (n) {
        if (isBetween(n, 0, 2) && n != 2) return 'one';
        return 'other';
      },
      '6': function (n) {
        if (n === 0) return 'zero';
        if (n % 10 == 1 && n % 100 != 11) return 'one';
        return 'other';
      },
      '7': function (n) {
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '8': function (n) {
        if (isBetween(n, 3, 6)) return 'few';
        if (isBetween(n, 7, 10)) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '9': function (n) {
        if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';
        if (n == 1) return 'one';
        return 'other';
      },
      '10': function (n) {
        if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';
        if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';
        return 'other';
      },
      '11': function (n) {
        if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
        if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';
        if (n % 10 == 1 && n % 100 != 11) return 'one';
        return 'other';
      },
      '12': function (n) {
        if (isBetween(n, 2, 4)) return 'few';
        if (n == 1) return 'one';
        return 'other';
      },
      '13': function (n) {
        if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
        if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';
        if (n == 1) return 'one';
        return 'other';
      },
      '14': function (n) {
        if (isBetween(n % 100, 3, 4)) return 'few';
        if (n % 100 == 2) return 'two';
        if (n % 100 == 1) return 'one';
        return 'other';
      },
      '15': function (n) {
        if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';
        if (isBetween(n % 100, 11, 19)) return 'many';
        if (n == 1) return 'one';
        return 'other';
      },
      '16': function (n) {
        if (n % 10 == 1 && n != 11) return 'one';
        return 'other';
      },
      '17': function (n) {
        if (n == 3) return 'few';
        if (n === 0) return 'zero';
        if (n == 6) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '18': function (n) {
        if (n === 0) return 'zero';
        if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';
        return 'other';
      },
      '19': function (n) {
        if (isBetween(n, 2, 10)) return 'few';
        if (isBetween(n, 0, 1)) return 'one';
        return 'other';
      },
      '20': function (n) {
        if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';
        if (n % 1000000 === 0 && n !== 0) return 'many';
        if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';
        if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';
        return 'other';
      },
      '21': function (n) {
        if (n === 0) return 'zero';
        if (n == 1) return 'one';
        return 'other';
      },
      '22': function (n) {
        if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';
        return 'other';
      },
      '23': function (n) {
        if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';
        return 'other';
      },
      '24': function (n) {
        if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';
        if (isIn(n, [2, 12])) return 'two';
        if (isIn(n, [1, 11])) return 'one';
        return 'other';
      }
    };
    var index = locales2rules[lang.replace(/-.*$/, '')];

    if (!(index in pluralRules)) {
      console.warn('plural form unknown for [' + lang + ']');
      return function () {
        return 'other';
      };
    }

    return pluralRules[index];
  }

  gMacros.plural = function (str, param, key, prop) {
    var n = parseFloat(param);
    if (isNaN(n)) return str;
    if (prop != gTextProp) return str;

    if (!gMacros._pluralRules) {
      gMacros._pluralRules = getPluralRules(gLanguage);
    }

    var index = '[' + gMacros._pluralRules(n) + ']';

    if (n === 0 && key + '[zero]' in gL10nData) {
      str = gL10nData[key + '[zero]'][prop];
    } else if (n == 1 && key + '[one]' in gL10nData) {
      str = gL10nData[key + '[one]'][prop];
    } else if (n == 2 && key + '[two]' in gL10nData) {
      str = gL10nData[key + '[two]'][prop];
    } else if (key + index in gL10nData) {
      str = gL10nData[key + index][prop];
    } else if (key + '[other]' in gL10nData) {
      str = gL10nData[key + '[other]'][prop];
    }

    return str;
  };

  function getL10nData(key, args, fallback) {
    var data = gL10nData[key];

    if (!data) {
      console.warn('#' + key + ' is undefined.');

      if (!fallback) {
        return null;
      }

      data = fallback;
    }

    var rv = {};

    for (var prop in data) {
      var str = data[prop];
      str = substIndexes(str, args, key, prop);
      str = substArguments(str, args, key);
      rv[prop] = str;
    }

    return rv;
  }

  function substIndexes(str, args, key, prop) {
    var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
    var reMatch = reIndex.exec(str);
    if (!reMatch || !reMatch.length) return str;
    var macroName = reMatch[1];
    var paramName = reMatch[2];
    var param;

    if (args && paramName in args) {
      param = args[paramName];
    } else if (paramName in gL10nData) {
      param = gL10nData[paramName];
    }

    if (macroName in gMacros) {
      var macro = gMacros[macroName];
      str = macro(str, param, key, prop);
    }

    return str;
  }

  function substArguments(str, args, key) {
    var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
    return str.replace(reArgs, function (matched_text, arg) {
      if (args && arg in args) {
        return args[arg];
      }

      if (arg in gL10nData) {
        return gL10nData[arg];
      }

      console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');
      return matched_text;
    });
  }

  function translateElement(element) {
    var l10n = getL10nAttributes(element);
    if (!l10n.id) return;
    var data = getL10nData(l10n.id, l10n.args);

    if (!data) {
      console.warn('#' + l10n.id + ' is undefined.');
      return;
    }

    if (data[gTextProp]) {
      if (getChildElementCount(element) === 0) {
        element[gTextProp] = data[gTextProp];
      } else {
        var children = element.childNodes;
        var found = false;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
            if (found) {
              children[i].nodeValue = '';
            } else {
              children[i].nodeValue = data[gTextProp];
              found = true;
            }
          }
        }

        if (!found) {
          var textNode = document.createTextNode(data[gTextProp]);
          element.insertBefore(textNode, element.firstChild);
        }
      }

      delete data[gTextProp];
    }

    for (var k in data) {
      element[k] = data[k];
    }
  }

  function getChildElementCount(element) {
    if (element.children) {
      return element.children.length;
    }

    if (typeof element.childElementCount !== 'undefined') {
      return element.childElementCount;
    }

    var count = 0;

    for (var i = 0; i < element.childNodes.length; i++) {
      count += element.nodeType === 1 ? 1 : 0;
    }

    return count;
  }

  function translateFragment(element) {
    element = element || document.documentElement;
    var children = getTranslatableChildren(element);
    var elementCount = children.length;

    for (var i = 0; i < elementCount; i++) {
      translateElement(children[i]);
    }

    translateElement(element);
  }

  return {
    get: function (key, args, fallbackString) {
      var index = key.lastIndexOf('.');
      var prop = gTextProp;

      if (index > 0) {
        prop = key.substring(index + 1);
        key = key.substring(0, index);
      }

      var fallback;

      if (fallbackString) {
        fallback = {};
        fallback[prop] = fallbackString;
      }

      var data = getL10nData(key, args, fallback);

      if (data && prop in data) {
        return data[prop];
      }

      return '{{' + key + '}}';
    },
    getData: function () {
      return gL10nData;
    },
    getText: function () {
      return gTextData;
    },
    getLanguage: function () {
      return gLanguage;
    },
    setLanguage: function (lang, callback) {
      loadLocale(lang, function () {
        if (callback) callback();
      });
    },
    getDirection: function () {
      var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];
      var shortCode = gLanguage.split('-', 1)[0];
      return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';
    },
    translate: translateFragment,
    getReadyState: function () {
      return gReadyState;
    },
    ready: function (callback) {
      if (!callback) {
        return;
      } else if (gReadyState == 'complete' || gReadyState == 'interactive') {
        window.setTimeout(function () {
          callback();
        });
      } else if (document.addEventListener) {
        document.addEventListener('localized', function once() {
          document.removeEventListener('localized', once);
          callback();
        });
      }
    }
  };
}(window, document);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFPrintService = PDFPrintService;

var _ui_utils = __webpack_require__(2);

var _app = __webpack_require__(1);

var _app_options = __webpack_require__(3);

let activeService = null;
let overlayManager = null;

function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size) {
  const scratchCanvas = activeService.scratchCanvas;
  const PRINT_RESOLUTION = _app_options.AppOptions.get("printResolution") || 150;
  const PRINT_UNITS = PRINT_RESOLUTION / 72.0;
  scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);
  scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);
  const width = Math.floor(size.width * _ui_utils.CSS_UNITS) + "px";
  const height = Math.floor(size.height * _ui_utils.CSS_UNITS) + "px";
  const ctx = scratchCanvas.getContext("2d");
  ctx.save();
  ctx.fillStyle = "rgb(255, 255, 255)";
  ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
  ctx.restore();
  return pdfDocument.getPage(pageNumber).then(function (pdfPage) {
    const renderContext = {
      canvasContext: ctx,
      transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],
      viewport: pdfPage.getViewport({
        scale: 1,
        rotation: size.rotation
      }),
      intent: "print"
    };
    return pdfPage.render(renderContext).promise;
  }).then(function () {
    return {
      width,
      height
    };
  });
}

function PDFPrintService(pdfDocument, pagesOverview, printContainer, l10n) {
  this.pdfDocument = pdfDocument;
  this.pagesOverview = pagesOverview;
  this.printContainer = printContainer;
  this.l10n = l10n || _ui_utils.NullL10n;
  this.disableCreateObjectURL = _app_options.AppOptions.get("disableCreateObjectURL");
  this.currentPage = -1;
  this.scratchCanvas = document.createElement("canvas");
}

PDFPrintService.prototype = {
  layout() {
    this.throwIfInactive();
    const body = document.querySelector("body");
    body.setAttribute("data-pdfjsprinting", true);
    const hasEqualPageSizes = this.pagesOverview.every(function (size) {
      return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;
    }, this);

    if (!hasEqualPageSizes) {
      console.warn("Not all pages have the same size. The printed " + "result may be incorrect!");
    }

    this.pageStyleSheet = document.createElement("style");
    const pageSize = this.pagesOverview[0];
    this.pageStyleSheet.textContent = "@supports ((size:A4) and (size:1pt 1pt)) {" + "@page { size: " + pageSize.width + "pt " + pageSize.height + "pt;}" + "}";
    body.appendChild(this.pageStyleSheet);
  },

  destroy() {
    if (activeService !== this) {
      return;
    }

    this.printContainer.textContent = "";
    const body = document.querySelector("body");
    body.removeAttribute("data-pdfjsprinting");

    if (this.pageStyleSheet) {
      this.pageStyleSheet.remove();
      this.pageStyleSheet = null;
    }

    this.scratchCanvas.width = this.scratchCanvas.height = 0;
    this.scratchCanvas = null;
    activeService = null;
    ensureOverlay().then(function () {
      if (overlayManager.active !== "printServiceOverlay") {
        return;
      }

      overlayManager.close("printServiceOverlay");
    });
  },

  renderPages() {
    const pageCount = this.pagesOverview.length;

    const renderNextPage = (resolve, reject) => {
      this.throwIfInactive();

      if (++this.currentPage >= pageCount) {
        renderProgress(pageCount, pageCount, this.l10n);
        resolve();
        return;
      }

      const index = this.currentPage;
      renderProgress(index, pageCount, this.l10n);
      renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index]).then(this.useRenderedPage.bind(this)).then(function () {
        renderNextPage(resolve, reject);
      }, reject);
    };

    return new Promise(renderNextPage);
  },

  useRenderedPage(printItem) {
    this.throwIfInactive();
    const img = document.createElement("img");
    img.style.width = printItem.width;
    img.style.height = printItem.height;
    const scratchCanvas = this.scratchCanvas;

    if ("toBlob" in scratchCanvas && !this.disableCreateObjectURL) {
      scratchCanvas.toBlob(function (blob) {
        img.src = URL.createObjectURL(blob);
      });
    } else {
      img.src = scratchCanvas.toDataURL();
    }

    const wrapper = document.createElement("div");
    wrapper.appendChild(img);
    this.printContainer.appendChild(wrapper);
    return new Promise(function (resolve, reject) {
      img.onload = resolve;
      img.onerror = reject;
    });
  },

  performPrint() {
    this.throwIfInactive();
    return new Promise(resolve => {
      setTimeout(() => {
        if (!this.active) {
          resolve();
          return;
        }

        print.call(window);
        setTimeout(resolve, 20);
      }, 0);
    });
  },

  get active() {
    return this === activeService;
  },

  throwIfInactive() {
    if (!this.active) {
      throw new Error("This print request was cancelled or completed.");
    }
  }

};
const print = window.print;

window.print = function () {
  if (activeService) {
    console.warn("Ignored window.print() because of a pending print job.");
    return;
  }

  ensureOverlay().then(function () {
    if (activeService) {
      overlayManager.open("printServiceOverlay");
    }
  });

  try {
    dispatchEvent("beforeprint");
  } finally {
    if (!activeService) {
      console.error("Expected print service to be initialized.");
      ensureOverlay().then(function () {
        if (overlayManager.active === "printServiceOverlay") {
          overlayManager.close("printServiceOverlay");
        }
      });
      return;
    }

    const activeServiceOnEntry = activeService;
    activeService.renderPages().then(function () {
      return activeServiceOnEntry.performPrint();
    }).catch(function () {}).then(function () {
      if (activeServiceOnEntry.active) {
        abort();
      }
    });
  }
};

function dispatchEvent(eventType) {
  const event = document.createEvent("CustomEvent");
  event.initCustomEvent(eventType, false, false, "custom");
  window.dispatchEvent(event);
}

function abort() {
  if (activeService) {
    activeService.destroy();
    dispatchEvent("afterprint");
  }
}

function renderProgress(index, total, l10n) {
  const progressContainer = document.getElementById("printServiceOverlay");
  const progress = Math.round(100 * index / total);
  const progressBar = progressContainer.querySelector("progress");
  const progressPerc = progressContainer.querySelector(".relative-progress");
  progressBar.value = progress;
  l10n.get("print_progress_percent", {
    progress
  }, progress + "%").then(msg => {
    progressPerc.textContent = msg;
  });
}

window.addEventListener("keydown", function (event) {
  if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) {
    window.print();
    event.preventDefault();

    if (event.stopImmediatePropagation) {
      event.stopImmediatePropagation();
    } else {
      event.stopPropagation();
    }
  }
}, true);

if ("onbeforeprint" in window) {
  const stopPropagationIfNeeded = function (event) {
    if (event.detail !== "custom" && event.stopImmediatePropagation) {
      event.stopImmediatePropagation();
    }
  };

  window.addEventListener("beforeprint", stopPropagationIfNeeded);
  window.addEventListener("afterprint", stopPropagationIfNeeded);
}

let overlayPromise;

function ensureOverlay() {
  if (!overlayPromise) {
    overlayManager = _app.PDFViewerApplication.overlayManager;

    if (!overlayManager) {
      throw new Error("The overlay manager has not yet been initialized.");
    }

    overlayPromise = overlayManager.register("printServiceOverlay", document.getElementById("printServiceOverlay"), abort, true);
    document.getElementById("printCancel").onclick = abort;
  }

  return overlayPromise;
}

_app.PDFPrintServiceFactory.instance = {
  supportsPrinting: true,

  createPrintService(pdfDocument, pagesOverview, printContainer, l10n) {
    if (activeService) {
      throw new Error("The print service is created and active.");
    }

    activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, l10n);
    return activeService;
  }

};

/***/ })
/******/ ]);
//# sourceMappingURL=viewer.js.map
</script>


<style>
  #viewerContainer {
    background: #404040;
  }

  .pdfViewer .page {
    margin-bottom: 10px;
  }

  #sidebarToggle {
    display: none !important;
  }

  #openFile {
    display: none !important;
  }

  #viewBookmark {
    display: none !important;
  }

  #secondaryToolbarToggle {
    display: none !important;
  }

  #outerContainer #sidebarContainer {
    display: none !important; /* hide PDF viewer sidebar */
  }

  #outerContainer #mainContainer #viewerContainer {
    left: 0 !important; /* move doc left into empty sidebar space */
  }
</style>

<div id="outerContainer">
  <div id="sidebarContainer">
    <div id="toolbarSidebar">
      <div class="splitToolbarButton toggled">
        <button id="viewThumbnail" class="toolbarButton toggled" title="Show Thumbnails" tabindex="2" data-l10n-id="thumbs">
            <span data-l10n-id="thumbs_label">Thumbnails</span>
        </button>
        <button id="viewOutline" class="toolbarButton" title="Show Document Outline (double-click to expand/collapse all items)" tabindex="3" data-l10n-id="document_outline">
            <span data-l10n-id="document_outline_label">Document Outline</span>
        </button>
        <button id="viewAttachments" class="toolbarButton" title="Show Attachments" tabindex="4" data-l10n-id="attachments">
            <span data-l10n-id="attachments_label">Attachments</span>
        </button>
      </div>
    </div>
    <div id="sidebarContent">
      <div id="thumbnailView">
      </div>
      <div id="outlineView" class="hidden">
      </div>
      <div id="attachmentsView" class="hidden">
      </div>
    </div>
    <div id="sidebarResizer" class="hidden"></div>
  </div>  <!-- sidebarContainer -->

  <div id="mainContainer">
    <div class="findbar hidden doorHanger" id="findbar">
      <div id="findbarInputContainer">
        <input id="findInput" class="toolbarField" title="Find" placeholder="Find in document…" tabindex="91" data-l10n-id="find_input">
        <div class="splitToolbarButton">
          <button id="findPrevious" class="toolbarButton findPrevious" title="Find the previous occurrence of the phrase" tabindex="92" data-l10n-id="find_previous">
            <span data-l10n-id="find_previous_label">Previous</span>
          </button>
          <div class="splitToolbarButtonSeparator"></div>
          <button id="findNext" class="toolbarButton findNext" title="Find the next occurrence of the phrase" tabindex="93" data-l10n-id="find_next">
            <span data-l10n-id="find_next_label">Next</span>
          </button>
        </div>
      </div>

      <div id="findbarOptionsOneContainer">
        <input type="checkbox" id="findHighlightAll" class="toolbarField" tabindex="94">
        <label for="findHighlightAll" class="toolbarLabel" data-l10n-id="find_highlight">Highlight all</label>
        <input type="checkbox" id="findMatchCase" class="toolbarField" tabindex="95">
        <label for="findMatchCase" class="toolbarLabel" data-l10n-id="find_match_case_label">Match case</label>
      </div>
      <div id="findbarOptionsTwoContainer">
        <input type="checkbox" id="findEntireWord" class="toolbarField" tabindex="96">
        <label for="findEntireWord" class="toolbarLabel" data-l10n-id="find_entire_word_label">Whole words</label>
        <span id="findResultsCount" class="toolbarLabel hidden"></span>
      </div>

      <div id="findbarMessageContainer">
        <span id="findMsg" class="toolbarLabel"></span>
      </div>
    </div>  <!-- findbar -->

    <div id="secondaryToolbar" class="secondaryToolbar hidden doorHangerRight">
      <div id="secondaryToolbarButtonContainer">
        <button id="secondaryPresentationMode" class="secondaryToolbarButton presentationMode visibleLargeView" title="Switch to Presentation Mode" tabindex="51" data-l10n-id="presentation_mode">
          <span data-l10n-id="presentation_mode_label">Presentation Mode</span>
        </button>

        <button id="secondaryOpenFile" class="secondaryToolbarButton openFile visibleLargeView" title="Open File" tabindex="52" data-l10n-id="open_file">
          <span data-l10n-id="open_file_label">Open</span>
        </button>

        <button id="secondaryPrint" class="secondaryToolbarButton print visibleMediumView" title="Print" tabindex="53" data-l10n-id="print">
          <span data-l10n-id="print_label">Print</span>
        </button>

        <button id="secondaryDownload" class="secondaryToolbarButton download visibleMediumView" title="Download" data-qa-hook="pdf-viewer-secondary-toolbar-download" tabindex="54" data-l10n-id="download">
          <span data-l10n-id="download_label">Download</span>
        </button>

        <a href="#" id="secondaryViewBookmark" class="secondaryToolbarButton bookmark visibleSmallView" title="Current view (copy or open in new window)" tabindex="55" data-l10n-id="bookmark">
          <span data-l10n-id="bookmark_label">Current View</span>
        </a>

        <div class="horizontalToolbarSeparator visibleLargeView"></div>

        <button id="firstPage" class="secondaryToolbarButton firstPage" title="Go to First Page" tabindex="56" data-l10n-id="first_page">
          <span data-l10n-id="first_page_label">Go to First Page</span>
        </button>
        <button id="lastPage" class="secondaryToolbarButton lastPage" title="Go to Last Page" tabindex="57" data-l10n-id="last_page">
          <span data-l10n-id="last_page_label">Go to Last Page</span>
        </button>

        <div class="horizontalToolbarSeparator"></div>

        <button id="pageRotateCw" class="secondaryToolbarButton rotateCw" title="Rotate Clockwise" tabindex="58" data-l10n-id="page_rotate_cw">
          <span data-l10n-id="page_rotate_cw_label">Rotate Clockwise</span>
        </button>
        <button id="pageRotateCcw" class="secondaryToolbarButton rotateCcw" title="Rotate Counterclockwise" tabindex="59" data-l10n-id="page_rotate_ccw">
          <span data-l10n-id="page_rotate_ccw_label">Rotate Counterclockwise</span>
        </button>

        <div class="horizontalToolbarSeparator"></div>

        <button id="cursorSelectTool" class="secondaryToolbarButton selectTool toggled" title="Enable Text Selection Tool" tabindex="60" data-l10n-id="cursor_text_select_tool">
          <span data-l10n-id="cursor_text_select_tool_label">Text Selection Tool</span>
        </button>
        <button id="cursorHandTool" class="secondaryToolbarButton handTool" title="Enable Hand Tool" tabindex="61" data-l10n-id="cursor_hand_tool">
          <span data-l10n-id="cursor_hand_tool_label">Hand Tool</span>
        </button>

        <div class="horizontalToolbarSeparator"></div>

        <button id="scrollVertical" class="secondaryToolbarButton scrollModeButtons scrollVertical toggled" title="Use Vertical Scrolling" tabindex="62" data-l10n-id="scroll_vertical">
          <span data-l10n-id="scroll_vertical_label">Vertical Scrolling</span>
        </button>
        <button id="scrollHorizontal" class="secondaryToolbarButton scrollModeButtons scrollHorizontal" title="Use Horizontal Scrolling" tabindex="63" data-l10n-id="scroll_horizontal">
          <span data-l10n-id="scroll_horizontal_label">Horizontal Scrolling</span>
        </button>
        <button id="scrollWrapped" class="secondaryToolbarButton scrollModeButtons scrollWrapped" title="Use Wrapped Scrolling" tabindex="64" data-l10n-id="scroll_wrapped">
          <span data-l10n-id="scroll_wrapped_label">Wrapped Scrolling</span>
        </button>

        <div class="horizontalToolbarSeparator scrollModeButtons"></div>

        <button id="spreadNone" class="secondaryToolbarButton spreadModeButtons spreadNone toggled" title="Do not join page spreads" tabindex="65" data-l10n-id="spread_none">
          <span data-l10n-id="spread_none_label">No Spreads</span>
        </button>
        <button id="spreadOdd" class="secondaryToolbarButton spreadModeButtons spreadOdd" title="Join page spreads starting with odd-numbered pages" tabindex="66" data-l10n-id="spread_odd">
          <span data-l10n-id="spread_odd_label">Odd Spreads</span>
        </button>
        <button id="spreadEven" class="secondaryToolbarButton spreadModeButtons spreadEven" title="Join page spreads starting with even-numbered pages" tabindex="67" data-l10n-id="spread_even">
          <span data-l10n-id="spread_even_label">Even Spreads</span>
        </button>

        <div class="horizontalToolbarSeparator spreadModeButtons"></div>

        <button id="documentProperties" class="secondaryToolbarButton documentProperties" title="Document Properties…" tabindex="68" data-l10n-id="document_properties">
          <span data-l10n-id="document_properties_label">Document Properties…</span>
        </button>
      </div>
    </div>  <!-- secondaryToolbar -->

    <div class="toolbar">
      <div id="toolbarContainer">
        <div id="toolbarViewer">
          <div id="toolbarViewerLeft">
            <button id="sidebarToggle" class="toolbarButton" title="Toggle Sidebar" tabindex="11" data-l10n-id="toggle_sidebar">
              <span data-l10n-id="toggle_sidebar_label">Toggle Sidebar</span>
            </button>
            <div class="toolbarButtonSpacer"></div>
            <button id="viewFind" class="toolbarButton" title="Find in Document" tabindex="12" data-l10n-id="findbar">
              <span data-l10n-id="findbar_label">Find</span>
            </button>
            <div class="splitToolbarButton hiddenSmallView">
              <button class="toolbarButton pageUp" title="Previous Page" id="previous" tabindex="13" data-l10n-id="previous">
                <span data-l10n-id="previous_label">Previous</span>
              </button>
              <div class="splitToolbarButtonSeparator"></div>
              <button class="toolbarButton pageDown" title="Next Page" id="next" tabindex="14" data-l10n-id="next">
                <span data-l10n-id="next_label">Next</span>
              </button>
            </div>
            <input type="number" id="pageNumber" class="toolbarField pageNumber" title="Page" value="1" size="4" min="1" tabindex="15" data-l10n-id="page" autocomplete="off">
            <span id="numPages" class="toolbarLabel"></span>
          </div>
          <div id="toolbarViewerRight">
            <button id="presentationMode" class="toolbarButton presentationMode hiddenLargeView" title="Switch to Presentation Mode" tabindex="31" data-l10n-id="presentation_mode">
              <span data-l10n-id="presentation_mode_label">Presentation Mode</span>
            </button>

            <button id="openFile" class="toolbarButton openFile hiddenLargeView" title="Open File" tabindex="32" data-l10n-id="open_file">
              <span data-l10n-id="open_file_label">Open</span>
            </button>

            <button id="print" class="toolbarButton print hiddenMediumView" title="Print" tabindex="33" data-l10n-id="print">
              <span data-l10n-id="print_label">Print</span>
            </button>

            <button id="download" class="toolbarButton download hiddenMediumView" data-qa-hook="pdf-viewer-toolbar-download" title="Download" tabindex="34" data-l10n-id="download" style="margin-right: 45px; display: none;">
              <span data-l10n-id="download_label">Download</span>
            </button>
            <a href="#" id="viewBookmark" class="toolbarButton bookmark hiddenSmallView" title="Current view (copy or open in new window)" tabindex="35" data-l10n-id="bookmark">
              <span data-l10n-id="bookmark_label">Current View</span>
            </a>

            <div class="verticalToolbarSeparator hiddenSmallView"></div>

            <button id="secondaryToolbarToggle" class="toolbarButton" title="Tools" tabindex="36" data-l10n-id="tools">
              <span data-l10n-id="tools_label">Tools</span>
            </button>
          </div>
          <div id="toolbarViewerMiddle">
            <div class="splitToolbarButton">
              <button id="zoomOut" class="toolbarButton zoomOut" title="Zoom Out" tabindex="21" data-l10n-id="zoom_out">
                <span data-l10n-id="zoom_out_label">Zoom Out</span>
              </button>
              <div class="splitToolbarButtonSeparator"></div>
              <button id="zoomIn" class="toolbarButton zoomIn" title="Zoom In" tabindex="22" data-l10n-id="zoom_in">
                <span data-l10n-id="zoom_in_label">Zoom In</span>
                </button>
            </div>
            <span id="scaleSelectContainer" class="dropdownToolbarButton">
              <select id="scaleSelect" title="Zoom" tabindex="23" data-l10n-id="zoom">
                <option id="pageAutoOption" title="" value="auto" selected="selected" data-l10n-id="page_scale_auto">Automatic Zoom</option>
                <option id="pageActualOption" title="" value="page-actual" data-l10n-id="page_scale_actual">Actual Size</option>
                <option id="pageFitOption" title="" value="page-fit" data-l10n-id="page_scale_fit">Page Fit</option>
                <option id="pageWidthOption" title="" value="page-width" data-l10n-id="page_scale_width">Page Width</option>
                <option id="customScaleOption" title="" value="custom" disabled="disabled" hidden="true"></option>
                <option title="" value="0.5" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 50 }'>50%</option>
                <option title="" value="0.75" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 75 }'>75%</option>
                <option title="" value="1" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 100 }'>100%</option>
                <option title="" value="1.25" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 125 }'>125%</option>
                <option title="" value="1.5" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 150 }'>150%</option>
                <option title="" value="2" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 200 }'>200%</option>
                <option title="" value="3" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 300 }'>300%</option>
                <option title="" value="4" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 400 }'>400%</option>
              </select>
            </span>
          </div>
        </div>
        <div id="loadingBar">
          <div class="progress">
            <div class="glimmer">
            </div>
          </div>
        </div>
      </div>
    </div>

    <menu type="context" id="viewerContextMenu">
      <menuitem id="contextFirstPage" label="First Page"
                data-l10n-id="first_page"></menuitem>
      <menuitem id="contextLastPage" label="Last Page"
                data-l10n-id="last_page"></menuitem>
      <menuitem id="contextPageRotateCw" label="Rotate Clockwise"
                data-l10n-id="page_rotate_cw"></menuitem>
      <menuitem id="contextPageRotateCcw" label="Rotate Counter-Clockwise"
                data-l10n-id="page_rotate_ccw"></menuitem>
    </menu>

    <div id="viewerContainer" tabindex="0">
      <div id="viewer" class="pdfViewer"></div>
    </div>

    <div id="errorWrapper" hidden='true'>
      <div id="errorMessageLeft">
        <span id="errorMessage"></span>
        <button id="errorShowMore" data-l10n-id="error_more_info">
          More Information
        </button>
        <button id="errorShowLess" data-l10n-id="error_less_info" hidden='true'>
          Less Information
        </button>
      </div>
      <div id="errorMessageRight">
        <button id="errorClose" data-l10n-id="error_close">
          Close
        </button>
      </div>
      <div class="clearBoth"></div>
      <textarea id="errorMoreInfo" hidden='true' readonly="readonly"></textarea>
    </div>
  </div> <!-- mainContainer -->

  <div id="overlayContainer" class="hidden">
    <div id="passwordOverlay" class="container hidden">
      <div class="dialog">
        <div class="row">
          <p id="passwordText" data-l10n-id="password_label">Enter the password to open this PDF file:</p>
        </div>
        <div class="row">
          <input type="password" id="password" class="toolbarField">
        </div>
        <div class="buttonRow">
          <button id="passwordCancel" class="overlayButton"><span data-l10n-id="password_cancel">Cancel</span></button>
          <button id="passwordSubmit" class="overlayButton"><span data-l10n-id="password_ok">OK</span></button>
        </div>
      </div>
    </div>
    <div id="documentPropertiesOverlay" class="container hidden">
      <div class="dialog">
        <div class="row">
          <span data-l10n-id="document_properties_file_name">File name:</span> <p id="fileNameField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_file_size">File size:</span> <p id="fileSizeField">-</p>
        </div>
        <div class="separator"></div>
        <div class="row">
          <span data-l10n-id="document_properties_title">Title:</span> <p id="titleField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_author">Author:</span> <p id="authorField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_subject">Subject:</span> <p id="subjectField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_keywords">Keywords:</span> <p id="keywordsField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_creation_date">Creation Date:</span> <p id="creationDateField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_modification_date">Modification Date:</span> <p id="modificationDateField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_creator">Creator:</span> <p id="creatorField">-</p>
        </div>
        <div class="separator"></div>
        <div class="row">
          <span data-l10n-id="document_properties_producer">PDF Producer:</span> <p id="producerField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_version">PDF Version:</span> <p id="versionField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_page_count">Page Count:</span> <p id="pageCountField">-</p>
        </div>
        <div class="row">
          <span data-l10n-id="document_properties_page_size">Page Size:</span> <p id="pageSizeField">-</p>
        </div>
        <div class="separator"></div>
        <div class="row">
          <span data-l10n-id="document_properties_linearized">Fast Web View:</span> <p id="linearizedField">-</p>
        </div>
        <div class="buttonRow">
          <button id="documentPropertiesClose" class="overlayButton"><span data-l10n-id="document_properties_close">Close</span></button>
        </div>
      </div>
    </div>
    <div id="printServiceOverlay" class="container hidden">
      <div class="dialog">
        <div class="row">
          <span data-l10n-id="print_progress_message">Preparing document for printing…</span>
        </div>
        <div class="row">
          <progress value="0" max="100"></progress>
          <span data-l10n-id="print_progress_percent" data-l10n-args='{ "progress": 0 }' class="relative-progress">0%</span>
        </div>
        <div class="buttonRow">
          <button id="printCancel" class="overlayButton"><span data-l10n-id="print_progress_close">Cancel</span></button>
        </div>
      </div>
    </div>
  </div>  <!-- overlayContainer -->

</div> <!-- outerContainer -->
<div id="printContainer"></div>


    </div>



      <script>
  (function(j,u,k,e,b,o,x){j[b]=j[b]||function(){
  (j[b].q=j[b].q||[]).push(arguments)},j[b].l=1*new Date();o=u.createElement(k),
  x=u.getElementsByTagName(k)[0];o.async=1;o.src=e;x.parentNode.insertBefore(o,x)
})(window,document,"script","https://app.cdn.lookbookhq.com/production/jukebox/current/tracks.js?x=2","lbhq");

  lbhq("create", "LB-F4A92B32-10336")

</script>



      <style>
        .white-popup {
    margin-top: 20px !important;
    }
</style>
    <div id="jukebox-app"></div>
  </body>
</html>
